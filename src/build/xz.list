
build/xz.elf:     file format elf32-littlearm


Disassembly of section .text:

00000410 <Reset_Handler>:
     410:	b672      	cpsid	i
     412:	4837      	ldr	r0, [pc, #220]	; (4f0 <endfiniloop+0x6>)
     414:	f380 8809 	msr	PSP, r0
     418:	4836      	ldr	r0, [pc, #216]	; (4f4 <endfiniloop+0xa>)
     41a:	f64e 5108 	movw	r1, #60680	; 0xed08
     41e:	f2ce 0100 	movt	r1, #57344	; 0xe000
     422:	6008      	str	r0, [r1, #0]
     424:	f240 0000 	movw	r0, #0
     428:	f2cc 0000 	movt	r0, #49152	; 0xc000
     42c:	f64e 7134 	movw	r1, #61236	; 0xef34
     430:	f2ce 0100 	movt	r1, #57344	; 0xe000
     434:	6008      	str	r0, [r1, #0]
     436:	f3bf 8f4f 	dsb	sy
     43a:	f3bf 8f6f 	isb	sy
     43e:	f240 0000 	movw	r0, #0
     442:	f2c0 00f0 	movt	r0, #240	; 0xf0
     446:	f64e 5188 	movw	r1, #60808	; 0xed88
     44a:	f2ce 0100 	movt	r1, #57344	; 0xe000
     44e:	6008      	str	r0, [r1, #0]
     450:	f3bf 8f4f 	dsb	sy
     454:	f3bf 8f6f 	isb	sy
     458:	f04f 0000 	mov.w	r0, #0
     45c:	eee1 0a10 	vmsr	fpscr, r0
     460:	f64e 713c 	movw	r1, #61244	; 0xef3c
     464:	f2ce 0100 	movt	r1, #57344	; 0xe000
     468:	6008      	str	r0, [r1, #0]
     46a:	2006      	movs	r0, #6
     46c:	f380 8814 	msr	CONTROL, r0
     470:	f3bf 8f6f 	isb	sy
     474:	f000 fcdc 	bl	e30 <__core_init>
     478:	f003 fe5a 	bl	4130 <__early_init>
     47c:	481e      	ldr	r0, [pc, #120]	; (4f8 <endfiniloop+0xe>)
     47e:	491f      	ldr	r1, [pc, #124]	; (4fc <endfiniloop+0x12>)
     480:	4a1f      	ldr	r2, [pc, #124]	; (500 <endfiniloop+0x16>)

00000482 <msloop>:
     482:	4291      	cmp	r1, r2
     484:	bf3c      	itt	cc
     486:	f841 0b04 	strcc.w	r0, [r1], #4
     48a:	e7fa      	bcc.n	482 <msloop>
     48c:	491d      	ldr	r1, [pc, #116]	; (504 <endfiniloop+0x1a>)
     48e:	4a18      	ldr	r2, [pc, #96]	; (4f0 <endfiniloop+0x6>)

00000490 <psloop>:
     490:	4291      	cmp	r1, r2
     492:	bf3c      	itt	cc
     494:	f841 0b04 	strcc.w	r0, [r1], #4
     498:	e7fa      	bcc.n	490 <psloop>
     49a:	491b      	ldr	r1, [pc, #108]	; (508 <endfiniloop+0x1e>)
     49c:	4a1b      	ldr	r2, [pc, #108]	; (50c <endfiniloop+0x22>)
     49e:	4b1c      	ldr	r3, [pc, #112]	; (510 <endfiniloop+0x26>)

000004a0 <dloop>:
     4a0:	429a      	cmp	r2, r3
     4a2:	bf3e      	ittt	cc
     4a4:	f851 0b04 	ldrcc.w	r0, [r1], #4
     4a8:	f842 0b04 	strcc.w	r0, [r2], #4
     4ac:	e7f8      	bcc.n	4a0 <dloop>
     4ae:	2000      	movs	r0, #0
     4b0:	4918      	ldr	r1, [pc, #96]	; (514 <endfiniloop+0x2a>)
     4b2:	4a19      	ldr	r2, [pc, #100]	; (518 <endfiniloop+0x2e>)

000004b4 <bloop>:
     4b4:	4291      	cmp	r1, r2
     4b6:	bf3c      	itt	cc
     4b8:	f841 0b04 	strcc.w	r0, [r1], #4
     4bc:	e7fa      	bcc.n	4b4 <bloop>
     4be:	f000 fccf 	bl	e60 <__init_ram_areas>
     4c2:	f000 fcbd 	bl	e40 <__late_init>
     4c6:	4c15      	ldr	r4, [pc, #84]	; (51c <endfiniloop+0x32>)
     4c8:	4d15      	ldr	r5, [pc, #84]	; (520 <endfiniloop+0x36>)

000004ca <initloop>:
     4ca:	42ac      	cmp	r4, r5
     4cc:	da03      	bge.n	4d6 <endinitloop>
     4ce:	f854 1b04 	ldr.w	r1, [r4], #4
     4d2:	4788      	blx	r1
     4d4:	e7f9      	b.n	4ca <initloop>

000004d6 <endinitloop>:
     4d6:	f004 fdb3 	bl	5040 <main>
     4da:	4c12      	ldr	r4, [pc, #72]	; (524 <endfiniloop+0x3a>)
     4dc:	4d12      	ldr	r5, [pc, #72]	; (528 <endfiniloop+0x3e>)

000004de <finiloop>:
     4de:	42ac      	cmp	r4, r5
     4e0:	da03      	bge.n	4ea <endfiniloop>
     4e2:	f854 1b04 	ldr.w	r1, [r4], #4
     4e6:	4788      	blx	r1
     4e8:	e7f9      	b.n	4de <finiloop>

000004ea <endfiniloop>:
     4ea:	f000 bcb1 	b.w	e50 <__default_exit>
     4ee:	0000      	.short	0x0000
     4f0:	1ffff000 	.word	0x1ffff000
     4f4:	00000000 	.word	0x00000000
     4f8:	55555555 	.word	0x55555555
     4fc:	1fffe000 	.word	0x1fffe000
     500:	1fffe800 	.word	0x1fffe800
     504:	1fffe800 	.word	0x1fffe800
     508:	00007f78 	.word	0x00007f78
     50c:	1ffff000 	.word	0x1ffff000
     510:	1ffff0a4 	.word	0x1ffff0a4
     514:	1ffff0a8 	.word	0x1ffff0a8
     518:	20000584 	.word	0x20000584
     51c:	00000410 	.word	0x00000410
     520:	00000410 	.word	0x00000410
     524:	00000410 	.word	0x00000410
     528:	00000410 	.word	0x00000410
     52c:	00000000 	.word	0x00000000

00000530 <_port_switch>:
     530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     534:	ed2d 8a10 	vpush	{s16-s31}
     538:	f8c1 d00c 	str.w	sp, [r1, #12]
     53c:	68c3      	ldr	r3, [r0, #12]
     53e:	469d      	mov	sp, r3
     540:	ecbd 8a10 	vpop	{s16-s31}
     544:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000548 <_port_thread_start>:
     548:	f000 fd82 	bl	1050 <_dbg_check_unlock>
     54c:	f001 fbb8 	bl	1cc0 <_stats_stop_measure_crit_thd>
     550:	2300      	movs	r3, #0
     552:	f383 8811 	msr	BASEPRI, r3
     556:	4628      	mov	r0, r5
     558:	47a0      	blx	r4
     55a:	2000      	movs	r0, #0
     55c:	f001 f9f8 	bl	1950 <chThdExit>

00000560 <_port_switch_from_isr>:
     560:	f001 fba6 	bl	1cb0 <_stats_start_measure_crit_thd>
     564:	f000 fd64 	bl	1030 <_dbg_check_lock>
     568:	f001 f80a 	bl	1580 <chSchDoReschedule>
     56c:	f000 fd70 	bl	1050 <_dbg_check_unlock>
     570:	f001 fba6 	bl	1cc0 <_stats_stop_measure_crit_thd>

00000574 <_port_exit_from_isr>:
     574:	df00      	svc	0
     576:	e7fe      	b.n	576 <_port_exit_from_isr+0x2>
	...

00000580 <__aeabi_drsub>:
     580:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
     584:	e002      	b.n	58c <__adddf3>
     586:	bf00      	nop

00000588 <__aeabi_dsub>:
     588:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000058c <__adddf3>:
     58c:	b530      	push	{r4, r5, lr}
     58e:	ea4f 0441 	mov.w	r4, r1, lsl #1
     592:	ea4f 0543 	mov.w	r5, r3, lsl #1
     596:	ea94 0f05 	teq	r4, r5
     59a:	bf08      	it	eq
     59c:	ea90 0f02 	teqeq	r0, r2
     5a0:	bf1f      	itttt	ne
     5a2:	ea54 0c00 	orrsne.w	ip, r4, r0
     5a6:	ea55 0c02 	orrsne.w	ip, r5, r2
     5aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
     5ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     5b2:	f000 80e2 	beq.w	77a <__adddf3+0x1ee>
     5b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
     5ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
     5be:	bfb8      	it	lt
     5c0:	426d      	neglt	r5, r5
     5c2:	dd0c      	ble.n	5de <__adddf3+0x52>
     5c4:	442c      	add	r4, r5
     5c6:	ea80 0202 	eor.w	r2, r0, r2
     5ca:	ea81 0303 	eor.w	r3, r1, r3
     5ce:	ea82 0000 	eor.w	r0, r2, r0
     5d2:	ea83 0101 	eor.w	r1, r3, r1
     5d6:	ea80 0202 	eor.w	r2, r0, r2
     5da:	ea81 0303 	eor.w	r3, r1, r3
     5de:	2d36      	cmp	r5, #54	; 0x36
     5e0:	bf88      	it	hi
     5e2:	bd30      	pophi	{r4, r5, pc}
     5e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     5e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
     5ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
     5f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
     5f4:	d002      	beq.n	5fc <__adddf3+0x70>
     5f6:	4240      	negs	r0, r0
     5f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     5fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
     600:	ea4f 3303 	mov.w	r3, r3, lsl #12
     604:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
     608:	d002      	beq.n	610 <__adddf3+0x84>
     60a:	4252      	negs	r2, r2
     60c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     610:	ea94 0f05 	teq	r4, r5
     614:	f000 80a7 	beq.w	766 <__adddf3+0x1da>
     618:	f1a4 0401 	sub.w	r4, r4, #1
     61c:	f1d5 0e20 	rsbs	lr, r5, #32
     620:	db0d      	blt.n	63e <__adddf3+0xb2>
     622:	fa02 fc0e 	lsl.w	ip, r2, lr
     626:	fa22 f205 	lsr.w	r2, r2, r5
     62a:	1880      	adds	r0, r0, r2
     62c:	f141 0100 	adc.w	r1, r1, #0
     630:	fa03 f20e 	lsl.w	r2, r3, lr
     634:	1880      	adds	r0, r0, r2
     636:	fa43 f305 	asr.w	r3, r3, r5
     63a:	4159      	adcs	r1, r3
     63c:	e00e      	b.n	65c <__adddf3+0xd0>
     63e:	f1a5 0520 	sub.w	r5, r5, #32
     642:	f10e 0e20 	add.w	lr, lr, #32
     646:	2a01      	cmp	r2, #1
     648:	fa03 fc0e 	lsl.w	ip, r3, lr
     64c:	bf28      	it	cs
     64e:	f04c 0c02 	orrcs.w	ip, ip, #2
     652:	fa43 f305 	asr.w	r3, r3, r5
     656:	18c0      	adds	r0, r0, r3
     658:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
     65c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     660:	d507      	bpl.n	672 <__adddf3+0xe6>
     662:	f04f 0e00 	mov.w	lr, #0
     666:	f1dc 0c00 	rsbs	ip, ip, #0
     66a:	eb7e 0000 	sbcs.w	r0, lr, r0
     66e:	eb6e 0101 	sbc.w	r1, lr, r1
     672:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
     676:	d31b      	bcc.n	6b0 <__adddf3+0x124>
     678:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
     67c:	d30c      	bcc.n	698 <__adddf3+0x10c>
     67e:	0849      	lsrs	r1, r1, #1
     680:	ea5f 0030 	movs.w	r0, r0, rrx
     684:	ea4f 0c3c 	mov.w	ip, ip, rrx
     688:	f104 0401 	add.w	r4, r4, #1
     68c:	ea4f 5244 	mov.w	r2, r4, lsl #21
     690:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
     694:	f080 809a 	bcs.w	7cc <__adddf3+0x240>
     698:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     69c:	bf08      	it	eq
     69e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     6a2:	f150 0000 	adcs.w	r0, r0, #0
     6a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     6aa:	ea41 0105 	orr.w	r1, r1, r5
     6ae:	bd30      	pop	{r4, r5, pc}
     6b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
     6b4:	4140      	adcs	r0, r0
     6b6:	eb41 0101 	adc.w	r1, r1, r1
     6ba:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     6be:	f1a4 0401 	sub.w	r4, r4, #1
     6c2:	d1e9      	bne.n	698 <__adddf3+0x10c>
     6c4:	f091 0f00 	teq	r1, #0
     6c8:	bf04      	itt	eq
     6ca:	4601      	moveq	r1, r0
     6cc:	2000      	moveq	r0, #0
     6ce:	fab1 f381 	clz	r3, r1
     6d2:	bf08      	it	eq
     6d4:	3320      	addeq	r3, #32
     6d6:	f1a3 030b 	sub.w	r3, r3, #11
     6da:	f1b3 0220 	subs.w	r2, r3, #32
     6de:	da0c      	bge.n	6fa <__adddf3+0x16e>
     6e0:	320c      	adds	r2, #12
     6e2:	dd08      	ble.n	6f6 <__adddf3+0x16a>
     6e4:	f102 0c14 	add.w	ip, r2, #20
     6e8:	f1c2 020c 	rsb	r2, r2, #12
     6ec:	fa01 f00c 	lsl.w	r0, r1, ip
     6f0:	fa21 f102 	lsr.w	r1, r1, r2
     6f4:	e00c      	b.n	710 <__adddf3+0x184>
     6f6:	f102 0214 	add.w	r2, r2, #20
     6fa:	bfd8      	it	le
     6fc:	f1c2 0c20 	rsble	ip, r2, #32
     700:	fa01 f102 	lsl.w	r1, r1, r2
     704:	fa20 fc0c 	lsr.w	ip, r0, ip
     708:	bfdc      	itt	le
     70a:	ea41 010c 	orrle.w	r1, r1, ip
     70e:	4090      	lslle	r0, r2
     710:	1ae4      	subs	r4, r4, r3
     712:	bfa2      	ittt	ge
     714:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
     718:	4329      	orrge	r1, r5
     71a:	bd30      	popge	{r4, r5, pc}
     71c:	ea6f 0404 	mvn.w	r4, r4
     720:	3c1f      	subs	r4, #31
     722:	da1c      	bge.n	75e <__adddf3+0x1d2>
     724:	340c      	adds	r4, #12
     726:	dc0e      	bgt.n	746 <__adddf3+0x1ba>
     728:	f104 0414 	add.w	r4, r4, #20
     72c:	f1c4 0220 	rsb	r2, r4, #32
     730:	fa20 f004 	lsr.w	r0, r0, r4
     734:	fa01 f302 	lsl.w	r3, r1, r2
     738:	ea40 0003 	orr.w	r0, r0, r3
     73c:	fa21 f304 	lsr.w	r3, r1, r4
     740:	ea45 0103 	orr.w	r1, r5, r3
     744:	bd30      	pop	{r4, r5, pc}
     746:	f1c4 040c 	rsb	r4, r4, #12
     74a:	f1c4 0220 	rsb	r2, r4, #32
     74e:	fa20 f002 	lsr.w	r0, r0, r2
     752:	fa01 f304 	lsl.w	r3, r1, r4
     756:	ea40 0003 	orr.w	r0, r0, r3
     75a:	4629      	mov	r1, r5
     75c:	bd30      	pop	{r4, r5, pc}
     75e:	fa21 f004 	lsr.w	r0, r1, r4
     762:	4629      	mov	r1, r5
     764:	bd30      	pop	{r4, r5, pc}
     766:	f094 0f00 	teq	r4, #0
     76a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
     76e:	bf06      	itte	eq
     770:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
     774:	3401      	addeq	r4, #1
     776:	3d01      	subne	r5, #1
     778:	e74e      	b.n	618 <__adddf3+0x8c>
     77a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     77e:	bf18      	it	ne
     780:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     784:	d029      	beq.n	7da <__adddf3+0x24e>
     786:	ea94 0f05 	teq	r4, r5
     78a:	bf08      	it	eq
     78c:	ea90 0f02 	teqeq	r0, r2
     790:	d005      	beq.n	79e <__adddf3+0x212>
     792:	ea54 0c00 	orrs.w	ip, r4, r0
     796:	bf04      	itt	eq
     798:	4619      	moveq	r1, r3
     79a:	4610      	moveq	r0, r2
     79c:	bd30      	pop	{r4, r5, pc}
     79e:	ea91 0f03 	teq	r1, r3
     7a2:	bf1e      	ittt	ne
     7a4:	2100      	movne	r1, #0
     7a6:	2000      	movne	r0, #0
     7a8:	bd30      	popne	{r4, r5, pc}
     7aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
     7ae:	d105      	bne.n	7bc <__adddf3+0x230>
     7b0:	0040      	lsls	r0, r0, #1
     7b2:	4149      	adcs	r1, r1
     7b4:	bf28      	it	cs
     7b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
     7ba:	bd30      	pop	{r4, r5, pc}
     7bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
     7c0:	bf3c      	itt	cc
     7c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
     7c6:	bd30      	popcc	{r4, r5, pc}
     7c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     7cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
     7d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     7d4:	f04f 0000 	mov.w	r0, #0
     7d8:	bd30      	pop	{r4, r5, pc}
     7da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     7de:	bf1a      	itte	ne
     7e0:	4619      	movne	r1, r3
     7e2:	4610      	movne	r0, r2
     7e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
     7e8:	bf1c      	itt	ne
     7ea:	460b      	movne	r3, r1
     7ec:	4602      	movne	r2, r0
     7ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     7f2:	bf06      	itte	eq
     7f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
     7f8:	ea91 0f03 	teqeq	r1, r3
     7fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
     800:	bd30      	pop	{r4, r5, pc}
     802:	bf00      	nop

00000804 <__aeabi_ui2d>:
     804:	f090 0f00 	teq	r0, #0
     808:	bf04      	itt	eq
     80a:	2100      	moveq	r1, #0
     80c:	4770      	bxeq	lr
     80e:	b530      	push	{r4, r5, lr}
     810:	f44f 6480 	mov.w	r4, #1024	; 0x400
     814:	f104 0432 	add.w	r4, r4, #50	; 0x32
     818:	f04f 0500 	mov.w	r5, #0
     81c:	f04f 0100 	mov.w	r1, #0
     820:	e750      	b.n	6c4 <__adddf3+0x138>
     822:	bf00      	nop

00000824 <__aeabi_i2d>:
     824:	f090 0f00 	teq	r0, #0
     828:	bf04      	itt	eq
     82a:	2100      	moveq	r1, #0
     82c:	4770      	bxeq	lr
     82e:	b530      	push	{r4, r5, lr}
     830:	f44f 6480 	mov.w	r4, #1024	; 0x400
     834:	f104 0432 	add.w	r4, r4, #50	; 0x32
     838:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
     83c:	bf48      	it	mi
     83e:	4240      	negmi	r0, r0
     840:	f04f 0100 	mov.w	r1, #0
     844:	e73e      	b.n	6c4 <__adddf3+0x138>
     846:	bf00      	nop

00000848 <__aeabi_f2d>:
     848:	0042      	lsls	r2, r0, #1
     84a:	ea4f 01e2 	mov.w	r1, r2, asr #3
     84e:	ea4f 0131 	mov.w	r1, r1, rrx
     852:	ea4f 7002 	mov.w	r0, r2, lsl #28
     856:	bf1f      	itttt	ne
     858:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
     85c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     860:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
     864:	4770      	bxne	lr
     866:	f092 0f00 	teq	r2, #0
     86a:	bf14      	ite	ne
     86c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     870:	4770      	bxeq	lr
     872:	b530      	push	{r4, r5, lr}
     874:	f44f 7460 	mov.w	r4, #896	; 0x380
     878:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     87c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     880:	e720      	b.n	6c4 <__adddf3+0x138>
     882:	bf00      	nop

00000884 <__aeabi_ul2d>:
     884:	ea50 0201 	orrs.w	r2, r0, r1
     888:	bf08      	it	eq
     88a:	4770      	bxeq	lr
     88c:	b530      	push	{r4, r5, lr}
     88e:	f04f 0500 	mov.w	r5, #0
     892:	e00a      	b.n	8aa <__aeabi_l2d+0x16>

00000894 <__aeabi_l2d>:
     894:	ea50 0201 	orrs.w	r2, r0, r1
     898:	bf08      	it	eq
     89a:	4770      	bxeq	lr
     89c:	b530      	push	{r4, r5, lr}
     89e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
     8a2:	d502      	bpl.n	8aa <__aeabi_l2d+0x16>
     8a4:	4240      	negs	r0, r0
     8a6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     8aa:	f44f 6480 	mov.w	r4, #1024	; 0x400
     8ae:	f104 0432 	add.w	r4, r4, #50	; 0x32
     8b2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
     8b6:	f43f aedc 	beq.w	672 <__adddf3+0xe6>
     8ba:	f04f 0203 	mov.w	r2, #3
     8be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     8c2:	bf18      	it	ne
     8c4:	3203      	addne	r2, #3
     8c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     8ca:	bf18      	it	ne
     8cc:	3203      	addne	r2, #3
     8ce:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
     8d2:	f1c2 0320 	rsb	r3, r2, #32
     8d6:	fa00 fc03 	lsl.w	ip, r0, r3
     8da:	fa20 f002 	lsr.w	r0, r0, r2
     8de:	fa01 fe03 	lsl.w	lr, r1, r3
     8e2:	ea40 000e 	orr.w	r0, r0, lr
     8e6:	fa21 f102 	lsr.w	r1, r1, r2
     8ea:	4414      	add	r4, r2
     8ec:	e6c1      	b.n	672 <__adddf3+0xe6>
     8ee:	bf00      	nop

000008f0 <__aeabi_dmul>:
     8f0:	b570      	push	{r4, r5, r6, lr}
     8f2:	f04f 0cff 	mov.w	ip, #255	; 0xff
     8f6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     8fa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     8fe:	bf1d      	ittte	ne
     900:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     904:	ea94 0f0c 	teqne	r4, ip
     908:	ea95 0f0c 	teqne	r5, ip
     90c:	f000 f8de 	bleq	acc <__aeabi_dmul+0x1dc>
     910:	442c      	add	r4, r5
     912:	ea81 0603 	eor.w	r6, r1, r3
     916:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
     91a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
     91e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
     922:	bf18      	it	ne
     924:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
     928:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     92c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
     930:	d038      	beq.n	9a4 <__aeabi_dmul+0xb4>
     932:	fba0 ce02 	umull	ip, lr, r0, r2
     936:	f04f 0500 	mov.w	r5, #0
     93a:	fbe1 e502 	umlal	lr, r5, r1, r2
     93e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
     942:	fbe0 e503 	umlal	lr, r5, r0, r3
     946:	f04f 0600 	mov.w	r6, #0
     94a:	fbe1 5603 	umlal	r5, r6, r1, r3
     94e:	f09c 0f00 	teq	ip, #0
     952:	bf18      	it	ne
     954:	f04e 0e01 	orrne.w	lr, lr, #1
     958:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
     95c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
     960:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
     964:	d204      	bcs.n	970 <__aeabi_dmul+0x80>
     966:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
     96a:	416d      	adcs	r5, r5
     96c:	eb46 0606 	adc.w	r6, r6, r6
     970:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
     974:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
     978:	ea4f 20c5 	mov.w	r0, r5, lsl #11
     97c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
     980:	ea4f 2ece 	mov.w	lr, lr, lsl #11
     984:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     988:	bf88      	it	hi
     98a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     98e:	d81e      	bhi.n	9ce <__aeabi_dmul+0xde>
     990:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
     994:	bf08      	it	eq
     996:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
     99a:	f150 0000 	adcs.w	r0, r0, #0
     99e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     9a2:	bd70      	pop	{r4, r5, r6, pc}
     9a4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
     9a8:	ea46 0101 	orr.w	r1, r6, r1
     9ac:	ea40 0002 	orr.w	r0, r0, r2
     9b0:	ea81 0103 	eor.w	r1, r1, r3
     9b4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
     9b8:	bfc2      	ittt	gt
     9ba:	ebd4 050c 	rsbsgt	r5, r4, ip
     9be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     9c2:	bd70      	popgt	{r4, r5, r6, pc}
     9c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     9c8:	f04f 0e00 	mov.w	lr, #0
     9cc:	3c01      	subs	r4, #1
     9ce:	f300 80ab 	bgt.w	b28 <__aeabi_dmul+0x238>
     9d2:	f114 0f36 	cmn.w	r4, #54	; 0x36
     9d6:	bfde      	ittt	le
     9d8:	2000      	movle	r0, #0
     9da:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
     9de:	bd70      	pople	{r4, r5, r6, pc}
     9e0:	f1c4 0400 	rsb	r4, r4, #0
     9e4:	3c20      	subs	r4, #32
     9e6:	da35      	bge.n	a54 <__aeabi_dmul+0x164>
     9e8:	340c      	adds	r4, #12
     9ea:	dc1b      	bgt.n	a24 <__aeabi_dmul+0x134>
     9ec:	f104 0414 	add.w	r4, r4, #20
     9f0:	f1c4 0520 	rsb	r5, r4, #32
     9f4:	fa00 f305 	lsl.w	r3, r0, r5
     9f8:	fa20 f004 	lsr.w	r0, r0, r4
     9fc:	fa01 f205 	lsl.w	r2, r1, r5
     a00:	ea40 0002 	orr.w	r0, r0, r2
     a04:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
     a08:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     a0c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     a10:	fa21 f604 	lsr.w	r6, r1, r4
     a14:	eb42 0106 	adc.w	r1, r2, r6
     a18:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     a1c:	bf08      	it	eq
     a1e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     a22:	bd70      	pop	{r4, r5, r6, pc}
     a24:	f1c4 040c 	rsb	r4, r4, #12
     a28:	f1c4 0520 	rsb	r5, r4, #32
     a2c:	fa00 f304 	lsl.w	r3, r0, r4
     a30:	fa20 f005 	lsr.w	r0, r0, r5
     a34:	fa01 f204 	lsl.w	r2, r1, r4
     a38:	ea40 0002 	orr.w	r0, r0, r2
     a3c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     a40:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     a44:	f141 0100 	adc.w	r1, r1, #0
     a48:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     a4c:	bf08      	it	eq
     a4e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     a52:	bd70      	pop	{r4, r5, r6, pc}
     a54:	f1c4 0520 	rsb	r5, r4, #32
     a58:	fa00 f205 	lsl.w	r2, r0, r5
     a5c:	ea4e 0e02 	orr.w	lr, lr, r2
     a60:	fa20 f304 	lsr.w	r3, r0, r4
     a64:	fa01 f205 	lsl.w	r2, r1, r5
     a68:	ea43 0302 	orr.w	r3, r3, r2
     a6c:	fa21 f004 	lsr.w	r0, r1, r4
     a70:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     a74:	fa21 f204 	lsr.w	r2, r1, r4
     a78:	ea20 0002 	bic.w	r0, r0, r2
     a7c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
     a80:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     a84:	bf08      	it	eq
     a86:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     a8a:	bd70      	pop	{r4, r5, r6, pc}
     a8c:	f094 0f00 	teq	r4, #0
     a90:	d10f      	bne.n	ab2 <__aeabi_dmul+0x1c2>
     a92:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
     a96:	0040      	lsls	r0, r0, #1
     a98:	eb41 0101 	adc.w	r1, r1, r1
     a9c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     aa0:	bf08      	it	eq
     aa2:	3c01      	subeq	r4, #1
     aa4:	d0f7      	beq.n	a96 <__aeabi_dmul+0x1a6>
     aa6:	ea41 0106 	orr.w	r1, r1, r6
     aaa:	f095 0f00 	teq	r5, #0
     aae:	bf18      	it	ne
     ab0:	4770      	bxne	lr
     ab2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
     ab6:	0052      	lsls	r2, r2, #1
     ab8:	eb43 0303 	adc.w	r3, r3, r3
     abc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
     ac0:	bf08      	it	eq
     ac2:	3d01      	subeq	r5, #1
     ac4:	d0f7      	beq.n	ab6 <__aeabi_dmul+0x1c6>
     ac6:	ea43 0306 	orr.w	r3, r3, r6
     aca:	4770      	bx	lr
     acc:	ea94 0f0c 	teq	r4, ip
     ad0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
     ad4:	bf18      	it	ne
     ad6:	ea95 0f0c 	teqne	r5, ip
     ada:	d00c      	beq.n	af6 <__aeabi_dmul+0x206>
     adc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     ae0:	bf18      	it	ne
     ae2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     ae6:	d1d1      	bne.n	a8c <__aeabi_dmul+0x19c>
     ae8:	ea81 0103 	eor.w	r1, r1, r3
     aec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     af0:	f04f 0000 	mov.w	r0, #0
     af4:	bd70      	pop	{r4, r5, r6, pc}
     af6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     afa:	bf06      	itte	eq
     afc:	4610      	moveq	r0, r2
     afe:	4619      	moveq	r1, r3
     b00:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     b04:	d019      	beq.n	b3a <__aeabi_dmul+0x24a>
     b06:	ea94 0f0c 	teq	r4, ip
     b0a:	d102      	bne.n	b12 <__aeabi_dmul+0x222>
     b0c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
     b10:	d113      	bne.n	b3a <__aeabi_dmul+0x24a>
     b12:	ea95 0f0c 	teq	r5, ip
     b16:	d105      	bne.n	b24 <__aeabi_dmul+0x234>
     b18:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
     b1c:	bf1c      	itt	ne
     b1e:	4610      	movne	r0, r2
     b20:	4619      	movne	r1, r3
     b22:	d10a      	bne.n	b3a <__aeabi_dmul+0x24a>
     b24:	ea81 0103 	eor.w	r1, r1, r3
     b28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     b2c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
     b30:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     b34:	f04f 0000 	mov.w	r0, #0
     b38:	bd70      	pop	{r4, r5, r6, pc}
     b3a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
     b3e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
     b42:	bd70      	pop	{r4, r5, r6, pc}

00000b44 <__aeabi_ddiv>:
     b44:	b570      	push	{r4, r5, r6, lr}
     b46:	f04f 0cff 	mov.w	ip, #255	; 0xff
     b4a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     b4e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     b52:	bf1d      	ittte	ne
     b54:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     b58:	ea94 0f0c 	teqne	r4, ip
     b5c:	ea95 0f0c 	teqne	r5, ip
     b60:	f000 f8a7 	bleq	cb2 <__aeabi_ddiv+0x16e>
     b64:	eba4 0405 	sub.w	r4, r4, r5
     b68:	ea81 0e03 	eor.w	lr, r1, r3
     b6c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
     b70:	ea4f 3101 	mov.w	r1, r1, lsl #12
     b74:	f000 8088 	beq.w	c88 <__aeabi_ddiv+0x144>
     b78:	ea4f 3303 	mov.w	r3, r3, lsl #12
     b7c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
     b80:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
     b84:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
     b88:	ea4f 2202 	mov.w	r2, r2, lsl #8
     b8c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
     b90:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
     b94:	ea4f 2600 	mov.w	r6, r0, lsl #8
     b98:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
     b9c:	429d      	cmp	r5, r3
     b9e:	bf08      	it	eq
     ba0:	4296      	cmpeq	r6, r2
     ba2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
     ba6:	f504 7440 	add.w	r4, r4, #768	; 0x300
     baa:	d202      	bcs.n	bb2 <__aeabi_ddiv+0x6e>
     bac:	085b      	lsrs	r3, r3, #1
     bae:	ea4f 0232 	mov.w	r2, r2, rrx
     bb2:	1ab6      	subs	r6, r6, r2
     bb4:	eb65 0503 	sbc.w	r5, r5, r3
     bb8:	085b      	lsrs	r3, r3, #1
     bba:	ea4f 0232 	mov.w	r2, r2, rrx
     bbe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     bc2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
     bc6:	ebb6 0e02 	subs.w	lr, r6, r2
     bca:	eb75 0e03 	sbcs.w	lr, r5, r3
     bce:	bf22      	ittt	cs
     bd0:	1ab6      	subcs	r6, r6, r2
     bd2:	4675      	movcs	r5, lr
     bd4:	ea40 000c 	orrcs.w	r0, r0, ip
     bd8:	085b      	lsrs	r3, r3, #1
     bda:	ea4f 0232 	mov.w	r2, r2, rrx
     bde:	ebb6 0e02 	subs.w	lr, r6, r2
     be2:	eb75 0e03 	sbcs.w	lr, r5, r3
     be6:	bf22      	ittt	cs
     be8:	1ab6      	subcs	r6, r6, r2
     bea:	4675      	movcs	r5, lr
     bec:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
     bf0:	085b      	lsrs	r3, r3, #1
     bf2:	ea4f 0232 	mov.w	r2, r2, rrx
     bf6:	ebb6 0e02 	subs.w	lr, r6, r2
     bfa:	eb75 0e03 	sbcs.w	lr, r5, r3
     bfe:	bf22      	ittt	cs
     c00:	1ab6      	subcs	r6, r6, r2
     c02:	4675      	movcs	r5, lr
     c04:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
     c08:	085b      	lsrs	r3, r3, #1
     c0a:	ea4f 0232 	mov.w	r2, r2, rrx
     c0e:	ebb6 0e02 	subs.w	lr, r6, r2
     c12:	eb75 0e03 	sbcs.w	lr, r5, r3
     c16:	bf22      	ittt	cs
     c18:	1ab6      	subcs	r6, r6, r2
     c1a:	4675      	movcs	r5, lr
     c1c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
     c20:	ea55 0e06 	orrs.w	lr, r5, r6
     c24:	d018      	beq.n	c58 <__aeabi_ddiv+0x114>
     c26:	ea4f 1505 	mov.w	r5, r5, lsl #4
     c2a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
     c2e:	ea4f 1606 	mov.w	r6, r6, lsl #4
     c32:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     c36:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
     c3a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     c3e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
     c42:	d1c0      	bne.n	bc6 <__aeabi_ddiv+0x82>
     c44:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     c48:	d10b      	bne.n	c62 <__aeabi_ddiv+0x11e>
     c4a:	ea41 0100 	orr.w	r1, r1, r0
     c4e:	f04f 0000 	mov.w	r0, #0
     c52:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
     c56:	e7b6      	b.n	bc6 <__aeabi_ddiv+0x82>
     c58:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     c5c:	bf04      	itt	eq
     c5e:	4301      	orreq	r1, r0
     c60:	2000      	moveq	r0, #0
     c62:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     c66:	bf88      	it	hi
     c68:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     c6c:	f63f aeaf 	bhi.w	9ce <__aeabi_dmul+0xde>
     c70:	ebb5 0c03 	subs.w	ip, r5, r3
     c74:	bf04      	itt	eq
     c76:	ebb6 0c02 	subseq.w	ip, r6, r2
     c7a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     c7e:	f150 0000 	adcs.w	r0, r0, #0
     c82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     c86:	bd70      	pop	{r4, r5, r6, pc}
     c88:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
     c8c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
     c90:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
     c94:	bfc2      	ittt	gt
     c96:	ebd4 050c 	rsbsgt	r5, r4, ip
     c9a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     c9e:	bd70      	popgt	{r4, r5, r6, pc}
     ca0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     ca4:	f04f 0e00 	mov.w	lr, #0
     ca8:	3c01      	subs	r4, #1
     caa:	e690      	b.n	9ce <__aeabi_dmul+0xde>
     cac:	ea45 0e06 	orr.w	lr, r5, r6
     cb0:	e68d      	b.n	9ce <__aeabi_dmul+0xde>
     cb2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
     cb6:	ea94 0f0c 	teq	r4, ip
     cba:	bf08      	it	eq
     cbc:	ea95 0f0c 	teqeq	r5, ip
     cc0:	f43f af3b 	beq.w	b3a <__aeabi_dmul+0x24a>
     cc4:	ea94 0f0c 	teq	r4, ip
     cc8:	d10a      	bne.n	ce0 <__aeabi_ddiv+0x19c>
     cca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     cce:	f47f af34 	bne.w	b3a <__aeabi_dmul+0x24a>
     cd2:	ea95 0f0c 	teq	r5, ip
     cd6:	f47f af25 	bne.w	b24 <__aeabi_dmul+0x234>
     cda:	4610      	mov	r0, r2
     cdc:	4619      	mov	r1, r3
     cde:	e72c      	b.n	b3a <__aeabi_dmul+0x24a>
     ce0:	ea95 0f0c 	teq	r5, ip
     ce4:	d106      	bne.n	cf4 <__aeabi_ddiv+0x1b0>
     ce6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
     cea:	f43f aefd 	beq.w	ae8 <__aeabi_dmul+0x1f8>
     cee:	4610      	mov	r0, r2
     cf0:	4619      	mov	r1, r3
     cf2:	e722      	b.n	b3a <__aeabi_dmul+0x24a>
     cf4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     cf8:	bf18      	it	ne
     cfa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     cfe:	f47f aec5 	bne.w	a8c <__aeabi_dmul+0x19c>
     d02:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
     d06:	f47f af0d 	bne.w	b24 <__aeabi_dmul+0x234>
     d0a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
     d0e:	f47f aeeb 	bne.w	ae8 <__aeabi_dmul+0x1f8>
     d12:	e712      	b.n	b3a <__aeabi_dmul+0x24a>
	...

00000d20 <__aeabi_d2iz>:
     d20:	ea4f 0241 	mov.w	r2, r1, lsl #1
     d24:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
     d28:	d215      	bcs.n	d56 <__aeabi_d2iz+0x36>
     d2a:	d511      	bpl.n	d50 <__aeabi_d2iz+0x30>
     d2c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
     d30:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
     d34:	d912      	bls.n	d5c <__aeabi_d2iz+0x3c>
     d36:	ea4f 23c1 	mov.w	r3, r1, lsl #11
     d3a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     d3e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
     d42:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     d46:	fa23 f002 	lsr.w	r0, r3, r2
     d4a:	bf18      	it	ne
     d4c:	4240      	negne	r0, r0
     d4e:	4770      	bx	lr
     d50:	f04f 0000 	mov.w	r0, #0
     d54:	4770      	bx	lr
     d56:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
     d5a:	d105      	bne.n	d68 <__aeabi_d2iz+0x48>
     d5c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
     d60:	bf08      	it	eq
     d62:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
     d66:	4770      	bx	lr
     d68:	f04f 0000 	mov.w	r0, #0
     d6c:	4770      	bx	lr
     d6e:	bf00      	nop

00000d70 <__aeabi_d2f>:
     d70:	ea4f 0241 	mov.w	r2, r1, lsl #1
     d74:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
     d78:	bf24      	itt	cs
     d7a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
     d7e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
     d82:	d90d      	bls.n	da0 <__aeabi_d2f+0x30>
     d84:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
     d88:	ea4f 02c0 	mov.w	r2, r0, lsl #3
     d8c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
     d90:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
     d94:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
     d98:	bf08      	it	eq
     d9a:	f020 0001 	biceq.w	r0, r0, #1
     d9e:	4770      	bx	lr
     da0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
     da4:	d121      	bne.n	dea <__aeabi_d2f+0x7a>
     da6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
     daa:	bfbc      	itt	lt
     dac:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
     db0:	4770      	bxlt	lr
     db2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     db6:	ea4f 5252 	mov.w	r2, r2, lsr #21
     dba:	f1c2 0218 	rsb	r2, r2, #24
     dbe:	f1c2 0c20 	rsb	ip, r2, #32
     dc2:	fa10 f30c 	lsls.w	r3, r0, ip
     dc6:	fa20 f002 	lsr.w	r0, r0, r2
     dca:	bf18      	it	ne
     dcc:	f040 0001 	orrne.w	r0, r0, #1
     dd0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
     dd4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
     dd8:	fa03 fc0c 	lsl.w	ip, r3, ip
     ddc:	ea40 000c 	orr.w	r0, r0, ip
     de0:	fa23 f302 	lsr.w	r3, r3, r2
     de4:	ea4f 0343 	mov.w	r3, r3, lsl #1
     de8:	e7cc      	b.n	d84 <__aeabi_d2f+0x14>
     dea:	ea7f 5362 	mvns.w	r3, r2, asr #21
     dee:	d107      	bne.n	e00 <__aeabi_d2f+0x90>
     df0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
     df4:	bf1e      	ittt	ne
     df6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
     dfa:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
     dfe:	4770      	bxne	lr
     e00:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
     e04:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     e08:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     e0c:	4770      	bx	lr
     e0e:	bf00      	nop

00000e10 <strcmp>:
     e10:	f810 2b01 	ldrb.w	r2, [r0], #1
     e14:	f811 3b01 	ldrb.w	r3, [r1], #1
     e18:	2a01      	cmp	r2, #1
     e1a:	bf28      	it	cs
     e1c:	429a      	cmpcs	r2, r3
     e1e:	d0f7      	beq.n	e10 <strcmp>
     e20:	1ad0      	subs	r0, r2, r3
     e22:	4770      	bx	lr
	...

00000e30 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
     e30:	4770      	bx	lr
     e32:	bf00      	nop
     e34:	f3af 8000 	nop.w
     e38:	f3af 8000 	nop.w
     e3c:	f3af 8000 	nop.w

00000e40 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     e40:	4770      	bx	lr
     e42:	bf00      	nop
     e44:	f3af 8000 	nop.w
     e48:	f3af 8000 	nop.w
     e4c:	f3af 8000 	nop.w

00000e50 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     e50:	e7fe      	b.n	e50 <__default_exit>
     e52:	bf00      	nop
     e54:	f3af 8000 	nop.w
     e58:	f3af 8000 	nop.w
     e5c:	f3af 8000 	nop.w

00000e60 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
     e60:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
     e62:	4e11      	ldr	r6, [pc, #68]	; (ea8 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
     e64:	2500      	movs	r5, #0
     e66:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
     e6a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
     e6e:	42a3      	cmp	r3, r4
     e70:	d20d      	bcs.n	e8e <__init_ram_areas+0x2e>
     e72:	3904      	subs	r1, #4
     e74:	461a      	mov	r2, r3
      *p = *tp;
     e76:	f851 0f04 	ldr.w	r0, [r1, #4]!
     e7a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
     e7e:	42a2      	cmp	r2, r4
     e80:	d3f9      	bcc.n	e76 <__init_ram_areas+0x16>
     e82:	43da      	mvns	r2, r3
     e84:	4414      	add	r4, r2
     e86:	f024 0403 	bic.w	r4, r4, #3
     e8a:	3404      	adds	r4, #4
     e8c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
     e8e:	68f2      	ldr	r2, [r6, #12]
     e90:	4293      	cmp	r3, r2
     e92:	d203      	bcs.n	e9c <__init_ram_areas+0x3c>
      *p = 0;
     e94:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
     e98:	4293      	cmp	r3, r2
     e9a:	d3fb      	bcc.n	e94 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
     e9c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
     e9e:	42be      	cmp	r6, r7
     ea0:	d3e3      	bcc.n	e6a <__init_ram_areas+0xa>
#endif
}
     ea2:	bcf0      	pop	{r4, r5, r6, r7}
     ea4:	4770      	bx	lr
     ea6:	bf00      	nop
     ea8:	000068d0 	.word	0x000068d0
     eac:	f3af 8000 	nop.w

00000eb0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     eb0:	e7fe      	b.n	eb0 <_unhandled_exception>
     eb2:	bf00      	nop
     eb4:	f3af 8000 	nop.w
     eb8:	f3af 8000 	nop.w
     ebc:	f3af 8000 	nop.w

00000ec0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     ec0:	e7fe      	b.n	ec0 <_idle_thread>
     ec2:	bf00      	nop
     ec4:	f3af 8000 	nop.w
     ec8:	f3af 8000 	nop.w
     ecc:	f3af 8000 	nop.w

00000ed0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
     ed2:	4c20      	ldr	r4, [pc, #128]	; (f54 <chSysInit+0x84>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     ed4:	4e20      	ldr	r6, [pc, #128]	; (f58 <chSysInit+0x88>)
     ed6:	2500      	movs	r5, #0
 *
 * @special
 */
void chSysInit(void) {

  _scheduler_init();
     ed8:	f000 f9ba 	bl	1250 <_scheduler_init>
  _vt_init();
     edc:	f000 f950 	bl	1180 <_vt_init>
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
     ee0:	6325      	str	r5, [r4, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
     ee2:	6365      	str	r5, [r4, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
     ee4:	f000 fe64 	bl	1bb0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     ee8:	f001 fa0a 	bl	2300 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     eec:	f001 fa78 	bl	23e0 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
     ef0:	f000 fe9e 	bl	1c30 <_stats_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
     ef4:	f104 0038 	add.w	r0, r4, #56	; 0x38
     ef8:	4918      	ldr	r1, [pc, #96]	; (f5c <chSysInit+0x8c>)
     efa:	2280      	movs	r2, #128	; 0x80
     efc:	f000 fb70 	bl	15e0 <_thread_init>
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     f00:	4b17      	ldr	r3, [pc, #92]	; (f60 <chSysInit+0x90>)
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
     f02:	4918      	ldr	r1, [pc, #96]	; (f64 <chSysInit+0x94>)
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
     f04:	2201      	movs	r2, #1
     f06:	f880 2020 	strb.w	r2, [r0, #32]
     f0a:	68df      	ldr	r7, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     f0c:	4a16      	ldr	r2, [pc, #88]	; (f68 <chSysInit+0x98>)
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
     f0e:	61c1      	str	r1, [r0, #28]
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
     f10:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
     f14:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                   |
     f16:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     f18:	60da      	str	r2, [r3, #12]
     f1a:	68f2      	ldr	r2, [r6, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     f1c:	4913      	ldr	r1, [pc, #76]	; (f6c <chSysInit+0x9c>)
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
     f1e:	61a0      	str	r0, [r4, #24]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     f20:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     f24:	60f2      	str	r2, [r6, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     f26:	680a      	ldr	r2, [r1, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     f28:	2610      	movs	r6, #16
     f2a:	f042 0201 	orr.w	r2, r2, #1
     f2e:	2420      	movs	r4, #32
     f30:	600a      	str	r2, [r1, #0]
     initializations performed before.*/
  port_init();

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
     f32:	3048      	adds	r0, #72	; 0x48
     f34:	77de      	strb	r6, [r3, #31]
     f36:	f883 4022 	strb.w	r4, [r3, #34]	; 0x22
     f3a:	f000 fe09 	bl	1b50 <chTMStartMeasurementX>
 *
 * @special
 */
static inline void chSysEnable(void) {

  _dbg_check_enable();
     f3e:	f000 f867 	bl	1010 <_dbg_check_enable>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     f42:	f385 8811 	msr	BASEPRI, r5
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     f46:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
     f48:	4809      	ldr	r0, [pc, #36]	; (f70 <chSysInit+0xa0>)
  }
#endif
}
     f4a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
     f4e:	f000 bbbf 	b.w	16d0 <chThdCreate>
     f52:	bf00      	nop
     f54:	1ffff228 	.word	0x1ffff228
     f58:	e000edf0 	.word	0xe000edf0
     f5c:	00006b50 	.word	0x00006b50
     f60:	e000ed00 	.word	0xe000ed00
     f64:	1fffe800 	.word	0x1fffe800
     f68:	05fa0300 	.word	0x05fa0300
     f6c:	e0001000 	.word	0xe0001000
     f70:	00006950 	.word	0x00006950
     f74:	f3af 8000 	nop.w
     f78:	f3af 8000 	nop.w
     f7c:	f3af 8000 	nop.w

00000f80 <chSysHalt>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     f80:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     f82:	4b01      	ldr	r3, [pc, #4]	; (f88 <chSysHalt+0x8>)
     f84:	62d8      	str	r0, [r3, #44]	; 0x2c
  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
  }
     f86:	e7fe      	b.n	f86 <chSysHalt+0x6>
     f88:	1ffff228 	.word	0x1ffff228
     f8c:	f3af 8000 	nop.w

00000f90 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     f90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->preempt > (tslices_t)0) {
     f94:	4e19      	ldr	r6, [pc, #100]	; (ffc <chSysTimerHandlerI+0x6c>)
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
     f96:	f000 f8d3 	bl	1140 <chDbgCheckClassI>

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->preempt > (tslices_t)0) {
     f9a:	69b2      	ldr	r2, [r6, #24]
     f9c:	f892 3023 	ldrb.w	r3, [r2, #35]	; 0x23
     fa0:	b113      	cbz	r3, fa8 <chSysTimerHandlerI+0x18>
    /* Decrement remaining quantum.*/
    currp->preempt--;
     fa2:	3b01      	subs	r3, #1
     fa4:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
     fa8:	f000 f8ca 	bl	1140 <chDbgCheckClassI>

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     fac:	4f14      	ldr	r7, [pc, #80]	; (1000 <chSysTimerHandlerI+0x70>)
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
     fae:	6ab3      	ldr	r3, [r6, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     fb0:	69f4      	ldr	r4, [r6, #28]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
     fb2:	3301      	adds	r3, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     fb4:	42bc      	cmp	r4, r7
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
     fb6:	62b3      	str	r3, [r6, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     fb8:	d01d      	beq.n	ff6 <chSysTimerHandlerI+0x66>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
     fba:	68a5      	ldr	r5, [r4, #8]
     fbc:	3d01      	subs	r5, #1
     fbe:	60a5      	str	r5, [r4, #8]
    while (ch.vtlist.next->delta == (systime_t)0) {
     fc0:	b9cd      	cbnz	r5, ff6 <chSysTimerHandlerI+0x66>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     fc2:	f04f 0920 	mov.w	r9, #32
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
      vtp->func = NULL;
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
     fc6:	6823      	ldr	r3, [r4, #0]
    while (ch.vtlist.next->delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
     fc8:	f8d4 800c 	ldr.w	r8, [r4, #12]
      vtp->func = NULL;
     fcc:	60e5      	str	r5, [r4, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
     fce:	605f      	str	r7, [r3, #4]
      ch.vtlist.next = vtp->next;
     fd0:	61f3      	str	r3, [r6, #28]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
     fd2:	f000 f86d 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     fd6:	f000 fe83 	bl	1ce0 <_stats_stop_measure_crit_isr>
     fda:	f385 8811 	msr	BASEPRI, r5
      chSysUnlockFromISR();
      fn(vtp->par);
     fde:	6920      	ldr	r0, [r4, #16]
     fe0:	47c0      	blx	r8
     fe2:	f389 8811 	msr	BASEPRI, r9
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
     fe6:	f000 fe73 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     fea:	f000 f849 	bl	1080 <_dbg_check_lock_from_isr>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
    while (ch.vtlist.next->delta == (systime_t)0) {
     fee:	69f4      	ldr	r4, [r6, #28]
     ff0:	68a3      	ldr	r3, [r4, #8]
     ff2:	2b00      	cmp	r3, #0
     ff4:	d0e7      	beq.n	fc6 <chSysTimerHandlerI+0x36>
     ff6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     ffa:	bf00      	nop
     ffc:	1ffff228 	.word	0x1ffff228
    1000:	1ffff244 	.word	0x1ffff244
    1004:	f3af 8000 	nop.w
    1008:	f3af 8000 	nop.w
    100c:	f3af 8000 	nop.w

00001010 <_dbg_check_enable>:
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    1010:	4b04      	ldr	r3, [pc, #16]	; (1024 <_dbg_check_enable+0x14>)
    1012:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1014:	b90a      	cbnz	r2, 101a <_dbg_check_enable+0xa>
    1016:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1018:	b113      	cbz	r3, 1020 <_dbg_check_enable+0x10>
    chSysHalt("SV#3");
    101a:	4803      	ldr	r0, [pc, #12]	; (1028 <_dbg_check_enable+0x18>)
    101c:	f7ff bfb0 	b.w	f80 <chSysHalt>
    1020:	4770      	bx	lr
    1022:	bf00      	nop
    1024:	1ffff228 	.word	0x1ffff228
    1028:	00006990 	.word	0x00006990
    102c:	f3af 8000 	nop.w

00001030 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
    1030:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    1032:	4c05      	ldr	r4, [pc, #20]	; (1048 <_dbg_check_lock+0x18>)
    1034:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1036:	b90b      	cbnz	r3, 103c <_dbg_check_lock+0xc>
    1038:	6b63      	ldr	r3, [r4, #52]	; 0x34
    103a:	b113      	cbz	r3, 1042 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
    103c:	4803      	ldr	r0, [pc, #12]	; (104c <_dbg_check_lock+0x1c>)
    103e:	f7ff ff9f 	bl	f80 <chSysHalt>
  }
  _dbg_enter_lock();
    1042:	2301      	movs	r3, #1
    1044:	6363      	str	r3, [r4, #52]	; 0x34
    1046:	bd10      	pop	{r4, pc}
    1048:	1ffff228 	.word	0x1ffff228
    104c:	00006998 	.word	0x00006998

00001050 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
    1050:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1052:	4c07      	ldr	r4, [pc, #28]	; (1070 <_dbg_check_unlock+0x20>)
    1054:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1056:	b92b      	cbnz	r3, 1064 <_dbg_check_unlock+0x14>
    1058:	6b63      	ldr	r3, [r4, #52]	; 0x34
    105a:	2b00      	cmp	r3, #0
    105c:	dd02      	ble.n	1064 <_dbg_check_unlock+0x14>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
    105e:	2300      	movs	r3, #0
    1060:	6363      	str	r3, [r4, #52]	; 0x34
    1062:	bd10      	pop	{r4, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
    1064:	4803      	ldr	r0, [pc, #12]	; (1074 <_dbg_check_unlock+0x24>)
    1066:	f7ff ff8b 	bl	f80 <chSysHalt>
  }
  _dbg_leave_lock();
    106a:	2300      	movs	r3, #0
    106c:	6363      	str	r3, [r4, #52]	; 0x34
    106e:	bd10      	pop	{r4, pc}
    1070:	1ffff228 	.word	0x1ffff228
    1074:	000069a0 	.word	0x000069a0
    1078:	f3af 8000 	nop.w
    107c:	f3af 8000 	nop.w

00001080 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
    1080:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    1082:	4c06      	ldr	r4, [pc, #24]	; (109c <_dbg_check_lock_from_isr+0x1c>)
    1084:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1086:	2b00      	cmp	r3, #0
    1088:	dd01      	ble.n	108e <_dbg_check_lock_from_isr+0xe>
    108a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    108c:	b113      	cbz	r3, 1094 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
    108e:	4804      	ldr	r0, [pc, #16]	; (10a0 <_dbg_check_lock_from_isr+0x20>)
    1090:	f7ff ff76 	bl	f80 <chSysHalt>
  }
  _dbg_enter_lock();
    1094:	2301      	movs	r3, #1
    1096:	6363      	str	r3, [r4, #52]	; 0x34
    1098:	bd10      	pop	{r4, pc}
    109a:	bf00      	nop
    109c:	1ffff228 	.word	0x1ffff228
    10a0:	000069a8 	.word	0x000069a8
    10a4:	f3af 8000 	nop.w
    10a8:	f3af 8000 	nop.w
    10ac:	f3af 8000 	nop.w

000010b0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
    10b0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    10b2:	4c08      	ldr	r4, [pc, #32]	; (10d4 <_dbg_check_unlock_from_isr+0x24>)
    10b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    10b6:	2b00      	cmp	r3, #0
    10b8:	dd05      	ble.n	10c6 <_dbg_check_unlock_from_isr+0x16>
    10ba:	6b63      	ldr	r3, [r4, #52]	; 0x34
    10bc:	2b00      	cmp	r3, #0
    10be:	dd02      	ble.n	10c6 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
    10c0:	2300      	movs	r3, #0
    10c2:	6363      	str	r3, [r4, #52]	; 0x34
    10c4:	bd10      	pop	{r4, pc}
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
    10c6:	4804      	ldr	r0, [pc, #16]	; (10d8 <_dbg_check_unlock_from_isr+0x28>)
    10c8:	f7ff ff5a 	bl	f80 <chSysHalt>
  }
  _dbg_leave_lock();
    10cc:	2300      	movs	r3, #0
    10ce:	6363      	str	r3, [r4, #52]	; 0x34
    10d0:	bd10      	pop	{r4, pc}
    10d2:	bf00      	nop
    10d4:	1ffff228 	.word	0x1ffff228
    10d8:	000069b0 	.word	0x000069b0
    10dc:	f3af 8000 	nop.w

000010e0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
    10e0:	b510      	push	{r4, lr}
    10e2:	2320      	movs	r3, #32
    10e4:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    10e8:	4c07      	ldr	r4, [pc, #28]	; (1108 <_dbg_check_enter_isr+0x28>)
    10ea:	6b23      	ldr	r3, [r4, #48]	; 0x30
    10ec:	2b00      	cmp	r3, #0
    10ee:	db01      	blt.n	10f4 <_dbg_check_enter_isr+0x14>
    10f0:	6b62      	ldr	r2, [r4, #52]	; 0x34
    10f2:	b11a      	cbz	r2, 10fc <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
    10f4:	4805      	ldr	r0, [pc, #20]	; (110c <_dbg_check_enter_isr+0x2c>)
    10f6:	f7ff ff43 	bl	f80 <chSysHalt>
    10fa:	6b23      	ldr	r3, [r4, #48]	; 0x30
  }
  ch.dbg.isr_cnt++;
    10fc:	3301      	adds	r3, #1
    10fe:	6323      	str	r3, [r4, #48]	; 0x30
    1100:	2300      	movs	r3, #0
    1102:	f383 8811 	msr	BASEPRI, r3
    1106:	bd10      	pop	{r4, pc}
    1108:	1ffff228 	.word	0x1ffff228
    110c:	000069b8 	.word	0x000069b8

00001110 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
    1110:	b510      	push	{r4, lr}
    1112:	2320      	movs	r3, #32
    1114:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    1118:	4c07      	ldr	r4, [pc, #28]	; (1138 <_dbg_check_leave_isr+0x28>)
    111a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    111c:	2b00      	cmp	r3, #0
    111e:	dd01      	ble.n	1124 <_dbg_check_leave_isr+0x14>
    1120:	6b62      	ldr	r2, [r4, #52]	; 0x34
    1122:	b11a      	cbz	r2, 112c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
    1124:	4805      	ldr	r0, [pc, #20]	; (113c <_dbg_check_leave_isr+0x2c>)
    1126:	f7ff ff2b 	bl	f80 <chSysHalt>
    112a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  }
  ch.dbg.isr_cnt--;
    112c:	3b01      	subs	r3, #1
    112e:	6323      	str	r3, [r4, #48]	; 0x30
    1130:	2300      	movs	r3, #0
    1132:	f383 8811 	msr	BASEPRI, r3
    1136:	bd10      	pop	{r4, pc}
    1138:	1ffff228 	.word	0x1ffff228
    113c:	000069c0 	.word	0x000069c0

00001140 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1140:	4b05      	ldr	r3, [pc, #20]	; (1158 <chDbgCheckClassI+0x18>)
    1142:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1144:	2a00      	cmp	r2, #0
    1146:	db03      	blt.n	1150 <chDbgCheckClassI+0x10>
    1148:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    114a:	2b00      	cmp	r3, #0
    114c:	dd00      	ble.n	1150 <chDbgCheckClassI+0x10>
    114e:	4770      	bx	lr
    chSysHalt("SV#10");
    1150:	4802      	ldr	r0, [pc, #8]	; (115c <chDbgCheckClassI+0x1c>)
    1152:	f7ff bf15 	b.w	f80 <chSysHalt>
    1156:	bf00      	nop
    1158:	1ffff228 	.word	0x1ffff228
    115c:	000069c8 	.word	0x000069c8

00001160 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1160:	4b04      	ldr	r3, [pc, #16]	; (1174 <chDbgCheckClassS+0x14>)
    1162:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1164:	b91a      	cbnz	r2, 116e <chDbgCheckClassS+0xe>
    1166:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1168:	2b00      	cmp	r3, #0
    116a:	dd00      	ble.n	116e <chDbgCheckClassS+0xe>
    116c:	4770      	bx	lr
    chSysHalt("SV#11");
    116e:	4802      	ldr	r0, [pc, #8]	; (1178 <chDbgCheckClassS+0x18>)
    1170:	f7ff bf06 	b.w	f80 <chSysHalt>
    1174:	1ffff228 	.word	0x1ffff228
    1178:	000069d0 	.word	0x000069d0
    117c:	f3af 8000 	nop.w

00001180 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
    1180:	4b05      	ldr	r3, [pc, #20]	; (1198 <_vt_init+0x18>)
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
    1182:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
    1186:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
    118a:	2100      	movs	r1, #0
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
    118c:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
    118e:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
    1190:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
    1192:	621a      	str	r2, [r3, #32]
    1194:	4770      	bx	lr
    1196:	bf00      	nop
    1198:	1ffff228 	.word	0x1ffff228
    119c:	f3af 8000 	nop.w

000011a0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
    11a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11a2:	4605      	mov	r5, r0
    11a4:	460c      	mov	r4, r1
    11a6:	4616      	mov	r6, r2
    11a8:	461f      	mov	r7, r3
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
    11aa:	f7ff ffc9 	bl	1140 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
    11ae:	b1d5      	cbz	r5, 11e6 <chVTDoSetI+0x46>
    11b0:	b1ce      	cbz	r6, 11e6 <chVTDoSetI+0x46>
    11b2:	b1c4      	cbz	r4, 11e6 <chVTDoSetI+0x46>
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
    11b4:	480e      	ldr	r0, [pc, #56]	; (11f0 <chVTDoSetI+0x50>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
    11b6:	612f      	str	r7, [r5, #16]
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
    11b8:	69c3      	ldr	r3, [r0, #28]

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
    11ba:	60ee      	str	r6, [r5, #12]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    11bc:	689a      	ldr	r2, [r3, #8]
    11be:	4294      	cmp	r4, r2
    11c0:	d904      	bls.n	11cc <chVTDoSetI+0x2c>
    delta -= p->delta;
    p = p->next;
    11c2:	681b      	ldr	r3, [r3, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
    11c4:	1aa4      	subs	r4, r4, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    11c6:	689a      	ldr	r2, [r3, #8]
    11c8:	42a2      	cmp	r2, r4
    11ca:	d3fa      	bcc.n	11c2 <chVTDoSetI+0x22>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
    11cc:	685a      	ldr	r2, [r3, #4]
    11ce:	606a      	str	r2, [r5, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
    11d0:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
    11d2:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
    11d4:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
    11d6:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
    11d8:	6899      	ldr	r1, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
    11da:	f04f 32ff 	mov.w	r2, #4294967295
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
    11de:	1b09      	subs	r1, r1, r4
    11e0:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
    11e2:	6242      	str	r2, [r0, #36]	; 0x24
    11e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
    11e6:	4803      	ldr	r0, [pc, #12]	; (11f4 <chVTDoSetI+0x54>)
    11e8:	f7ff feca 	bl	f80 <chSysHalt>
    11ec:	e7e2      	b.n	11b4 <chVTDoSetI+0x14>
    11ee:	bf00      	nop
    11f0:	1ffff228 	.word	0x1ffff228
    11f4:	000069e0 	.word	0x000069e0
    11f8:	f3af 8000 	nop.w
    11fc:	f3af 8000 	nop.w

00001200 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
    1200:	b538      	push	{r3, r4, r5, lr}
    1202:	4604      	mov	r4, r0

  chDbgCheckClassI();
    1204:	f7ff ff9c 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
    1208:	b1ac      	cbz	r4, 1236 <chVTDoResetI+0x36>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
    120a:	68e3      	ldr	r3, [r4, #12]
    120c:	b17b      	cbz	r3, 122e <chVTDoResetI+0x2e>

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
    120e:	6823      	ldr	r3, [r4, #0]
    1210:	68a2      	ldr	r2, [r4, #8]
    1212:	689d      	ldr	r5, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
    1214:	6861      	ldr	r1, [r4, #4]
  vtp->next->prev = vtp->prev;
  vtp->func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
    1216:	480a      	ldr	r0, [pc, #40]	; (1240 <chVTDoResetI+0x40>)
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
    1218:	442a      	add	r2, r5
    121a:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
    121c:	600b      	str	r3, [r1, #0]
  vtp->next->prev = vtp->prev;
    121e:	6825      	ldr	r5, [r4, #0]
  vtp->func = NULL;
    1220:	2200      	movs	r2, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
    1222:	f04f 33ff 	mov.w	r3, #4294967295
  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
  vtp->next->prev = vtp->prev;
    1226:	6069      	str	r1, [r5, #4]
  vtp->func = NULL;
    1228:	60e2      	str	r2, [r4, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
    122a:	6243      	str	r3, [r0, #36]	; 0x24
    122c:	bd38      	pop	{r3, r4, r5, pc}
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
    122e:	4805      	ldr	r0, [pc, #20]	; (1244 <chVTDoResetI+0x44>)
    1230:	f7ff fea6 	bl	f80 <chSysHalt>
    1234:	e7eb      	b.n	120e <chVTDoResetI+0xe>
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
    1236:	4803      	ldr	r0, [pc, #12]	; (1244 <chVTDoResetI+0x44>)
    1238:	f7ff fea2 	bl	f80 <chSysHalt>
    123c:	e7e5      	b.n	120a <chVTDoResetI+0xa>
    123e:	bf00      	nop
    1240:	1ffff228 	.word	0x1ffff228
    1244:	000069f0 	.word	0x000069f0
    1248:	f3af 8000 	nop.w
    124c:	f3af 8000 	nop.w

00001250 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
    1250:	4b03      	ldr	r3, [pc, #12]	; (1260 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
    1252:	2200      	movs	r2, #0
    1254:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
    1256:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
    1258:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
    125a:	615b      	str	r3, [r3, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
    125c:	609a      	str	r2, [r3, #8]
    125e:	4770      	bx	lr
    1260:	1ffff228 	.word	0x1ffff228
    1264:	f3af 8000 	nop.w
    1268:	f3af 8000 	nop.w
    126c:	f3af 8000 	nop.w

00001270 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
    1270:	b510      	push	{r4, lr}
    1272:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
    1274:	f7ff ff64 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1278:	b1c4      	cbz	r4, 12ac <chSchReadyI+0x3c>
  chDbgAssert((tp->state != CH_STATE_READY) &&
    127a:	f894 3020 	ldrb.w	r3, [r4, #32]
    127e:	b18b      	cbz	r3, 12a4 <chSchReadyI+0x34>
    1280:	2b0f      	cmp	r3, #15
    1282:	d00f      	beq.n	12a4 <chSchReadyI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
    1284:	2200      	movs	r2, #0
    1286:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
    1288:	4b0a      	ldr	r3, [pc, #40]	; (12b4 <chSchReadyI+0x44>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
    128a:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
    128e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
    1290:	689a      	ldr	r2, [r3, #8]
    1292:	428a      	cmp	r2, r1
    1294:	d2fb      	bcs.n	128e <chSchReadyI+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
    1296:	685a      	ldr	r2, [r3, #4]
    1298:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
    129a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
    129c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
    129e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
    12a0:	605c      	str	r4, [r3, #4]

  return tp;
}
    12a2:	bd10      	pop	{r4, pc}
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
    12a4:	4804      	ldr	r0, [pc, #16]	; (12b8 <chSchReadyI+0x48>)
    12a6:	f7ff fe6b 	bl	f80 <chSysHalt>
    12aa:	e7eb      	b.n	1284 <chSchReadyI+0x14>
 */
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    12ac:	4802      	ldr	r0, [pc, #8]	; (12b8 <chSchReadyI+0x48>)
    12ae:	f7ff fe67 	bl	f80 <chSysHalt>
    12b2:	e7e2      	b.n	127a <chSchReadyI+0xa>
    12b4:	1ffff228 	.word	0x1ffff228
    12b8:	00006a10 	.word	0x00006a10
    12bc:	f3af 8000 	nop.w

000012c0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    12c0:	b538      	push	{r3, r4, r5, lr}
    12c2:	4604      	mov	r4, r0
    12c4:	2320      	movs	r3, #32
    12c6:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    12ca:	f000 fd01 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    12ce:	f7ff fed7 	bl	1080 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
    12d2:	f894 3020 	ldrb.w	r3, [r4, #32]
    12d6:	2b07      	cmp	r3, #7
    12d8:	d810      	bhi.n	12fc <wakeup+0x3c>
    12da:	e8df f003 	tbb	[pc, r3]
    12de:	0f15      	.short	0x0f15
    12e0:	040a1d0f 	.word	0x040a1d0f
    12e4:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
    12e6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
    12e8:	f7ff ff2a 	bl	1140 <chDbgCheckClassI>

  sp->cnt++;
    12ec:	68ab      	ldr	r3, [r5, #8]
    12ee:	3301      	adds	r3, #1
    12f0:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
    12f2:	e894 000c 	ldmia.w	r4, {r2, r3}
    12f6:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
    12f8:	6822      	ldr	r2, [r4, #0]
    12fa:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
    12fc:	f04f 33ff 	mov.w	r3, #4294967295
    1300:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    1302:	4620      	mov	r0, r4
    1304:	f7ff ffb4 	bl	1270 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    1308:	f7ff fed2 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    130c:	f000 fce8 	bl	1ce0 <_stats_stop_measure_crit_isr>
    1310:	2300      	movs	r3, #0
    1312:	f383 8811 	msr	BASEPRI, r3
    1316:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    1318:	6a63      	ldr	r3, [r4, #36]	; 0x24
    131a:	2200      	movs	r2, #0
    131c:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
    131e:	f04f 33ff 	mov.w	r3, #4294967295
    1322:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    1324:	4620      	mov	r0, r4
    1326:	f7ff ffa3 	bl	1270 <chSchReadyI>
    132a:	e7ed      	b.n	1308 <wakeup+0x48>
    132c:	f3af 8000 	nop.w

00001330 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
    1330:	b510      	push	{r4, lr}
    1332:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
    1334:	f7ff ff04 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1338:	b1c4      	cbz	r4, 136c <chSchReadyAheadI+0x3c>
  chDbgAssert((tp->state != CH_STATE_READY) &&
    133a:	f894 3020 	ldrb.w	r3, [r4, #32]
    133e:	b18b      	cbz	r3, 1364 <chSchReadyAheadI+0x34>
    1340:	2b0f      	cmp	r3, #15
    1342:	d00f      	beq.n	1364 <chSchReadyAheadI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
    1344:	2200      	movs	r2, #0
    1346:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
    1348:	4b0a      	ldr	r3, [pc, #40]	; (1374 <chSchReadyAheadI+0x44>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
    134a:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
    134e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
    1350:	689a      	ldr	r2, [r3, #8]
    1352:	428a      	cmp	r2, r1
    1354:	d8fb      	bhi.n	134e <chSchReadyAheadI+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
    1356:	685a      	ldr	r2, [r3, #4]
    1358:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
    135a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
    135c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
    135e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
    1360:	605c      	str	r4, [r3, #4]

  return tp;
}
    1362:	bd10      	pop	{r4, pc}
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
    1364:	4804      	ldr	r0, [pc, #16]	; (1378 <chSchReadyAheadI+0x48>)
    1366:	f7ff fe0b 	bl	f80 <chSysHalt>
    136a:	e7eb      	b.n	1344 <chSchReadyAheadI+0x14>
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    136c:	4802      	ldr	r0, [pc, #8]	; (1378 <chSchReadyAheadI+0x48>)
    136e:	f7ff fe07 	bl	f80 <chSysHalt>
    1372:	e7e2      	b.n	133a <chSchReadyAheadI+0xa>
    1374:	1ffff228 	.word	0x1ffff228
    1378:	00006a30 	.word	0x00006a30
    137c:	f3af 8000 	nop.w

00001380 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
    1380:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
    1382:	4c12      	ldr	r4, [pc, #72]	; (13cc <chSchGoSleepS+0x4c>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
    1384:	4606      	mov	r6, r0
  thread_t *otp = currp;
    1386:	69a5      	ldr	r5, [r4, #24]

  chDbgCheckClassS();
    1388:	f7ff feea 	bl	1160 <chDbgCheckClassS>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
    138c:	6823      	ldr	r3, [r4, #0]

  /* New state.*/
  otp->state = newstate;
    138e:	f885 6020 	strb.w	r6, [r5, #32]

  tqp->next             = tp->queue.next;
    1392:	681a      	ldr	r2, [r3, #0]
    1394:	6022      	str	r2, [r4, #0]

#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    1396:	2114      	movs	r1, #20
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
    1398:	2601      	movs	r6, #1
  otp->state = newstate;

#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    139a:	f885 1023 	strb.w	r1, [r5, #35]	; 0x23
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    139e:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
    13a0:	6054      	str	r4, [r2, #4]
    13a2:	4629      	mov	r1, r5
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
    13a4:	f883 6020 	strb.w	r6, [r3, #32]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
    13a8:	61a3      	str	r3, [r4, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    13aa:	f000 fc69 	bl	1c80 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    13ae:	f3ef 8309 	mrs	r3, PSP
    13b2:	69ea      	ldr	r2, [r5, #28]
    13b4:	3b64      	subs	r3, #100	; 0x64
    13b6:	429a      	cmp	r2, r3
    13b8:	d902      	bls.n	13c0 <chSchGoSleepS+0x40>
    13ba:	4805      	ldr	r0, [pc, #20]	; (13d0 <chSchGoSleepS+0x50>)
    13bc:	f7ff fde0 	bl	f80 <chSysHalt>
    13c0:	69a0      	ldr	r0, [r4, #24]
    13c2:	4629      	mov	r1, r5
}
    13c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    13c8:	f7ff b8b2 	b.w	530 <_port_switch>
    13cc:	1ffff228 	.word	0x1ffff228
    13d0:	00006a20 	.word	0x00006a20
    13d4:	f3af 8000 	nop.w
    13d8:	f3af 8000 	nop.w
    13dc:	f3af 8000 	nop.w

000013e0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    13e0:	b570      	push	{r4, r5, r6, lr}
    13e2:	460c      	mov	r4, r1
    13e4:	b086      	sub	sp, #24
    13e6:	4606      	mov	r6, r0

  chDbgCheckClassS();
    13e8:	f7ff feba 	bl	1160 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
    13ec:	1c63      	adds	r3, r4, #1
    13ee:	d014      	beq.n	141a <chSchGoSleepTimeoutS+0x3a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
    13f0:	4d0e      	ldr	r5, [pc, #56]	; (142c <chSchGoSleepTimeoutS+0x4c>)
    13f2:	4a0f      	ldr	r2, [pc, #60]	; (1430 <chSchGoSleepTimeoutS+0x50>)
    13f4:	69ab      	ldr	r3, [r5, #24]
    13f6:	4621      	mov	r1, r4
    13f8:	a801      	add	r0, sp, #4
    13fa:	f7ff fed1 	bl	11a0 <chVTDoSetI>
    chSchGoSleepS(newstate);
    13fe:	4630      	mov	r0, r6
    1400:	f7ff ffbe 	bl	1380 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
    1404:	f7ff fe9c 	bl	1140 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
    1408:	9b04      	ldr	r3, [sp, #16]
    140a:	b113      	cbz	r3, 1412 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
    140c:	a801      	add	r0, sp, #4
    140e:	f7ff fef7 	bl	1200 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
    1412:	69ab      	ldr	r3, [r5, #24]
}
    1414:	6a58      	ldr	r0, [r3, #36]	; 0x24
    1416:	b006      	add	sp, #24
    1418:	bd70      	pop	{r4, r5, r6, pc}
    141a:	4d04      	ldr	r5, [pc, #16]	; (142c <chSchGoSleepTimeoutS+0x4c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
    141c:	4630      	mov	r0, r6
    141e:	f7ff ffaf 	bl	1380 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
    1422:	69ab      	ldr	r3, [r5, #24]
}
    1424:	6a58      	ldr	r0, [r3, #36]	; 0x24
    1426:	b006      	add	sp, #24
    1428:	bd70      	pop	{r4, r5, r6, pc}
    142a:	bf00      	nop
    142c:	1ffff228 	.word	0x1ffff228
    1430:	000012c1 	.word	0x000012c1
    1434:	f3af 8000 	nop.w
    1438:	f3af 8000 	nop.w
    143c:	f3af 8000 	nop.w

00001440 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    1440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *otp = currp;
    1442:	4d1e      	ldr	r5, [pc, #120]	; (14bc <chSchWakeupS+0x7c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    1444:	4604      	mov	r4, r0
    1446:	460f      	mov	r7, r1
  thread_t *otp = currp;
    1448:	69ae      	ldr	r6, [r5, #24]

  chDbgCheckClassS();
    144a:	f7ff fe89 	bl	1160 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    144e:	682b      	ldr	r3, [r5, #0]
    1450:	42ab      	cmp	r3, r5
    1452:	d004      	beq.n	145e <chSchWakeupS+0x1e>
    1454:	69aa      	ldr	r2, [r5, #24]
    1456:	689b      	ldr	r3, [r3, #8]
    1458:	6892      	ldr	r2, [r2, #8]
    145a:	429a      	cmp	r2, r3
    145c:	d321      	bcc.n	14a2 <chSchWakeupS+0x62>

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    145e:	68b3      	ldr	r3, [r6, #8]
    1460:	68a2      	ldr	r2, [r4, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
    1462:	6267      	str	r7, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    1464:	429a      	cmp	r2, r3
    1466:	d917      	bls.n	1498 <chSchWakeupS+0x58>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
    1468:	4630      	mov	r0, r6
    146a:	f7ff ff01 	bl	1270 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
    146e:	2301      	movs	r3, #1

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    1470:	4601      	mov	r1, r0
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
    1472:	4606      	mov	r6, r0
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
    1474:	f884 3020 	strb.w	r3, [r4, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    1478:	4620      	mov	r0, r4
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    147a:	61ac      	str	r4, [r5, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    147c:	f000 fc00 	bl	1c80 <_stats_ctxswc>
    1480:	f3ef 8309 	mrs	r3, PSP
    1484:	69f2      	ldr	r2, [r6, #28]
    1486:	3b64      	subs	r3, #100	; 0x64
    1488:	429a      	cmp	r2, r3
    148a:	d80e      	bhi.n	14aa <chSchWakeupS+0x6a>
    148c:	4620      	mov	r0, r4
    148e:	4631      	mov	r1, r6
  }
}
    1490:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    1494:	f7ff b84c 	b.w	530 <_port_switch>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
    1498:	4620      	mov	r0, r4
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
    149a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
    149e:	f7ff bee7 	b.w	1270 <chSchReadyI>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    14a2:	4807      	ldr	r0, [pc, #28]	; (14c0 <chSchWakeupS+0x80>)
    14a4:	f7ff fd6c 	bl	f80 <chSysHalt>
    14a8:	e7d9      	b.n	145e <chSchWakeupS+0x1e>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    14aa:	4806      	ldr	r0, [pc, #24]	; (14c4 <chSchWakeupS+0x84>)
    14ac:	f7ff fd68 	bl	f80 <chSysHalt>
    14b0:	4620      	mov	r0, r4
    14b2:	4631      	mov	r1, r6
  }
}
    14b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    14b8:	f7ff b83a 	b.w	530 <_port_switch>
    14bc:	1ffff228 	.word	0x1ffff228
    14c0:	00006a00 	.word	0x00006a00
    14c4:	00006a20 	.word	0x00006a20
    14c8:	f3af 8000 	nop.w
    14cc:	f3af 8000 	nop.w

000014d0 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
    14d0:	4b08      	ldr	r3, [pc, #32]	; (14f4 <chSchIsPreemptionRequired+0x24>)
  tprio_t p2 = currp->prio;
    14d2:	699a      	ldr	r2, [r3, #24]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
    14d4:	681b      	ldr	r3, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    14d6:	f892 1023 	ldrb.w	r1, [r2, #35]	; 0x23
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
    14da:	689b      	ldr	r3, [r3, #8]
  tprio_t p2 = currp->prio;
    14dc:	6890      	ldr	r0, [r2, #8]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    14de:	b921      	cbnz	r1, 14ea <chSchIsPreemptionRequired+0x1a>
    14e0:	4283      	cmp	r3, r0
    14e2:	bf34      	ite	cc
    14e4:	2000      	movcc	r0, #0
    14e6:	2001      	movcs	r0, #1
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
    14e8:	4770      	bx	lr
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    14ea:	4283      	cmp	r3, r0
    14ec:	bf94      	ite	ls
    14ee:	2000      	movls	r0, #0
    14f0:	2001      	movhi	r0, #1
    14f2:	4770      	bx	lr
    14f4:	1ffff228 	.word	0x1ffff228
    14f8:	f3af 8000 	nop.w
    14fc:	f3af 8000 	nop.w

00001500 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    1500:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
    1502:	4c10      	ldr	r4, [pc, #64]	; (1544 <chSchDoRescheduleAhead+0x44>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
    1504:	6823      	ldr	r3, [r4, #0]
    1506:	69a0      	ldr	r0, [r4, #24]

  tqp->next             = tp->queue.next;
    1508:	681a      	ldr	r2, [r3, #0]
    150a:	6022      	str	r2, [r4, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
    150c:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
    150e:	6054      	str	r4, [r2, #4]
    1510:	f883 1020 	strb.w	r1, [r3, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
    1514:	61a3      	str	r3, [r4, #24]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
    1516:	f7ff ff0b 	bl	1330 <chSchReadyAheadI>

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    151a:	4601      	mov	r1, r0
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
    151c:	4605      	mov	r5, r0

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    151e:	69a0      	ldr	r0, [r4, #24]
    1520:	f000 fbae 	bl	1c80 <_stats_ctxswc>
    1524:	f3ef 8309 	mrs	r3, PSP
    1528:	69ea      	ldr	r2, [r5, #28]
    152a:	3b64      	subs	r3, #100	; 0x64
    152c:	429a      	cmp	r2, r3
    152e:	d902      	bls.n	1536 <chSchDoRescheduleAhead+0x36>
    1530:	4805      	ldr	r0, [pc, #20]	; (1548 <chSchDoRescheduleAhead+0x48>)
    1532:	f7ff fd25 	bl	f80 <chSysHalt>
    1536:	69a0      	ldr	r0, [r4, #24]
    1538:	4629      	mov	r1, r5
}
    153a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    153e:	f7fe bff7 	b.w	530 <_port_switch>
    1542:	bf00      	nop
    1544:	1ffff228 	.word	0x1ffff228
    1548:	00006a20 	.word	0x00006a20
    154c:	f3af 8000 	nop.w

00001550 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
    1550:	b508      	push	{r3, lr}

  chDbgCheckClassS();
    1552:	f7ff fe05 	bl	1160 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
    1556:	f7ff fdf3 	bl	1140 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
    155a:	4b06      	ldr	r3, [pc, #24]	; (1574 <chSchRescheduleS+0x24>)
    155c:	681a      	ldr	r2, [r3, #0]
    155e:	699b      	ldr	r3, [r3, #24]

  if (chSchIsRescRequiredI()) {
    1560:	6892      	ldr	r2, [r2, #8]
    1562:	689b      	ldr	r3, [r3, #8]
    1564:	429a      	cmp	r2, r3
    1566:	d800      	bhi.n	156a <chSchRescheduleS+0x1a>
    1568:	bd08      	pop	{r3, pc}
    chSchDoRescheduleAhead();
  }
}
    156a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
    156e:	f7ff bfc7 	b.w	1500 <chSchDoRescheduleAhead>
    1572:	bf00      	nop
    1574:	1ffff228 	.word	0x1ffff228
    1578:	f3af 8000 	nop.w
    157c:	f3af 8000 	nop.w

00001580 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1580:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
    1582:	4c15      	ldr	r4, [pc, #84]	; (15d8 <chSchDoReschedule+0x58>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
    1584:	6823      	ldr	r3, [r4, #0]
    1586:	69a0      	ldr	r0, [r4, #24]

  tqp->next             = tp->queue.next;
    1588:	681a      	ldr	r2, [r3, #0]
  }

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->preempt == (tslices_t)0) {
    158a:	f893 1023 	ldrb.w	r1, [r3, #35]	; 0x23
    158e:	6022      	str	r2, [r4, #0]
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
    1590:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
    1592:	6054      	str	r4, [r2, #4]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
    1594:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
    1596:	f883 5020 	strb.w	r5, [r3, #32]
  }

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->preempt == (tslices_t)0) {
    159a:	b9c1      	cbnz	r1, 15ce <chSchDoReschedule+0x4e>

    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    otp = chSchReadyI(otp);
    159c:	f7ff fe68 	bl	1270 <chSchReadyI>

    /* The thread being swapped out receives a new time quantum.*/
    otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    15a0:	2314      	movs	r3, #20
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->preempt == (tslices_t)0) {

    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    otp = chSchReadyI(otp);
    15a2:	4605      	mov	r5, r0

    /* The thread being swapped out receives a new time quantum.*/
    otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    15a4:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    15a8:	69a0      	ldr	r0, [r4, #24]
    15aa:	4629      	mov	r1, r5
    15ac:	f000 fb68 	bl	1c80 <_stats_ctxswc>
    15b0:	f3ef 8309 	mrs	r3, PSP
    15b4:	69ea      	ldr	r2, [r5, #28]
    15b6:	3b64      	subs	r3, #100	; 0x64
    15b8:	429a      	cmp	r2, r3
    15ba:	d902      	bls.n	15c2 <chSchDoReschedule+0x42>
    15bc:	4807      	ldr	r0, [pc, #28]	; (15dc <chSchDoReschedule+0x5c>)
    15be:	f7ff fcdf 	bl	f80 <chSysHalt>
    15c2:	69a0      	ldr	r0, [r4, #24]
    15c4:	4629      	mov	r1, r5
}
    15c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    15ca:	f7fe bfb1 	b.w	530 <_port_switch>
    otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    otp = chSchReadyAheadI(otp);
    15ce:	f7ff feaf 	bl	1330 <chSchReadyAheadI>
    15d2:	4605      	mov	r5, r0
    15d4:	e7e8      	b.n	15a8 <chSchDoReschedule+0x28>
    15d6:	bf00      	nop
    15d8:	1ffff228 	.word	0x1ffff228
    15dc:	00006a20 	.word	0x00006a20

000015e0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
    15e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
    15e2:	4b13      	ldr	r3, [pc, #76]	; (1630 <_thread_init+0x50>)
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
    15e4:	6181      	str	r1, [r0, #24]
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
    15e6:	4604      	mov	r4, r0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
    15e8:	695e      	ldr	r6, [r3, #20]
    15ea:	6166      	str	r6, [r4, #20]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
    15ec:	2100      	movs	r1, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
    15ee:	f04f 0c02 	mov.w	ip, #2
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
    15f2:	f04f 0e14 	mov.w	lr, #20
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
    15f6:	f104 052c 	add.w	r5, r4, #44	; 0x2c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
    15fa:	2001      	movs	r0, #1
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
    15fc:	f104 0728 	add.w	r7, r4, #40	; 0x28
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
    1600:	60a2      	str	r2, [r4, #8]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
    1602:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
  tp->name      = name;
  REG_INSERT(tp);
    1606:	6123      	str	r3, [r4, #16]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
    1608:	63e2      	str	r2, [r4, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
    160a:	f884 c020 	strb.w	ip, [r4, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
    160e:	f884 e023 	strb.w	lr, [r4, #35]	; 0x23
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
    1612:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
    1616:	63a1      	str	r1, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
    1618:	6361      	str	r1, [r4, #52]	; 0x34
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
    161a:	f104 0048 	add.w	r0, r4, #72	; 0x48
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
    161e:	6134      	str	r4, [r6, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
    1620:	62a7      	str	r7, [r4, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
    1622:	62e5      	str	r5, [r4, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
    1624:	6325      	str	r5, [r4, #48]	; 0x30
    1626:	615c      	str	r4, [r3, #20]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
    1628:	f000 fa82 	bl	1b30 <chTMObjectInit>
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
    162c:	4620      	mov	r0, r4
    162e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1630:	1ffff228 	.word	0x1ffff228
    1634:	f3af 8000 	nop.w
    1638:	f3af 8000 	nop.w
    163c:	f3af 8000 	nop.w

00001640 <_thread_memfill>:
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    1640:	4288      	cmp	r0, r1
    1642:	d203      	bcs.n	164c <_thread_memfill+0xc>
    *startp++ = v;
    1644:	f800 2b01 	strb.w	r2, [r0], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    1648:	4288      	cmp	r0, r1
    164a:	d1fb      	bne.n	1644 <_thread_memfill+0x4>
    164c:	4770      	bx	lr
    164e:	bf00      	nop

00001650 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
    1650:	b570      	push	{r4, r5, r6, lr}
    1652:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
    1654:	f7ff fd74 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
    1658:	b384      	cbz	r4, 16bc <chThdCreateSuspendedI+0x6c>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
    165a:	6863      	ldr	r3, [r4, #4]
    165c:	0758      	lsls	r0, r3, #29
    165e:	d102      	bne.n	1666 <chThdCreateSuspendedI+0x16>
    1660:	68a2      	ldr	r2, [r4, #8]
    1662:	0751      	lsls	r1, r2, #29
    1664:	d01d      	beq.n	16a2 <chThdCreateSuspendedI+0x52>
    1666:	4817      	ldr	r0, [pc, #92]	; (16c4 <chThdCreateSuspendedI+0x74>)
    1668:	f7ff fc8a 	bl	f80 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
    166c:	68e2      	ldr	r2, [r4, #12]
    166e:	2aff      	cmp	r2, #255	; 0xff
    1670:	d81e      	bhi.n	16b0 <chThdCreateSuspendedI+0x60>
    1672:	6923      	ldr	r3, [r4, #16]
    1674:	b1e3      	cbz	r3, 16b0 <chThdCreateSuspendedI+0x60>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
    1676:	68a0      	ldr	r0, [r4, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
    1678:	6866      	ldr	r6, [r4, #4]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
    167a:	6961      	ldr	r1, [r4, #20]
    167c:	4d12      	ldr	r5, [pc, #72]	; (16c8 <chThdCreateSuspendedI+0x78>)
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
    167e:	f840 6c44 	str.w	r6, [r0, #-68]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
    1682:	f1a0 06c4 	sub.w	r6, r0, #196	; 0xc4
    1686:	f840 6c54 	str.w	r6, [r0, #-84]
    168a:	f840 1c80 	str.w	r1, [r0, #-128]
    168e:	f840 3c84 	str.w	r3, [r0, #-132]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
    1692:	6821      	ldr	r1, [r4, #0]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
    1694:	f840 5c64 	str.w	r5, [r0, #-100]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
    1698:	3860      	subs	r0, #96	; 0x60
}
    169a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
    169e:	f7ff bf9f 	b.w	15e0 <_thread_init>
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
  chDbgCheck(tdp != NULL);
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
    16a2:	4293      	cmp	r3, r2
    16a4:	d2df      	bcs.n	1666 <chThdCreateSuspendedI+0x16>
    16a6:	1ad3      	subs	r3, r2, r3
    16a8:	f5b3 7fb8 	cmp.w	r3, #368	; 0x170
    16ac:	d2de      	bcs.n	166c <chThdCreateSuspendedI+0x1c>
    16ae:	e7da      	b.n	1666 <chThdCreateSuspendedI+0x16>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
    16b0:	4804      	ldr	r0, [pc, #16]	; (16c4 <chThdCreateSuspendedI+0x74>)
    16b2:	f7ff fc65 	bl	f80 <chSysHalt>
    16b6:	6923      	ldr	r3, [r4, #16]
    16b8:	68e2      	ldr	r2, [r4, #12]
    16ba:	e7dc      	b.n	1676 <chThdCreateSuspendedI+0x26>
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
  chDbgCheck(tdp != NULL);
    16bc:	4801      	ldr	r0, [pc, #4]	; (16c4 <chThdCreateSuspendedI+0x74>)
    16be:	f7ff fc5f 	bl	f80 <chSysHalt>
    16c2:	e7ca      	b.n	165a <chThdCreateSuspendedI+0xa>
    16c4:	00006b20 	.word	0x00006b20
    16c8:	00000549 	.word	0x00000549
    16cc:	f3af 8000 	nop.w

000016d0 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
    16d0:	b510      	push	{r4, lr}
    16d2:	4604      	mov	r4, r0
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
    16d4:	6840      	ldr	r0, [r0, #4]
    16d6:	f000 fb73 	bl	1dc0 <chRegFindThreadByWorkingArea>
    16da:	b110      	cbz	r0, 16e2 <chThdCreate+0x12>
    16dc:	4817      	ldr	r0, [pc, #92]	; (173c <chThdCreate+0x6c>)
    16de:	f7ff fc4f 	bl	f80 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
    16e2:	6863      	ldr	r3, [r4, #4]
                  (uint8_t *)tdp->wend,
    16e4:	68a2      	ldr	r2, [r4, #8]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    16e6:	4293      	cmp	r3, r2
    *startp++ = v;
    16e8:	bf38      	it	cc
    16ea:	2155      	movcc	r1, #85	; 0x55
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    16ec:	d203      	bcs.n	16f6 <chThdCreate+0x26>
    *startp++ = v;
    16ee:	f803 1b01 	strb.w	r1, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    16f2:	4293      	cmp	r3, r2
    16f4:	d1fb      	bne.n	16ee <chThdCreate+0x1e>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    16f6:	2320      	movs	r3, #32
    16f8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    16fc:	f000 fad8 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1700:	f7ff fc96 	bl	1030 <_dbg_check_lock>
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
    1704:	4620      	mov	r0, r4
    1706:	f7ff ffa3 	bl	1650 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
    170a:	2100      	movs	r1, #0
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
    170c:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
    170e:	f7ff fe97 	bl	1440 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1712:	f7ff fc9d 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1716:	f000 fad3 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    171a:	4b09      	ldr	r3, [pc, #36]	; (1740 <chThdCreate+0x70>)
    171c:	681a      	ldr	r2, [r3, #0]
    171e:	429a      	cmp	r2, r3
    1720:	d007      	beq.n	1732 <chThdCreate+0x62>
    1722:	6999      	ldr	r1, [r3, #24]
    1724:	6893      	ldr	r3, [r2, #8]
    1726:	688a      	ldr	r2, [r1, #8]
    1728:	429a      	cmp	r2, r3
    172a:	d202      	bcs.n	1732 <chThdCreate+0x62>
    172c:	4805      	ldr	r0, [pc, #20]	; (1744 <chThdCreate+0x74>)
    172e:	f7ff fc27 	bl	f80 <chSysHalt>
    1732:	2300      	movs	r3, #0
    1734:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
    1738:	4620      	mov	r0, r4
    173a:	bd10      	pop	{r4, pc}
    173c:	00006b40 	.word	0x00006b40
    1740:	1ffff228 	.word	0x1ffff228
    1744:	00006a70 	.word	0x00006a70
    1748:	f3af 8000 	nop.w
    174c:	f3af 8000 	nop.w

00001750 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1750:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1754:	4688      	mov	r8, r1
    1756:	4691      	mov	r9, r2
    1758:	469a      	mov	sl, r3
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
    175a:	4607      	mov	r7, r0
    175c:	b108      	cbz	r0, 1762 <chThdCreateStatic+0x12>
    175e:	0743      	lsls	r3, r0, #29
    1760:	d048      	beq.n	17f4 <chThdCreateStatic+0xa4>
    1762:	482a      	ldr	r0, [pc, #168]	; (180c <chThdCreateStatic+0xbc>)
    1764:	f7ff fc0c 	bl	f80 <chSysHalt>
             (size >= THD_WORKING_AREA_SIZE(0)) &&
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
    1768:	4638      	mov	r0, r7
    176a:	f000 fb29 	bl	1dc0 <chRegFindThreadByWorkingArea>
    176e:	b110      	cbz	r0, 1776 <chThdCreateStatic+0x26>
    1770:	4826      	ldr	r0, [pc, #152]	; (180c <chThdCreateStatic+0xbc>)
    1772:	f7ff fc05 	bl	f80 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    1776:	eb07 0508 	add.w	r5, r7, r8
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    177a:	42af      	cmp	r7, r5
    177c:	d205      	bcs.n	178a <chThdCreateStatic+0x3a>
    177e:	463c      	mov	r4, r7
    *startp++ = v;
    1780:	2655      	movs	r6, #85	; 0x55
    1782:	f804 6b01 	strb.w	r6, [r4], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    1786:	42ac      	cmp	r4, r5
    1788:	d1fb      	bne.n	1782 <chThdCreateStatic+0x32>
    178a:	2320      	movs	r3, #32
    178c:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1790:	f000 fa8e 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1794:	f7ff fc4c 	bl	1030 <_dbg_check_lock>
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
    1798:	f1a8 0160 	sub.w	r1, r8, #96	; 0x60
    179c:	4439      	add	r1, r7
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
    179e:	4b1c      	ldr	r3, [pc, #112]	; (1810 <chThdCreateStatic+0xc0>)
    17a0:	9a08      	ldr	r2, [sp, #32]
    17a2:	f841 3c04 	str.w	r3, [r1, #-4]
    17a6:	f1a1 0064 	sub.w	r0, r1, #100	; 0x64
    17aa:	f841 2c20 	str.w	r2, [r1, #-32]
    17ae:	60c8      	str	r0, [r1, #12]

  tp = _thread_init(tp, "noname", prio);
    17b0:	464a      	mov	r2, r9
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
    17b2:	61cf      	str	r7, [r1, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
    17b4:	f841 ac24 	str.w	sl, [r1, #-36]

  tp = _thread_init(tp, "noname", prio);
    17b8:	4608      	mov	r0, r1
    17ba:	4916      	ldr	r1, [pc, #88]	; (1814 <chThdCreateStatic+0xc4>)
    17bc:	f7ff ff10 	bl	15e0 <_thread_init>

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
    17c0:	2100      	movs	r1, #0
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);
    17c2:	4604      	mov	r4, r0

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
    17c4:	f7ff fe3c 	bl	1440 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    17c8:	f7ff fc42 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    17cc:	f000 fa78 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    17d0:	4b11      	ldr	r3, [pc, #68]	; (1818 <chThdCreateStatic+0xc8>)
    17d2:	681a      	ldr	r2, [r3, #0]
    17d4:	429a      	cmp	r2, r3
    17d6:	d007      	beq.n	17e8 <chThdCreateStatic+0x98>
    17d8:	6999      	ldr	r1, [r3, #24]
    17da:	6893      	ldr	r3, [r2, #8]
    17dc:	688a      	ldr	r2, [r1, #8]
    17de:	429a      	cmp	r2, r3
    17e0:	d202      	bcs.n	17e8 <chThdCreateStatic+0x98>
    17e2:	480e      	ldr	r0, [pc, #56]	; (181c <chThdCreateStatic+0xcc>)
    17e4:	f7ff fbcc 	bl	f80 <chSysHalt>
    17e8:	2300      	movs	r3, #0
    17ea:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
    17ee:	4620      	mov	r0, r4
    17f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
    17f4:	f5b1 7fb8 	cmp.w	r1, #368	; 0x170
    17f8:	d3b3      	bcc.n	1762 <chThdCreateStatic+0x12>
    17fa:	f011 0f07 	tst.w	r1, #7
    17fe:	d1b0      	bne.n	1762 <chThdCreateStatic+0x12>
    1800:	2aff      	cmp	r2, #255	; 0xff
    1802:	d8ae      	bhi.n	1762 <chThdCreateStatic+0x12>
    1804:	f1ba 0f00 	cmp.w	sl, #0
    1808:	d1ae      	bne.n	1768 <chThdCreateStatic+0x18>
    180a:	e7aa      	b.n	1762 <chThdCreateStatic+0x12>
    180c:	00006a50 	.word	0x00006a50
    1810:	00000549 	.word	0x00000549
    1814:	00006ae0 	.word	0x00006ae0
    1818:	1ffff228 	.word	0x1ffff228
    181c:	00006a70 	.word	0x00006a70

00001820 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
    1820:	b510      	push	{r4, lr}
    1822:	2320      	movs	r3, #32
    1824:	4604      	mov	r4, r0
    1826:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    182a:	f000 fa41 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    182e:	f7ff fbff 	bl	1030 <_dbg_check_lock>

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
    1832:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    1836:	b1fb      	cbz	r3, 1878 <chThdRelease+0x58>
  tp->refs--;
    1838:	3b01      	subs	r3, #1
    183a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    183e:	6a23      	ldr	r3, [r4, #32]
    1840:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
    1844:	2b0f      	cmp	r3, #15
    1846:	d01d      	beq.n	1884 <chThdRelease+0x64>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1848:	f7ff fc02 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    184c:	f000 fa38 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1850:	4b23      	ldr	r3, [pc, #140]	; (18e0 <chThdRelease+0xc0>)
    1852:	681a      	ldr	r2, [r3, #0]
    1854:	429a      	cmp	r2, r3
    1856:	d004      	beq.n	1862 <chThdRelease+0x42>
    1858:	6999      	ldr	r1, [r3, #24]
    185a:	6893      	ldr	r3, [r2, #8]
    185c:	688a      	ldr	r2, [r1, #8]
    185e:	429a      	cmp	r2, r3
    1860:	d303      	bcc.n	186a <chThdRelease+0x4a>
    1862:	2300      	movs	r3, #0
    1864:	f383 8811 	msr	BASEPRI, r3
    1868:	bd10      	pop	{r4, pc}
    186a:	481e      	ldr	r0, [pc, #120]	; (18e4 <chThdRelease+0xc4>)
    186c:	f7ff fb88 	bl	f80 <chSysHalt>
    1870:	2300      	movs	r3, #0
    1872:	f383 8811 	msr	BASEPRI, r3
    1876:	bd10      	pop	{r4, pc}
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
    1878:	481b      	ldr	r0, [pc, #108]	; (18e8 <chThdRelease+0xc8>)
    187a:	f7ff fb81 	bl	f80 <chSysHalt>
    187e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    1882:	e7d9      	b.n	1838 <chThdRelease+0x18>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
    1884:	6963      	ldr	r3, [r4, #20]
    1886:	6922      	ldr	r2, [r4, #16]
    1888:	611a      	str	r2, [r3, #16]
    188a:	6922      	ldr	r2, [r4, #16]
    188c:	6153      	str	r3, [r2, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    188e:	f7ff fbdf 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1892:	f000 fa15 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1896:	4b12      	ldr	r3, [pc, #72]	; (18e0 <chThdRelease+0xc0>)
    1898:	681a      	ldr	r2, [r3, #0]
    189a:	429a      	cmp	r2, r3
    189c:	d004      	beq.n	18a8 <chThdRelease+0x88>
    189e:	6999      	ldr	r1, [r3, #24]
    18a0:	6893      	ldr	r3, [r2, #8]
    18a2:	688a      	ldr	r2, [r1, #8]
    18a4:	429a      	cmp	r2, r3
    18a6:	d30b      	bcc.n	18c0 <chThdRelease+0xa0>
    18a8:	2300      	movs	r3, #0
    18aa:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
    18ae:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    18b2:	f003 0303 	and.w	r3, r3, #3
    18b6:	2b01      	cmp	r3, #1
    18b8:	d006      	beq.n	18c8 <chThdRelease+0xa8>
    18ba:	2b02      	cmp	r3, #2
    18bc:	d009      	beq.n	18d2 <chThdRelease+0xb2>
    18be:	bd10      	pop	{r4, pc}
    18c0:	4808      	ldr	r0, [pc, #32]	; (18e4 <chThdRelease+0xc4>)
    18c2:	f7ff fb5d 	bl	f80 <chSysHalt>
    18c6:	e7ef      	b.n	18a8 <chThdRelease+0x88>
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
    18c8:	69e0      	ldr	r0, [r4, #28]
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
    18ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
    18ce:	f000 be27 	b.w	2520 <chHeapFree>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
    18d2:	6c20      	ldr	r0, [r4, #64]	; 0x40
    18d4:	69e1      	ldr	r1, [r4, #28]
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
    18d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
    18da:	f000 bee1 	b.w	26a0 <chPoolFree>
    18de:	bf00      	nop
    18e0:	1ffff228 	.word	0x1ffff228
    18e4:	00006a70 	.word	0x00006a70
    18e8:	00006a80 	.word	0x00006a80
    18ec:	f3af 8000 	nop.w

000018f0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    18f0:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
    18f2:	4b12      	ldr	r3, [pc, #72]	; (193c <chThdExitS+0x4c>)
    18f4:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
    18f6:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
    18f8:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    18fa:	f104 0528 	add.w	r5, r4, #40	; 0x28
    18fe:	429d      	cmp	r5, r3
    1900:	d007      	beq.n	1912 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
    1902:	681a      	ldr	r2, [r3, #0]
    1904:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
    1906:	4618      	mov	r0, r3
    1908:	f7ff fcb2 	bl	1270 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
    190c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    190e:	42ab      	cmp	r3, r5
    1910:	d1f7      	bne.n	1902 <chThdExitS+0x12>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
    1912:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    1916:	b943      	cbnz	r3, 192a <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    1918:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
    191c:	079b      	lsls	r3, r3, #30
    191e:	d104      	bne.n	192a <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
    1920:	6963      	ldr	r3, [r4, #20]
    1922:	6922      	ldr	r2, [r4, #16]
    1924:	611a      	str	r2, [r3, #16]
    1926:	6922      	ldr	r2, [r4, #16]
    1928:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
    192a:	200f      	movs	r0, #15
    192c:	f7ff fd28 	bl	1380 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    1930:	4803      	ldr	r0, [pc, #12]	; (1940 <chThdExitS+0x50>)
}
    1932:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    1936:	f7ff bb23 	b.w	f80 <chSysHalt>
    193a:	bf00      	nop
    193c:	1ffff228 	.word	0x1ffff228
    1940:	00006af0 	.word	0x00006af0
    1944:	f3af 8000 	nop.w
    1948:	f3af 8000 	nop.w
    194c:	f3af 8000 	nop.w

00001950 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1950:	b510      	push	{r4, lr}
    1952:	2320      	movs	r3, #32
    1954:	4604      	mov	r4, r0
    1956:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    195a:	f000 f9a9 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    195e:	f7ff fb67 	bl	1030 <_dbg_check_lock>

  chSysLock();
  chThdExitS(msg);
    1962:	4620      	mov	r0, r4
  /* The thread never returns here.*/
}
    1964:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
    1968:	f7ff bfc2 	b.w	18f0 <chThdExitS>
    196c:	f3af 8000 	nop.w

00001970 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
    1970:	b570      	push	{r4, r5, r6, lr}
  msg_t msg;

  chDbgCheck(tp != NULL);
    1972:	4604      	mov	r4, r0
    1974:	2800      	cmp	r0, #0
    1976:	d039      	beq.n	19ec <chThdWait+0x7c>
    1978:	2320      	movs	r3, #32
    197a:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
    197e:	4d1d      	ldr	r5, [pc, #116]	; (19f4 <chThdWait+0x84>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1980:	f000 f996 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1984:	f7ff fb54 	bl	1030 <_dbg_check_lock>
    1988:	69ab      	ldr	r3, [r5, #24]
    198a:	42a3      	cmp	r3, r4
    198c:	d02a      	beq.n	19e4 <chThdWait+0x74>
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
    198e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    1992:	b31b      	cbz	r3, 19dc <chThdWait+0x6c>
#endif

  if (tp->state != CH_STATE_FINAL) {
    1994:	f894 3020 	ldrb.w	r3, [r4, #32]
    1998:	2b0f      	cmp	r3, #15
    199a:	d006      	beq.n	19aa <chThdWait+0x3a>
    list_insert(currp, &tp->waiting);
    199c:	69ab      	ldr	r3, [r5, #24]
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->queue.next = tlp->next;
    199e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    19a0:	601a      	str	r2, [r3, #0]
    chSchGoSleepS(CH_STATE_WTEXIT);
    19a2:	2009      	movs	r0, #9
  tlp->next = tp;
    19a4:	62a3      	str	r3, [r4, #40]	; 0x28
    19a6:	f7ff fceb 	bl	1380 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
    19aa:	6a66      	ldr	r6, [r4, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    19ac:	f7ff fb50 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    19b0:	f000 f986 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    19b4:	682b      	ldr	r3, [r5, #0]
    19b6:	4a0f      	ldr	r2, [pc, #60]	; (19f4 <chThdWait+0x84>)
    19b8:	42ab      	cmp	r3, r5
    19ba:	d007      	beq.n	19cc <chThdWait+0x5c>
    19bc:	6992      	ldr	r2, [r2, #24]
    19be:	689b      	ldr	r3, [r3, #8]
    19c0:	6892      	ldr	r2, [r2, #8]
    19c2:	429a      	cmp	r2, r3
    19c4:	d202      	bcs.n	19cc <chThdWait+0x5c>
    19c6:	480c      	ldr	r0, [pc, #48]	; (19f8 <chThdWait+0x88>)
    19c8:	f7ff fada 	bl	f80 <chSysHalt>
    19cc:	2300      	movs	r3, #0
    19ce:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
    19d2:	4620      	mov	r0, r4
    19d4:	f7ff ff24 	bl	1820 <chThdRelease>
#endif

  return msg;
}
    19d8:	4630      	mov	r0, r6
    19da:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(tp != NULL);

  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
    19dc:	4807      	ldr	r0, [pc, #28]	; (19fc <chThdWait+0x8c>)
    19de:	f7ff facf 	bl	f80 <chSysHalt>
    19e2:	e7d7      	b.n	1994 <chThdWait+0x24>
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
    19e4:	4805      	ldr	r0, [pc, #20]	; (19fc <chThdWait+0x8c>)
    19e6:	f7ff facb 	bl	f80 <chSysHalt>
    19ea:	e7d0      	b.n	198e <chThdWait+0x1e>
 * @api
 */
msg_t chThdWait(thread_t *tp) {
  msg_t msg;

  chDbgCheck(tp != NULL);
    19ec:	4803      	ldr	r0, [pc, #12]	; (19fc <chThdWait+0x8c>)
    19ee:	f7ff fac7 	bl	f80 <chSysHalt>
    19f2:	e7c1      	b.n	1978 <chThdWait+0x8>
    19f4:	1ffff228 	.word	0x1ffff228
    19f8:	00006a70 	.word	0x00006a70
    19fc:	00006b10 	.word	0x00006b10

00001a00 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1a00:	b510      	push	{r4, lr}
    1a02:	2320      	movs	r3, #32
    1a04:	4604      	mov	r4, r0
    1a06:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1a0a:	f000 f951 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1a0e:	f7ff fb0f 	bl	1030 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
    1a12:	b914      	cbnz	r4, 1a1a <chThdSleep+0x1a>
    1a14:	480d      	ldr	r0, [pc, #52]	; (1a4c <chThdSleep+0x4c>)
    1a16:	f7ff fab3 	bl	f80 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    1a1a:	4621      	mov	r1, r4
    1a1c:	2008      	movs	r0, #8
    1a1e:	f7ff fcdf 	bl	13e0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1a22:	f7ff fb15 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1a26:	f000 f94b 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1a2a:	4b09      	ldr	r3, [pc, #36]	; (1a50 <chThdSleep+0x50>)
    1a2c:	681a      	ldr	r2, [r3, #0]
    1a2e:	429a      	cmp	r2, r3
    1a30:	d007      	beq.n	1a42 <chThdSleep+0x42>
    1a32:	6999      	ldr	r1, [r3, #24]
    1a34:	6893      	ldr	r3, [r2, #8]
    1a36:	688a      	ldr	r2, [r1, #8]
    1a38:	429a      	cmp	r2, r3
    1a3a:	d202      	bcs.n	1a42 <chThdSleep+0x42>
    1a3c:	4805      	ldr	r0, [pc, #20]	; (1a54 <chThdSleep+0x54>)
    1a3e:	f7ff fa9f 	bl	f80 <chSysHalt>
    1a42:	2300      	movs	r3, #0
    1a44:	f383 8811 	msr	BASEPRI, r3
    1a48:	bd10      	pop	{r4, pc}
    1a4a:	bf00      	nop
    1a4c:	00006b00 	.word	0x00006b00
    1a50:	1ffff228 	.word	0x1ffff228
    1a54:	00006a70 	.word	0x00006a70
    1a58:	f3af 8000 	nop.w
    1a5c:	f3af 8000 	nop.w

00001a60 <chThdSuspendTimeoutS>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
    1a60:	4a0a      	ldr	r2, [pc, #40]	; (1a8c <chThdSuspendTimeoutS+0x2c>)
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
    1a62:	6803      	ldr	r3, [r0, #0]
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
    1a64:	b570      	push	{r4, r5, r6, lr}
    1a66:	4604      	mov	r4, r0
    1a68:	6996      	ldr	r6, [r2, #24]
    1a6a:	460d      	mov	r5, r1
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
    1a6c:	b113      	cbz	r3, 1a74 <chThdSuspendTimeoutS+0x14>
    1a6e:	4808      	ldr	r0, [pc, #32]	; (1a90 <chThdSuspendTimeoutS+0x30>)
    1a70:	f7ff fa86 	bl	f80 <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
    1a74:	b13d      	cbz	r5, 1a86 <chThdSuspendTimeoutS+0x26>
    return MSG_TIMEOUT;
  }

  *trp = tp;
    1a76:	6026      	str	r6, [r4, #0]
  tp->u.wttrp = trp;
    1a78:	6274      	str	r4, [r6, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
    1a7a:	4629      	mov	r1, r5
    1a7c:	2003      	movs	r0, #3
}
    1a7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  *trp = tp;
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
    1a82:	f7ff bcad 	b.w	13e0 <chSchGoSleepTimeoutS>
}
    1a86:	f04f 30ff 	mov.w	r0, #4294967295
    1a8a:	bd70      	pop	{r4, r5, r6, pc}
    1a8c:	1ffff228 	.word	0x1ffff228
    1a90:	00006a90 	.word	0x00006a90
    1a94:	f3af 8000 	nop.w
    1a98:	f3af 8000 	nop.w
    1a9c:	f3af 8000 	nop.w

00001aa0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1aa0:	b570      	push	{r4, r5, r6, lr}

  if (*trp != NULL) {
    1aa2:	6804      	ldr	r4, [r0, #0]
    1aa4:	b184      	cbz	r4, 1ac8 <chThdResumeI+0x28>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
    1aa6:	f894 3020 	ldrb.w	r3, [r4, #32]
    1aaa:	2b03      	cmp	r3, #3
    1aac:	460e      	mov	r6, r1
    1aae:	4605      	mov	r5, r0
    1ab0:	d002      	beq.n	1ab8 <chThdResumeI+0x18>
    1ab2:	4806      	ldr	r0, [pc, #24]	; (1acc <chThdResumeI+0x2c>)
    1ab4:	f7ff fa64 	bl	f80 <chSysHalt>

    *trp = NULL;
    1ab8:	2300      	movs	r3, #0
    1aba:	602b      	str	r3, [r5, #0]
    tp->u.rdymsg = msg;
    1abc:	6266      	str	r6, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
    1abe:	4620      	mov	r0, r4
  }
}
    1ac0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
    1ac4:	f7ff bbd4 	b.w	1270 <chSchReadyI>
    1ac8:	bd70      	pop	{r4, r5, r6, pc}
    1aca:	bf00      	nop
    1acc:	00006ab0 	.word	0x00006ab0

00001ad0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    1ad0:	b169      	cbz	r1, 1aee <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
    1ad2:	4b08      	ldr	r3, [pc, #32]	; (1af4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    1ad4:	b410      	push	{r4}
    1ad6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
    1ad8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
    1ada:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1adc:	2004      	movs	r0, #4
    1ade:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
    1ae2:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
    1ae4:	6053      	str	r3, [r2, #4]
}
    1ae6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1aea:	f7ff bc79 	b.w	13e0 <chSchGoSleepTimeoutS>
}
    1aee:	f04f 30ff 	mov.w	r0, #4294967295
    1af2:	4770      	bx	lr
    1af4:	1ffff228 	.word	0x1ffff228
    1af8:	f3af 8000 	nop.w
    1afc:	f3af 8000 	nop.w

00001b00 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    1b00:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
    1b02:	6804      	ldr	r4, [r0, #0]

  if (queue_notempty(tqp)) {
    1b04:	42a0      	cmp	r0, r4
    1b06:	d010      	beq.n	1b2a <chThdDequeueNextI+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
    1b08:	6822      	ldr	r2, [r4, #0]
    1b0a:	6002      	str	r2, [r0, #0]
    1b0c:	460d      	mov	r5, r1

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
    1b0e:	f894 1020 	ldrb.w	r1, [r4, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
    1b12:	6050      	str	r0, [r2, #4]
    1b14:	2904      	cmp	r1, #4
    1b16:	d002      	beq.n	1b1e <chThdDequeueNextI+0x1e>
    1b18:	4804      	ldr	r0, [pc, #16]	; (1b2c <chThdDequeueNextI+0x2c>)
    1b1a:	f7ff fa31 	bl	f80 <chSysHalt>

  tp->u.rdymsg = msg;
    1b1e:	6265      	str	r5, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    1b20:	4620      	mov	r0, r4
    chThdDoDequeueNextI(tqp, msg);
  }
}
    1b22:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    1b26:	f7ff bba3 	b.w	1270 <chSchReadyI>
    1b2a:	bd38      	pop	{r3, r4, r5, pc}
    1b2c:	00006ac0 	.word	0x00006ac0

00001b30 <chTMObjectInit>:

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
    1b30:	2200      	movs	r2, #0
    1b32:	2300      	movs	r3, #0
    1b34:	e9c0 2304 	strd	r2, r3, [r0, #16]
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
    1b38:	2300      	movs	r3, #0
    1b3a:	f04f 32ff 	mov.w	r2, #4294967295
    1b3e:	e880 000c 	stmia.w	r0, {r2, r3}
  tmp->last       = (rtcnt_t)0;
    1b42:	6083      	str	r3, [r0, #8]
  tmp->n          = (ucnt_t)0;
    1b44:	60c3      	str	r3, [r0, #12]
    1b46:	4770      	bx	lr
    1b48:	f3af 8000 	nop.w
    1b4c:	f3af 8000 	nop.w

00001b50 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
    1b50:	4b01      	ldr	r3, [pc, #4]	; (1b58 <chTMStartMeasurementX+0x8>)
    1b52:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
    1b54:	6083      	str	r3, [r0, #8]
    1b56:	4770      	bx	lr
    1b58:	e0001000 	.word	0xe0001000
    1b5c:	f3af 8000 	nop.w

00001b60 <chTMStopMeasurementX>:
    1b60:	4b0f      	ldr	r3, [pc, #60]	; (1ba0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    1b62:	4910      	ldr	r1, [pc, #64]	; (1ba4 <chTMStopMeasurementX+0x44>)
    1b64:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
    1b66:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
    1b68:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    1b6a:	f8d1 7098 	ldr.w	r7, [r1, #152]	; 0x98
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    1b6e:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
    1b70:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
    1b72:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
    1b76:	1ad3      	subs	r3, r2, r3
    1b78:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
    1b7a:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    1b7c:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
    1b7e:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
    1b80:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
    1b84:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
    1b86:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
    1b8a:	bf88      	it	hi
    1b8c:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
    1b8e:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
    1b90:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
    1b92:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
    1b96:	bf38      	it	cc
    1b98:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
    1b9a:	bcf0      	pop	{r4, r5, r6, r7}
    1b9c:	4770      	bx	lr
    1b9e:	bf00      	nop
    1ba0:	e0001000 	.word	0xe0001000
    1ba4:	1ffff228 	.word	0x1ffff228
    1ba8:	f3af 8000 	nop.w
    1bac:	f3af 8000 	nop.w

00001bb0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    1bb0:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    1bb2:	4c0d      	ldr	r4, [pc, #52]	; (1be8 <_tm_init+0x38>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    1bb4:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    1bb6:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
    1bb8:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
    1bbc:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
    1bbe:	2600      	movs	r6, #0
    1bc0:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    1bc2:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
    1bc6:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
    1bc8:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
    1bca:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
    1bcc:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
    1bce:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
    1bd2:	f7ff ffbd 	bl	1b50 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
    1bd6:	4668      	mov	r0, sp
    1bd8:	f7ff ffc2 	bl	1b60 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
    1bdc:	9b02      	ldr	r3, [sp, #8]
    1bde:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
}
    1be2:	b006      	add	sp, #24
    1be4:	bdd0      	pop	{r4, r6, r7, pc}
    1be6:	bf00      	nop
    1be8:	1ffff228 	.word	0x1ffff228
    1bec:	f3af 8000 	nop.w

00001bf0 <chTMChainMeasurementToX>:
    1bf0:	4b0d      	ldr	r3, [pc, #52]	; (1c28 <chTMChainMeasurementToX+0x38>)
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    1bf2:	6842      	ldr	r2, [r0, #4]
    1bf4:	685b      	ldr	r3, [r3, #4]
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
    1bf6:	b470      	push	{r4, r5, r6}

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
    1bf8:	608b      	str	r3, [r1, #8]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
    1bfa:	6886      	ldr	r6, [r0, #8]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
    1bfc:	68c1      	ldr	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
    1bfe:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
    1c02:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
    1c04:	18e4      	adds	r4, r4, r3
    1c06:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
    1c0a:	4293      	cmp	r3, r2
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    1c0c:	6802      	ldr	r2, [r0, #0]

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
    1c0e:	bf88      	it	hi
    1c10:	6043      	strhi	r3, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
    1c12:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    1c14:	4293      	cmp	r3, r2
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
    1c16:	e9c0 4504 	strd	r4, r5, [r0, #16]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
    1c1a:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
    1c1c:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
    1c1e:	bf38      	it	cc
    1c20:	6003      	strcc	r3, [r0, #0]
  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
}
    1c22:	bc70      	pop	{r4, r5, r6}
    1c24:	4770      	bx	lr
    1c26:	bf00      	nop
    1c28:	e0001000 	.word	0xe0001000
    1c2c:	f3af 8000 	nop.w

00001c30 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
    1c30:	b510      	push	{r4, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1c32:	4c08      	ldr	r4, [pc, #32]	; (1c54 <_stats_init+0x24>)
    1c34:	2300      	movs	r3, #0
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1c36:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
 *
 * @init
 */
void _stats_init(void) {

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1c3a:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
    1c3e:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1c42:	f7ff ff75 	bl	1b30 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1c46:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
}
    1c4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void _stats_init(void) {

  ch.kernel_stats.n_irq = (ucnt_t)0;
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1c4e:	f7ff bf6f 	b.w	1b30 <chTMObjectInit>
    1c52:	bf00      	nop
    1c54:	1ffff228 	.word	0x1ffff228
    1c58:	f3af 8000 	nop.w
    1c5c:	f3af 8000 	nop.w

00001c60 <_stats_increase_irq>:
    1c60:	2320      	movs	r3, #32
    1c62:	f383 8811 	msr	BASEPRI, r3
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  port_lock_from_isr();
  ch.kernel_stats.n_irq++;
    1c66:	4a05      	ldr	r2, [pc, #20]	; (1c7c <_stats_increase_irq+0x1c>)
    1c68:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
    1c6c:	3301      	adds	r3, #1
    1c6e:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
    1c72:	2300      	movs	r3, #0
    1c74:	f383 8811 	msr	BASEPRI, r3
    1c78:	4770      	bx	lr
    1c7a:	bf00      	nop
    1c7c:	1ffff228 	.word	0x1ffff228

00001c80 <_stats_ctxswc>:
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
    1c80:	4a07      	ldr	r2, [pc, #28]	; (1ca0 <_stats_ctxswc+0x20>)
    1c82:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
    1c86:	b410      	push	{r4}

  ch.kernel_stats.n_ctxswc++;
  chTMChainMeasurementToX(&otp->stats, &ntp->stats);
    1c88:	f100 0448 	add.w	r4, r0, #72	; 0x48
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
    1c8c:	3301      	adds	r3, #1
  chTMChainMeasurementToX(&otp->stats, &ntp->stats);
    1c8e:	f101 0048 	add.w	r0, r1, #72	; 0x48
    1c92:	4621      	mov	r1, r4
}
    1c94:	f85d 4b04 	ldr.w	r4, [sp], #4
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
    1c98:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
  chTMChainMeasurementToX(&otp->stats, &ntp->stats);
    1c9c:	f7ff bfa8 	b.w	1bf0 <chTMChainMeasurementToX>
    1ca0:	1ffff228 	.word	0x1ffff228
    1ca4:	f3af 8000 	nop.w
    1ca8:	f3af 8000 	nop.w
    1cac:	f3af 8000 	nop.w

00001cb0 <_stats_start_measure_crit_thd>:
/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
    1cb0:	4801      	ldr	r0, [pc, #4]	; (1cb8 <_stats_start_measure_crit_thd+0x8>)
    1cb2:	f7ff bf4d 	b.w	1b50 <chTMStartMeasurementX>
    1cb6:	bf00      	nop
    1cb8:	1ffff2d0 	.word	0x1ffff2d0
    1cbc:	f3af 8000 	nop.w

00001cc0 <_stats_stop_measure_crit_thd>:
/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
    1cc0:	4801      	ldr	r0, [pc, #4]	; (1cc8 <_stats_stop_measure_crit_thd+0x8>)
    1cc2:	f7ff bf4d 	b.w	1b60 <chTMStopMeasurementX>
    1cc6:	bf00      	nop
    1cc8:	1ffff2d0 	.word	0x1ffff2d0
    1ccc:	f3af 8000 	nop.w

00001cd0 <_stats_start_measure_crit_isr>:
/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
    1cd0:	4801      	ldr	r0, [pc, #4]	; (1cd8 <_stats_start_measure_crit_isr+0x8>)
    1cd2:	f7ff bf3d 	b.w	1b50 <chTMStartMeasurementX>
    1cd6:	bf00      	nop
    1cd8:	1ffff2e8 	.word	0x1ffff2e8
    1cdc:	f3af 8000 	nop.w

00001ce0 <_stats_stop_measure_crit_isr>:
/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
    1ce0:	4801      	ldr	r0, [pc, #4]	; (1ce8 <_stats_stop_measure_crit_isr+0x8>)
    1ce2:	f7ff bf3d 	b.w	1b60 <chTMStopMeasurementX>
    1ce6:	bf00      	nop
    1ce8:	1ffff2e8 	.word	0x1ffff2e8
    1cec:	f3af 8000 	nop.w

00001cf0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
    1cf0:	b538      	push	{r3, r4, r5, lr}
    1cf2:	2320      	movs	r3, #32
    1cf4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
    1cf8:	4c0f      	ldr	r4, [pc, #60]	; (1d38 <chRegFirstThread+0x48>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1cfa:	f7ff ffd9 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1cfe:	f7ff f997 	bl	1030 <_dbg_check_lock>
    1d02:	6925      	ldr	r5, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
    1d04:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
    1d08:	3301      	adds	r3, #1
    1d0a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1d0e:	f7ff f99f 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1d12:	f7ff ffd5 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1d16:	6823      	ldr	r3, [r4, #0]
    1d18:	42a3      	cmp	r3, r4
    1d1a:	d007      	beq.n	1d2c <chRegFirstThread+0x3c>
    1d1c:	69a2      	ldr	r2, [r4, #24]
    1d1e:	689b      	ldr	r3, [r3, #8]
    1d20:	6892      	ldr	r2, [r2, #8]
    1d22:	429a      	cmp	r2, r3
    1d24:	d202      	bcs.n	1d2c <chRegFirstThread+0x3c>
    1d26:	4805      	ldr	r0, [pc, #20]	; (1d3c <chRegFirstThread+0x4c>)
    1d28:	f7ff f92a 	bl	f80 <chSysHalt>
    1d2c:	2300      	movs	r3, #0
    1d2e:	f383 8811 	msr	BASEPRI, r3
#endif
  chSysUnlock();

  return tp;
}
    1d32:	4628      	mov	r0, r5
    1d34:	bd38      	pop	{r3, r4, r5, pc}
    1d36:	bf00      	nop
    1d38:	1ffff228 	.word	0x1ffff228
    1d3c:	00006b80 	.word	0x00006b80

00001d40 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
    1d40:	b570      	push	{r4, r5, r6, lr}
    1d42:	2320      	movs	r3, #32
    1d44:	4606      	mov	r6, r0
    1d46:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1d4a:	f7ff ffb1 	bl	1cb0 <_stats_start_measure_crit_thd>
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
    1d4e:	4d16      	ldr	r5, [pc, #88]	; (1da8 <chRegNextThread+0x68>)
  _dbg_check_lock();
    1d50:	f7ff f96e 	bl	1030 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
    1d54:	6934      	ldr	r4, [r6, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
    1d56:	42ac      	cmp	r4, r5
    1d58:	d024      	beq.n	1da4 <chRegNextThread+0x64>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    1d5a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    1d5e:	2bff      	cmp	r3, #255	; 0xff
    1d60:	d01a      	beq.n	1d98 <chRegNextThread+0x58>
    ntp->refs++;
    1d62:	3301      	adds	r3, #1
    1d64:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1d68:	f7ff f972 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1d6c:	f7ff ffa8 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1d70:	682b      	ldr	r3, [r5, #0]
    1d72:	4a0d      	ldr	r2, [pc, #52]	; (1da8 <chRegNextThread+0x68>)
    1d74:	42ab      	cmp	r3, r5
    1d76:	d007      	beq.n	1d88 <chRegNextThread+0x48>
    1d78:	6992      	ldr	r2, [r2, #24]
    1d7a:	689b      	ldr	r3, [r3, #8]
    1d7c:	6892      	ldr	r2, [r2, #8]
    1d7e:	429a      	cmp	r2, r3
    1d80:	d202      	bcs.n	1d88 <chRegNextThread+0x48>
    1d82:	480a      	ldr	r0, [pc, #40]	; (1dac <chRegNextThread+0x6c>)
    1d84:	f7ff f8fc 	bl	f80 <chSysHalt>
    1d88:	2300      	movs	r3, #0
    1d8a:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
    1d8e:	4630      	mov	r0, r6
    1d90:	f7ff fd46 	bl	1820 <chThdRelease>
#endif

  return ntp;
}
    1d94:	4620      	mov	r0, r4
    1d96:	bd70      	pop	{r4, r5, r6, pc}
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    1d98:	4805      	ldr	r0, [pc, #20]	; (1db0 <chRegNextThread+0x70>)
    1d9a:	f7ff f8f1 	bl	f80 <chSysHalt>
    1d9e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    1da2:	e7de      	b.n	1d62 <chRegNextThread+0x22>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
    1da4:	2400      	movs	r4, #0
    1da6:	e7df      	b.n	1d68 <chRegNextThread+0x28>
    1da8:	1ffff228 	.word	0x1ffff228
    1dac:	00006b80 	.word	0x00006b80
    1db0:	00006b70 	.word	0x00006b70
    1db4:	f3af 8000 	nop.w
    1db8:	f3af 8000 	nop.w
    1dbc:	f3af 8000 	nop.w

00001dc0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
    1dc0:	b510      	push	{r4, lr}
    1dc2:	4604      	mov	r4, r0
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
    1dc4:	f7ff ff94 	bl	1cf0 <chRegFirstThread>
    1dc8:	4603      	mov	r3, r0
    1dca:	e003      	b.n	1dd4 <chRegFindThreadByWorkingArea+0x14>
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
    1dcc:	f7ff ffb8 	bl	1d40 <chRegNextThread>
  } while (ctp != NULL);
    1dd0:	4603      	mov	r3, r0
    1dd2:	b118      	cbz	r0, 1ddc <chRegFindThreadByWorkingArea+0x1c>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
    1dd4:	69da      	ldr	r2, [r3, #28]
    1dd6:	42a2      	cmp	r2, r4
      return ctp;
    }
    ctp = chRegNextThread(ctp);
    1dd8:	4618      	mov	r0, r3
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
    1dda:	d1f7      	bne.n	1dcc <chRegFindThreadByWorkingArea+0xc>
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
    1ddc:	4618      	mov	r0, r3
    1dde:	bd10      	pop	{r4, pc}

00001de0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    1de0:	b510      	push	{r4, lr}

  chDbgCheck(mp != NULL);
    1de2:	4604      	mov	r4, r0
    1de4:	b120      	cbz	r0, 1df0 <chMtxObjectInit+0x10>

  queue_init(&mp->queue);
  mp->owner = NULL;
    1de6:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
    1de8:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
    1dea:	6064      	str	r4, [r4, #4]
    1dec:	60a3      	str	r3, [r4, #8]
    1dee:	bd10      	pop	{r4, pc}
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);
    1df0:	4801      	ldr	r0, [pc, #4]	; (1df8 <chMtxObjectInit+0x18>)
    1df2:	f7ff f8c5 	bl	f80 <chSysHalt>
    1df6:	e7f6      	b.n	1de6 <chMtxObjectInit+0x6>
    1df8:	00006bb0 	.word	0x00006bb0
    1dfc:	f3af 8000 	nop.w

00001e00 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
    1e00:	4b3b      	ldr	r3, [pc, #236]	; (1ef0 <chMtxLockS+0xf0>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
    1e02:	b570      	push	{r4, r5, r6, lr}
    1e04:	4605      	mov	r5, r0
  thread_t *ctp = currp;
    1e06:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
    1e08:	f7ff f9aa 	bl	1160 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
    1e0c:	2d00      	cmp	r5, #0
    1e0e:	d06b      	beq.n	1ee8 <chMtxLockS+0xe8>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
    1e10:	68a8      	ldr	r0, [r5, #8]
    1e12:	2800      	cmp	r0, #0
    1e14:	d036      	beq.n	1e84 <chMtxLockS+0x84>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
    1e16:	68a2      	ldr	r2, [r4, #8]
    1e18:	6883      	ldr	r3, [r0, #8]
    1e1a:	429a      	cmp	r2, r3
    1e1c:	d907      	bls.n	1e2e <chMtxLockS+0x2e>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
    1e1e:	f890 3020 	ldrb.w	r3, [r0, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
    1e22:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
    1e24:	2b06      	cmp	r3, #6
    1e26:	d046      	beq.n	1eb6 <chMtxLockS+0xb6>
    1e28:	2b07      	cmp	r3, #7
    1e2a:	d030      	beq.n	1e8e <chMtxLockS+0x8e>
    1e2c:	b1fb      	cbz	r3, 1e6e <chMtxLockS+0x6e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
    1e2e:	462b      	mov	r3, r5
    1e30:	e003      	b.n	1e3a <chMtxLockS+0x3a>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1e32:	6899      	ldr	r1, [r3, #8]
    1e34:	68a2      	ldr	r2, [r4, #8]
    1e36:	4291      	cmp	r1, r2
    1e38:	d302      	bcc.n	1e40 <chMtxLockS+0x40>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
    1e3a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1e3c:	429d      	cmp	r5, r3
    1e3e:	d1f8      	bne.n	1e32 <chMtxLockS+0x32>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
    1e40:	685a      	ldr	r2, [r3, #4]
    1e42:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
    1e44:	6023      	str	r3, [r4, #0]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
    1e46:	2006      	movs	r0, #6
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
    1e48:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
    1e4a:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
    1e4c:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
    1e4e:	f7ff fa97 	bl	1380 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
    1e52:	68ab      	ldr	r3, [r5, #8]
    1e54:	42a3      	cmp	r3, r4
    1e56:	d002      	beq.n	1e5e <chMtxLockS+0x5e>
    1e58:	4826      	ldr	r0, [pc, #152]	; (1ef4 <chMtxLockS+0xf4>)
    1e5a:	f7ff f891 	bl	f80 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
    1e5e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1e60:	42ab      	cmp	r3, r5
    1e62:	d013      	beq.n	1e8c <chMtxLockS+0x8c>
    1e64:	4823      	ldr	r0, [pc, #140]	; (1ef4 <chMtxLockS+0xf4>)
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
    1e66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
    1e6a:	f7ff b889 	b.w	f80 <chSysHalt>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
    1e6e:	e890 000c 	ldmia.w	r0, {r2, r3}
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
    1e72:	2101      	movs	r1, #1
    1e74:	f880 1020 	strb.w	r1, [r0, #32]
    1e78:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
    1e7a:	6802      	ldr	r2, [r0, #0]
    1e7c:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
    1e7e:	f7ff f9f7 	bl	1270 <chSchReadyI>
          break;
    1e82:	e7d4      	b.n	1e2e <chMtxLockS+0x2e>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    1e84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1e86:	60eb      	str	r3, [r5, #12]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    1e88:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
    1e8a:	63a5      	str	r5, [r4, #56]	; 0x38
    1e8c:	bd70      	pop	{r4, r5, r6, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
    1e8e:	e890 000a 	ldmia.w	r0, {r1, r3}
    1e92:	6019      	str	r1, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
    1e94:	6a46      	ldr	r6, [r0, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
    1e96:	6801      	ldr	r1, [r0, #0]
    1e98:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
    1e9a:	4633      	mov	r3, r6
    1e9c:	e002      	b.n	1ea4 <chMtxLockS+0xa4>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1e9e:	6899      	ldr	r1, [r3, #8]
    1ea0:	4291      	cmp	r1, r2
    1ea2:	d302      	bcc.n	1eaa <chMtxLockS+0xaa>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
    1ea4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1ea6:	429e      	cmp	r6, r3
    1ea8:	d1f9      	bne.n	1e9e <chMtxLockS+0x9e>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
    1eaa:	685a      	ldr	r2, [r3, #4]
    1eac:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
    1eae:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
    1eb0:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
    1eb2:	6058      	str	r0, [r3, #4]
    1eb4:	e7bb      	b.n	1e2e <chMtxLockS+0x2e>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
    1eb6:	e890 000a 	ldmia.w	r0, {r1, r3}
    1eba:	6019      	str	r1, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
    1ebc:	6a46      	ldr	r6, [r0, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
    1ebe:	6801      	ldr	r1, [r0, #0]
    1ec0:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
    1ec2:	4633      	mov	r3, r6
    1ec4:	e002      	b.n	1ecc <chMtxLockS+0xcc>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1ec6:	6899      	ldr	r1, [r3, #8]
    1ec8:	4291      	cmp	r1, r2
    1eca:	d302      	bcc.n	1ed2 <chMtxLockS+0xd2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
    1ecc:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1ece:	429e      	cmp	r6, r3
    1ed0:	d1f9      	bne.n	1ec6 <chMtxLockS+0xc6>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
    1ed2:	685a      	ldr	r2, [r3, #4]
    1ed4:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
    1ed6:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
    1ed8:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
    1eda:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
    1edc:	68b0      	ldr	r0, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
    1ede:	68a2      	ldr	r2, [r4, #8]
    1ee0:	6883      	ldr	r3, [r0, #8]
    1ee2:	4293      	cmp	r3, r2
    1ee4:	d39b      	bcc.n	1e1e <chMtxLockS+0x1e>
    1ee6:	e7a2      	b.n	1e2e <chMtxLockS+0x2e>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
    1ee8:	4802      	ldr	r0, [pc, #8]	; (1ef4 <chMtxLockS+0xf4>)
    1eea:	f7ff f849 	bl	f80 <chSysHalt>
    1eee:	e78f      	b.n	1e10 <chMtxLockS+0x10>
    1ef0:	1ffff228 	.word	0x1ffff228
    1ef4:	00006bc0 	.word	0x00006bc0
    1ef8:	f3af 8000 	nop.w
    1efc:	f3af 8000 	nop.w

00001f00 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
    1f00:	b510      	push	{r4, lr}
    1f02:	2320      	movs	r3, #32
    1f04:	4604      	mov	r4, r0
    1f06:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1f0a:	f7ff fed1 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1f0e:	f7ff f88f 	bl	1030 <_dbg_check_lock>

  chSysLock();
  chMtxLockS(mp);
    1f12:	4620      	mov	r0, r4
    1f14:	f7ff ff74 	bl	1e00 <chMtxLockS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1f18:	f7ff f89a 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1f1c:	f7ff fed0 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1f20:	4b07      	ldr	r3, [pc, #28]	; (1f40 <chMtxLock+0x40>)
    1f22:	681a      	ldr	r2, [r3, #0]
    1f24:	429a      	cmp	r2, r3
    1f26:	d007      	beq.n	1f38 <chMtxLock+0x38>
    1f28:	6999      	ldr	r1, [r3, #24]
    1f2a:	6893      	ldr	r3, [r2, #8]
    1f2c:	688a      	ldr	r2, [r1, #8]
    1f2e:	429a      	cmp	r2, r3
    1f30:	d202      	bcs.n	1f38 <chMtxLock+0x38>
    1f32:	4804      	ldr	r0, [pc, #16]	; (1f44 <chMtxLock+0x44>)
    1f34:	f7ff f824 	bl	f80 <chSysHalt>
    1f38:	2300      	movs	r3, #0
    1f3a:	f383 8811 	msr	BASEPRI, r3
    1f3e:	bd10      	pop	{r4, pc}
    1f40:	1ffff228 	.word	0x1ffff228
    1f44:	00006ba0 	.word	0x00006ba0
    1f48:	f3af 8000 	nop.w
    1f4c:	f3af 8000 	nop.w

00001f50 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    1f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  thread_t *ctp = currp;
    1f54:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 2020 <chMtxUnlock+0xd0>
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
    1f58:	4606      	mov	r6, r0
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
    1f5a:	f8d8 7018 	ldr.w	r7, [r8, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
    1f5e:	2800      	cmp	r0, #0
    1f60:	d052      	beq.n	2008 <chMtxUnlock+0xb8>
    1f62:	2320      	movs	r3, #32
    1f64:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    1f68:	f7ff fea2 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1f6c:	f7ff f860 	bl	1030 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
    1f70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1f72:	2b00      	cmp	r3, #0
    1f74:	d04c      	beq.n	2010 <chMtxUnlock+0xc0>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
    1f76:	689a      	ldr	r2, [r3, #8]
    1f78:	42ba      	cmp	r2, r7
    1f7a:	d003      	beq.n	1f84 <chMtxUnlock+0x34>
    1f7c:	4827      	ldr	r0, [pc, #156]	; (201c <chMtxUnlock+0xcc>)
    1f7e:	f7fe ffff 	bl	f80 <chSysHalt>
    1f82:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
    1f84:	429e      	cmp	r6, r3
    1f86:	d002      	beq.n	1f8e <chMtxUnlock+0x3e>
    1f88:	4824      	ldr	r0, [pc, #144]	; (201c <chMtxUnlock+0xcc>)
    1f8a:	f7fe fff9 	bl	f80 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
    1f8e:	68f3      	ldr	r3, [r6, #12]
    1f90:	63bb      	str	r3, [r7, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
    1f92:	f7ff f8e5 	bl	1160 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
    1f96:	6833      	ldr	r3, [r6, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1f98:	429e      	cmp	r6, r3
    1f9a:	d032      	beq.n	2002 <chMtxUnlock+0xb2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
    1f9c:	6bbc      	ldr	r4, [r7, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
    1f9e:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
    1fa0:	b164      	cbz	r4, 1fbc <chMtxUnlock+0x6c>
    1fa2:	f7ff f8dd 	bl	1160 <chDbgCheckClassS>
    1fa6:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    1fa8:	429c      	cmp	r4, r3
    1faa:	d003      	beq.n	1fb4 <chMtxUnlock+0x64>
            (lmp->queue.next->prio > newprio)) {
    1fac:	689b      	ldr	r3, [r3, #8]
    1fae:	429d      	cmp	r5, r3
    1fb0:	bf38      	it	cc
    1fb2:	461d      	movcc	r5, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
    1fb4:	68e4      	ldr	r4, [r4, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
    1fb6:	2c00      	cmp	r4, #0
    1fb8:	d1f3      	bne.n	1fa2 <chMtxUnlock+0x52>
    1fba:	6833      	ldr	r3, [r6, #0]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
    1fbc:	681a      	ldr	r2, [r3, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
    1fbe:	6b99      	ldr	r1, [r3, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
    1fc0:	60bd      	str	r5, [r7, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1fc2:	4618      	mov	r0, r3
    1fc4:	6032      	str	r2, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
    1fc6:	6056      	str	r6, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
    1fc8:	60b3      	str	r3, [r6, #8]
      mp->next = tp->mtxlist;
    1fca:	60f1      	str	r1, [r6, #12]
      tp->mtxlist = mp;
    1fcc:	639e      	str	r6, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1fce:	f7ff f94f 	bl	1270 <chSchReadyI>
      chSchRescheduleS();
    1fd2:	f7ff fabd 	bl	1550 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    1fd6:	f7ff f83b 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1fda:	f7ff fe71 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1fde:	f8d8 3000 	ldr.w	r3, [r8]
    1fe2:	4a0f      	ldr	r2, [pc, #60]	; (2020 <chMtxUnlock+0xd0>)
    1fe4:	4543      	cmp	r3, r8
    1fe6:	d007      	beq.n	1ff8 <chMtxUnlock+0xa8>
    1fe8:	6992      	ldr	r2, [r2, #24]
    1fea:	689b      	ldr	r3, [r3, #8]
    1fec:	6892      	ldr	r2, [r2, #8]
    1fee:	429a      	cmp	r2, r3
    1ff0:	d202      	bcs.n	1ff8 <chMtxUnlock+0xa8>
    1ff2:	480c      	ldr	r0, [pc, #48]	; (2024 <chMtxUnlock+0xd4>)
    1ff4:	f7fe ffc4 	bl	f80 <chSysHalt>
    1ff8:	2300      	movs	r3, #0
    1ffa:	f383 8811 	msr	BASEPRI, r3
    1ffe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    else {
      mp->owner = NULL;
    2002:	2300      	movs	r3, #0
    2004:	60b3      	str	r3, [r6, #8]
    2006:	e7e6      	b.n	1fd6 <chMtxUnlock+0x86>
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
    2008:	4804      	ldr	r0, [pc, #16]	; (201c <chMtxUnlock+0xcc>)
    200a:	f7fe ffb9 	bl	f80 <chSysHalt>
    200e:	e7a8      	b.n	1f62 <chMtxUnlock+0x12>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
    2010:	4802      	ldr	r0, [pc, #8]	; (201c <chMtxUnlock+0xcc>)
    2012:	f7fe ffb5 	bl	f80 <chSysHalt>
    2016:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    2018:	e7ad      	b.n	1f76 <chMtxUnlock+0x26>
    201a:	bf00      	nop
    201c:	00006b90 	.word	0x00006b90
    2020:	1ffff228 	.word	0x1ffff228
    2024:	00006ba0 	.word	0x00006ba0
    2028:	f3af 8000 	nop.w
    202c:	f3af 8000 	nop.w

00002030 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
    2030:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2034:	460c      	mov	r4, r1
    2036:	4690      	mov	r8, r2
    2038:	461f      	mov	r7, r3

  chDbgCheck((esp != NULL) && (elp != NULL));
    203a:	4606      	mov	r6, r0
    203c:	b330      	cbz	r0, 208c <chEvtRegisterMaskWithFlags+0x5c>
    203e:	b329      	cbz	r1, 208c <chEvtRegisterMaskWithFlags+0x5c>
    2040:	2320      	movs	r3, #32
    2042:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
    2046:	4d13      	ldr	r5, [pc, #76]	; (2094 <chEvtRegisterMaskWithFlags+0x64>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2048:	f7ff fe32 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    204c:	f7fe fff0 	bl	1030 <_dbg_check_lock>
    2050:	69ab      	ldr	r3, [r5, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
    2052:	6832      	ldr	r2, [r6, #0]
    2054:	6022      	str	r2, [r4, #0]
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
    2056:	2100      	movs	r1, #0

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
    2058:	6034      	str	r4, [r6, #0]
  elp->listener = currp;
    205a:	6063      	str	r3, [r4, #4]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
    205c:	60e1      	str	r1, [r4, #12]

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
    205e:	f8c4 8008 	str.w	r8, [r4, #8]
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
    2062:	6127      	str	r7, [r4, #16]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2064:	f7fe fff4 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2068:	f7ff fe2a 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    206c:	682b      	ldr	r3, [r5, #0]
    206e:	42ab      	cmp	r3, r5
    2070:	d007      	beq.n	2082 <chEvtRegisterMaskWithFlags+0x52>
    2072:	69aa      	ldr	r2, [r5, #24]
    2074:	689b      	ldr	r3, [r3, #8]
    2076:	6892      	ldr	r2, [r2, #8]
    2078:	429a      	cmp	r2, r3
    207a:	d202      	bcs.n	2082 <chEvtRegisterMaskWithFlags+0x52>
    207c:	4806      	ldr	r0, [pc, #24]	; (2098 <chEvtRegisterMaskWithFlags+0x68>)
    207e:	f7fe ff7f 	bl	f80 <chSysHalt>
    2082:	2300      	movs	r3, #0
    2084:	f383 8811 	msr	BASEPRI, r3
    2088:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));
    208c:	4803      	ldr	r0, [pc, #12]	; (209c <chEvtRegisterMaskWithFlags+0x6c>)
    208e:	f7fe ff77 	bl	f80 <chSysHalt>
    2092:	e7d5      	b.n	2040 <chEvtRegisterMaskWithFlags+0x10>
    2094:	1ffff228 	.word	0x1ffff228
    2098:	00006bd0 	.word	0x00006bd0
    209c:	00006c00 	.word	0x00006c00

000020a0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
    20a0:	b538      	push	{r3, r4, r5, lr}
    20a2:	460d      	mov	r5, r1
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));
    20a4:	4604      	mov	r4, r0
    20a6:	b330      	cbz	r0, 20f6 <chEvtUnregister+0x56>
    20a8:	b329      	cbz	r1, 20f6 <chEvtUnregister+0x56>
    20aa:	2320      	movs	r3, #32
    20ac:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    20b0:	f7ff fdfe 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    20b4:	f7fe ffbc 	bl	1030 <_dbg_check_lock>
    20b8:	4622      	mov	r2, r4
    20ba:	e002      	b.n	20c2 <chEvtUnregister+0x22>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
    20bc:	429d      	cmp	r5, r3
    20be:	d017      	beq.n	20f0 <chEvtUnregister+0x50>
    20c0:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
    20c2:	6813      	ldr	r3, [r2, #0]
    20c4:	42a3      	cmp	r3, r4
    20c6:	d1f9      	bne.n	20bc <chEvtUnregister+0x1c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    20c8:	f7fe ffc2 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    20cc:	f7ff fdf8 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    20d0:	4b0b      	ldr	r3, [pc, #44]	; (2100 <chEvtUnregister+0x60>)
    20d2:	681a      	ldr	r2, [r3, #0]
    20d4:	429a      	cmp	r2, r3
    20d6:	d007      	beq.n	20e8 <chEvtUnregister+0x48>
    20d8:	6999      	ldr	r1, [r3, #24]
    20da:	6893      	ldr	r3, [r2, #8]
    20dc:	688a      	ldr	r2, [r1, #8]
    20de:	429a      	cmp	r2, r3
    20e0:	d202      	bcs.n	20e8 <chEvtUnregister+0x48>
    20e2:	4808      	ldr	r0, [pc, #32]	; (2104 <chEvtUnregister+0x64>)
    20e4:	f7fe ff4c 	bl	f80 <chSysHalt>
    20e8:	2300      	movs	r3, #0
    20ea:	f383 8811 	msr	BASEPRI, r3
    20ee:	bd38      	pop	{r3, r4, r5, pc}
  /*lint -restore*/
    if (p->next == elp) {
      p->next = elp->next;
    20f0:	682b      	ldr	r3, [r5, #0]
    20f2:	6013      	str	r3, [r2, #0]
      break;
    20f4:	e7e8      	b.n	20c8 <chEvtUnregister+0x28>
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));
    20f6:	4804      	ldr	r0, [pc, #16]	; (2108 <chEvtUnregister+0x68>)
    20f8:	f7fe ff42 	bl	f80 <chSysHalt>
    20fc:	e7d5      	b.n	20aa <chEvtUnregister+0xa>
    20fe:	bf00      	nop
    2100:	1ffff228 	.word	0x1ffff228
    2104:	00006bd0 	.word	0x00006bd0
    2108:	00006c20 	.word	0x00006c20
    210c:	f3af 8000 	nop.w

00002110 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    2110:	b538      	push	{r3, r4, r5, lr}
    2112:	4604      	mov	r4, r0
    2114:	460d      	mov	r5, r1

  chDbgCheckClassI();
    2116:	f7ff f813 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    211a:	b1cc      	cbz	r4, 2150 <chEvtSignalI+0x40>

  tp->epending |= events;
    211c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
    211e:	f894 2020 	ldrb.w	r2, [r4, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
    2122:	ea45 0103 	orr.w	r1, r5, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
    2126:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
    2128:	6361      	str	r1, [r4, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
    212a:	d00d      	beq.n	2148 <chEvtSignalI+0x38>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
    212c:	2a0b      	cmp	r2, #11
    212e:	d000      	beq.n	2132 <chEvtSignalI+0x22>
    2130:	bd38      	pop	{r3, r4, r5, pc}
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    2132:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2134:	4019      	ands	r1, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
    2136:	428b      	cmp	r3, r1
    2138:	d1fa      	bne.n	2130 <chEvtSignalI+0x20>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    213a:	2300      	movs	r3, #0
    213c:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
    213e:	4620      	mov	r0, r4
  }
}
    2140:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
    2144:	f7ff b894 	b.w	1270 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
    2148:	6a63      	ldr	r3, [r4, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
    214a:	4219      	tst	r1, r3
    214c:	d1f5      	bne.n	213a <chEvtSignalI+0x2a>
    214e:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    2150:	4801      	ldr	r0, [pc, #4]	; (2158 <chEvtSignalI+0x48>)
    2152:	f7fe ff15 	bl	f80 <chSysHalt>
    2156:	e7e1      	b.n	211c <chEvtSignalI+0xc>
    2158:	00006be0 	.word	0x00006be0
    215c:	f3af 8000 	nop.w

00002160 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    2160:	b570      	push	{r4, r5, r6, lr}
    2162:	4606      	mov	r6, r0
    2164:	460d      	mov	r5, r1
  event_listener_t *elp;

  chDbgCheckClassI();
    2166:	f7fe ffeb 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
    216a:	b18e      	cbz	r6, 2190 <chEvtBroadcastFlagsI+0x30>

  elp = esp->next;
    216c:	6834      	ldr	r4, [r6, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    216e:	42a6      	cmp	r6, r4
    2170:	d00d      	beq.n	218e <chEvtBroadcastFlagsI+0x2e>
  /*lint -restore*/
    elp->flags |= flags;
    2172:	68e3      	ldr	r3, [r4, #12]
    2174:	432b      	orrs	r3, r5
    2176:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    2178:	b115      	cbz	r5, 2180 <chEvtBroadcastFlagsI+0x20>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
    217a:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    217c:	4213      	tst	r3, r2
    217e:	d003      	beq.n	2188 <chEvtBroadcastFlagsI+0x28>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    2180:	6860      	ldr	r0, [r4, #4]
    2182:	68a1      	ldr	r1, [r4, #8]
    2184:	f7ff ffc4 	bl	2110 <chEvtSignalI>
    }
    elp = elp->next;
    2188:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    218a:	42a6      	cmp	r6, r4
    218c:	d1f1      	bne.n	2172 <chEvtBroadcastFlagsI+0x12>
    218e:	bd70      	pop	{r4, r5, r6, pc}
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);
    2190:	4801      	ldr	r0, [pc, #4]	; (2198 <chEvtBroadcastFlagsI+0x38>)
    2192:	f7fe fef5 	bl	f80 <chSysHalt>
    2196:	e7e9      	b.n	216c <chEvtBroadcastFlagsI+0xc>
    2198:	00006c30 	.word	0x00006c30
    219c:	f3af 8000 	nop.w

000021a0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
    21a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    21a4:	460e      	mov	r6, r1
  eventid_t eid;

  chDbgCheck(handlers != NULL);
    21a6:	4605      	mov	r5, r0
    21a8:	b1e8      	cbz	r0, 21e6 <chEvtDispatch+0x46>

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    21aa:	b1ae      	cbz	r6, 21d8 <chEvtDispatch+0x38>
    21ac:	2400      	movs	r4, #0
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
    21ae:	f04f 0801 	mov.w	r8, #1
    21b2:	fa08 f704 	lsl.w	r7, r8, r4
    21b6:	4237      	tst	r7, r6
    21b8:	d00b      	beq.n	21d2 <chEvtDispatch+0x32>
      chDbgAssert(handlers[eid] != NULL, "null handler");
    21ba:	682b      	ldr	r3, [r5, #0]
    21bc:	b173      	cbz	r3, 21dc <chEvtDispatch+0x3c>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    21be:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
    21c0:	ea26 0607 	bic.w	r6, r6, r7
    21c4:	3504      	adds	r5, #4
      handlers[eid](eid);
    21c6:	4798      	blx	r3
    }
    eid++;
    21c8:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    21ca:	2e00      	cmp	r6, #0
    21cc:	d1f1      	bne.n	21b2 <chEvtDispatch+0x12>
    21ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
    21d2:	3401      	adds	r4, #1
    21d4:	3504      	adds	r5, #4
    21d6:	e7ec      	b.n	21b2 <chEvtDispatch+0x12>
    21d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
    21dc:	4804      	ldr	r0, [pc, #16]	; (21f0 <chEvtDispatch+0x50>)
    21de:	f7fe fecf 	bl	f80 <chSysHalt>
    21e2:	682b      	ldr	r3, [r5, #0]
    21e4:	e7eb      	b.n	21be <chEvtDispatch+0x1e>
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  eventid_t eid;

  chDbgCheck(handlers != NULL);
    21e6:	4802      	ldr	r0, [pc, #8]	; (21f0 <chEvtDispatch+0x50>)
    21e8:	f7fe feca 	bl	f80 <chSysHalt>
    21ec:	e7dd      	b.n	21aa <chEvtDispatch+0xa>
    21ee:	bf00      	nop
    21f0:	00006bf0 	.word	0x00006bf0
    21f4:	f3af 8000 	nop.w
    21f8:	f3af 8000 	nop.w
    21fc:	f3af 8000 	nop.w

00002200 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
    2200:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
    2202:	4d17      	ldr	r5, [pc, #92]	; (2260 <chEvtWaitOne+0x60>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
    2204:	4604      	mov	r4, r0
  thread_t *ctp = currp;
    2206:	69ae      	ldr	r6, [r5, #24]
    2208:	2320      	movs	r3, #32
    220a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    220e:	f7ff fd4f 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2212:	f7fe ff0d 	bl	1030 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
    2216:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
    2218:	ea14 0203 	ands.w	r2, r4, r3
    221c:	d106      	bne.n	222c <chEvtWaitOne+0x2c>
    ctp->u.ewmask = events;
    221e:	6274      	str	r4, [r6, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
    2220:	200a      	movs	r0, #10
    2222:	f7ff f8ad 	bl	1380 <chSchGoSleepS>
    m = ctp->epending & events;
    2226:	6b73      	ldr	r3, [r6, #52]	; 0x34
    2228:	ea04 0203 	and.w	r2, r4, r3
  }
  m ^= m & (m - (eventmask_t)1);
    222c:	4254      	negs	r4, r2
    222e:	4014      	ands	r4, r2
  ctp->epending &= ~m;
    2230:	ea23 0304 	bic.w	r3, r3, r4
    2234:	6373      	str	r3, [r6, #52]	; 0x34
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2236:	f7fe ff0b 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    223a:	f7ff fd41 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    223e:	682b      	ldr	r3, [r5, #0]
    2240:	4a07      	ldr	r2, [pc, #28]	; (2260 <chEvtWaitOne+0x60>)
    2242:	42ab      	cmp	r3, r5
    2244:	d007      	beq.n	2256 <chEvtWaitOne+0x56>
    2246:	6992      	ldr	r2, [r2, #24]
    2248:	689b      	ldr	r3, [r3, #8]
    224a:	6892      	ldr	r2, [r2, #8]
    224c:	429a      	cmp	r2, r3
    224e:	d202      	bcs.n	2256 <chEvtWaitOne+0x56>
    2250:	4804      	ldr	r0, [pc, #16]	; (2264 <chEvtWaitOne+0x64>)
    2252:	f7fe fe95 	bl	f80 <chSysHalt>
    2256:	2300      	movs	r3, #0
    2258:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
    225c:	4620      	mov	r0, r4
    225e:	bd70      	pop	{r4, r5, r6, pc}
    2260:	1ffff228 	.word	0x1ffff228
    2264:	00006bd0 	.word	0x00006bd0
    2268:	f3af 8000 	nop.w
    226c:	f3af 8000 	nop.w

00002270 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
    2270:	b5f0      	push	{r4, r5, r6, r7, lr}
    2272:	4617      	mov	r7, r2
    2274:	b087      	sub	sp, #28
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
    2276:	2208      	movs	r2, #8
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
    2278:	461e      	mov	r6, r3
    227a:	460d      	mov	r5, r1
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
    227c:	f000 f8c0 	bl	2400 <chHeapAllocAligned>
  if (wsp == NULL) {
    2280:	b388      	cbz	r0, 22e6 <chThdCreateFromHeap+0x76>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
    2282:	4405      	add	r5, r0
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
    2284:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    2286:	9304      	str	r3, [sp, #16]
    pf,
    arg
  };

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    2288:	4629      	mov	r1, r5
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
    228a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    228c:	9305      	str	r3, [sp, #20]
    pf,
    arg
  };

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    228e:	2255      	movs	r2, #85	; 0x55
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
    2290:	9502      	str	r5, [sp, #8]
    2292:	9700      	str	r7, [sp, #0]
    2294:	9001      	str	r0, [sp, #4]
    2296:	9603      	str	r6, [sp, #12]
    pf,
    arg
  };

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    2298:	f7ff f9d2 	bl	1640 <_thread_memfill>
    229c:	2320      	movs	r3, #32
    229e:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    22a2:	f7ff fd05 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    22a6:	f7fe fec3 	bl	1030 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
    22aa:	4668      	mov	r0, sp
    22ac:	f7ff f9d0 	bl	1650 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
    22b0:	2301      	movs	r3, #1
    22b2:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
    22b6:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
    22b8:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
    22ba:	f7ff f8c1 	bl	1440 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    22be:	f7fe fec7 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    22c2:	f7ff fcfd 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    22c6:	4b09      	ldr	r3, [pc, #36]	; (22ec <chThdCreateFromHeap+0x7c>)
    22c8:	681a      	ldr	r2, [r3, #0]
    22ca:	429a      	cmp	r2, r3
    22cc:	d007      	beq.n	22de <chThdCreateFromHeap+0x6e>
    22ce:	6999      	ldr	r1, [r3, #24]
    22d0:	6893      	ldr	r3, [r2, #8]
    22d2:	688a      	ldr	r2, [r1, #8]
    22d4:	429a      	cmp	r2, r3
    22d6:	d202      	bcs.n	22de <chThdCreateFromHeap+0x6e>
    22d8:	4805      	ldr	r0, [pc, #20]	; (22f0 <chThdCreateFromHeap+0x80>)
    22da:	f7fe fe51 	bl	f80 <chSysHalt>
    22de:	2300      	movs	r3, #0
    22e0:	f383 8811 	msr	BASEPRI, r3
    22e4:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
    22e6:	b007      	add	sp, #28
    22e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    22ea:	bf00      	nop
    22ec:	1ffff228 	.word	0x1ffff228
    22f0:	00006c50 	.word	0x00006c50
    22f4:	f3af 8000 	nop.w
    22f8:	f3af 8000 	nop.w
    22fc:	f3af 8000 	nop.w

00002300 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
    2300:	4903      	ldr	r1, [pc, #12]	; (2310 <_core_init+0x10>)
  endmem  = __heap_end__;
    2302:	4b04      	ldr	r3, [pc, #16]	; (2314 <_core_init+0x14>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
    2304:	4804      	ldr	r0, [pc, #16]	; (2318 <_core_init+0x18>)
  endmem  = __heap_end__;
    2306:	4a05      	ldr	r2, [pc, #20]	; (231c <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
    2308:	6008      	str	r0, [r1, #0]
  endmem  = __heap_end__;
    230a:	601a      	str	r2, [r3, #0]
    230c:	4770      	bx	lr
    230e:	bf00      	nop
    2310:	1ffff304 	.word	0x1ffff304
    2314:	1ffff300 	.word	0x1ffff300
    2318:	20000588 	.word	0x20000588
    231c:	20004000 	.word	0x20004000

00002320 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    2320:	b570      	push	{r4, r5, r6, lr}
    2322:	460c      	mov	r4, r1
    2324:	4605      	mov	r5, r0
  uint8_t *p;

  chDbgCheckClassI();
    2326:	f7fe ff0b 	bl	1140 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    232a:	b114      	cbz	r4, 2332 <chCoreAllocAlignedI+0x12>
    232c:	1e63      	subs	r3, r4, #1
    232e:	4223      	tst	r3, r4
    2330:	d002      	beq.n	2338 <chCoreAllocAlignedI+0x18>
    2332:	480a      	ldr	r0, [pc, #40]	; (235c <chCoreAllocAlignedI+0x3c>)
    2334:	f7fe fe24 	bl	f80 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    2338:	4e09      	ldr	r6, [pc, #36]	; (2360 <chCoreAllocAlignedI+0x40>)

  if (((size_t)endmem - (size_t)p) < size) {
    233a:	4a0a      	ldr	r2, [pc, #40]	; (2364 <chCoreAllocAlignedI+0x44>)
    233c:	6833      	ldr	r3, [r6, #0]
    233e:	6812      	ldr	r2, [r2, #0]
    2340:	3b01      	subs	r3, #1
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    2342:	4261      	negs	r1, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    2344:	1918      	adds	r0, r3, r4
    2346:	3d01      	subs	r5, #1
    2348:	4008      	ands	r0, r1
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    234a:	442c      	add	r4, r5
    234c:	400c      	ands	r4, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    234e:	1a13      	subs	r3, r2, r0
    2350:	429c      	cmp	r4, r3
    return NULL;
  }
  nextmem = p + size;
    2352:	bf9a      	itte	ls
    2354:	1824      	addls	r4, r4, r0
    2356:	6034      	strls	r4, [r6, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
    2358:	2000      	movhi	r0, #0
  }
  nextmem = p + size;

  return p;
}
    235a:	bd70      	pop	{r4, r5, r6, pc}
    235c:	00006c70 	.word	0x00006c70
    2360:	1ffff304 	.word	0x1ffff304
    2364:	1ffff300 	.word	0x1ffff300
    2368:	f3af 8000 	nop.w
    236c:	f3af 8000 	nop.w

00002370 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    2370:	b538      	push	{r3, r4, r5, lr}
    2372:	4605      	mov	r5, r0
    2374:	460c      	mov	r4, r1
    2376:	2320      	movs	r3, #32
    2378:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    237c:	f7ff fc98 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2380:	f7fe fe56 	bl	1030 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocAlignedI(size, align);
    2384:	4621      	mov	r1, r4
    2386:	4628      	mov	r0, r5
    2388:	f7ff ffca 	bl	2320 <chCoreAllocAlignedI>
    238c:	4604      	mov	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    238e:	f7fe fe5f 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2392:	f7ff fc95 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2396:	4b08      	ldr	r3, [pc, #32]	; (23b8 <chCoreAllocAligned+0x48>)
    2398:	681a      	ldr	r2, [r3, #0]
    239a:	429a      	cmp	r2, r3
    239c:	d007      	beq.n	23ae <chCoreAllocAligned+0x3e>
    239e:	6999      	ldr	r1, [r3, #24]
    23a0:	6893      	ldr	r3, [r2, #8]
    23a2:	688a      	ldr	r2, [r1, #8]
    23a4:	429a      	cmp	r2, r3
    23a6:	d202      	bcs.n	23ae <chCoreAllocAligned+0x3e>
    23a8:	4804      	ldr	r0, [pc, #16]	; (23bc <chCoreAllocAligned+0x4c>)
    23aa:	f7fe fde9 	bl	f80 <chSysHalt>
    23ae:	2300      	movs	r3, #0
    23b0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
    23b4:	4620      	mov	r0, r4
    23b6:	bd38      	pop	{r3, r4, r5, pc}
    23b8:	1ffff228 	.word	0x1ffff228
    23bc:	00006c60 	.word	0x00006c60

000023c0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
    23c0:	4a02      	ldr	r2, [pc, #8]	; (23cc <chCoreGetStatusX+0xc>)
    23c2:	4b03      	ldr	r3, [pc, #12]	; (23d0 <chCoreGetStatusX+0x10>)
    23c4:	6810      	ldr	r0, [r2, #0]
    23c6:	681b      	ldr	r3, [r3, #0]
  /*lint -restore*/
}
    23c8:	1ac0      	subs	r0, r0, r3
    23ca:	4770      	bx	lr
    23cc:	1ffff300 	.word	0x1ffff300
    23d0:	1ffff304 	.word	0x1ffff304
    23d4:	f3af 8000 	nop.w
    23d8:	f3af 8000 	nop.w
    23dc:	f3af 8000 	nop.w

000023e0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    23e0:	4b04      	ldr	r3, [pc, #16]	; (23f4 <_heap_init+0x14>)
    23e2:	4a05      	ldr	r2, [pc, #20]	; (23f8 <_heap_init+0x18>)
    23e4:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    23e6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
  H_NEXT(&default_heap.header) = NULL;
    23ea:	2200      	movs	r2, #0
    23ec:	609a      	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
    23ee:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    23f0:	f7ff bcf6 	b.w	1de0 <chMtxObjectInit>
    23f4:	1ffff308 	.word	0x1ffff308
    23f8:	00002371 	.word	0x00002371
    23fc:	f3af 8000 	nop.w

00002400 <chHeapAllocAligned>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
    2400:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2404:	4681      	mov	r9, r0
    2406:	4690      	mov	r8, r2
  heap_header_t *qp, *hp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
    2408:	460f      	mov	r7, r1
    240a:	b109      	cbz	r1, 2410 <chHeapAllocAligned+0x10>
    240c:	2a00      	cmp	r2, #0
    240e:	d145      	bne.n	249c <chHeapAllocAligned+0x9c>
    2410:	4840      	ldr	r0, [pc, #256]	; (2514 <chHeapAllocAligned+0x114>)
    2412:	f7fe fdb5 	bl	f80 <chSysHalt>

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
    2416:	4b40      	ldr	r3, [pc, #256]	; (2518 <chHeapAllocAligned+0x118>)
    2418:	f1b9 0f00 	cmp.w	r9, #0
    241c:	bf08      	it	eq
    241e:	4699      	moveq	r9, r3

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
    2420:	f109 0b10 	add.w	fp, r9, #16
    heapp = &default_heap;
  }

  /* Minimum alignment is constrained by the heap header structure size.*/
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
    2424:	f1b8 0f07 	cmp.w	r8, #7
    2428:	bf98      	it	ls
    242a:	f04f 0808 	movls.w	r8, #8

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
    242e:	4658      	mov	r0, fp
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
    2430:	f107 0a07 	add.w	sl, r7, #7

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
    2434:	f7ff fd64 	bl	1f00 <chMtxLock>
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
    2438:	ea4f 0ada 	mov.w	sl, sl, lsr #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
    243c:	f109 0208 	add.w	r2, r9, #8

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
    2440:	f1c8 0100 	rsb	r1, r8, #0
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    2444:	6814      	ldr	r4, [r2, #0]
    2446:	1de3      	adds	r3, r4, #7

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
    2448:	4443      	add	r3, r8
    244a:	400b      	ands	r3, r1
    244c:	3b08      	subs	r3, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
    244e:	1ae6      	subs	r6, r4, r3

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
    2450:	f104 0c08 	add.w	ip, r4, #8
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    2454:	b174      	cbz	r4, 2474 <chHeapAllocAligned+0x74>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
    2456:	6860      	ldr	r0, [r4, #4]
    2458:	1c45      	adds	r5, r0, #1
    245a:	00ed      	lsls	r5, r5, #3
    245c:	f1a5 0e08 	sub.w	lr, r5, #8
    2460:	4425      	add	r5, r4
    2462:	4476      	add	r6, lr
    2464:	42ab      	cmp	r3, r5
    2466:	ea4f 06e6 	mov.w	r6, r6, asr #3
    246a:	d201      	bcs.n	2470 <chHeapAllocAligned+0x70>
    246c:	45b2      	cmp	sl, r6
    246e:	d919      	bls.n	24a4 <chHeapAllocAligned+0xa4>
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    2470:	4622      	mov	r2, r4
    2472:	e7e7      	b.n	2444 <chHeapAllocAligned+0x44>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
    2474:	4658      	mov	r0, fp
    2476:	f7ff fd6b 	bl	1f50 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
    247a:	f8d9 3000 	ldr.w	r3, [r9]
    247e:	2b00      	cmp	r3, #0
    2480:	d045      	beq.n	250e <chHeapAllocAligned+0x10e>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
    2482:	f10a 0001 	add.w	r0, sl, #1
    2486:	00c0      	lsls	r0, r0, #3
    2488:	4641      	mov	r1, r8
    248a:	4798      	blx	r3
    if (hp != NULL) {
    248c:	2800      	cmp	r0, #0
    248e:	d03e      	beq.n	250e <chHeapAllocAligned+0x10e>
      H_HEAP(hp) = heapp;
    2490:	f8c0 9000 	str.w	r9, [r0]
      H_SIZE(hp) = size;
    2494:	6047      	str	r7, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
    2496:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
    2498:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  heap_header_t *qp, *hp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
    249c:	1e53      	subs	r3, r2, #1
    249e:	4213      	tst	r3, r2
    24a0:	d0b9      	beq.n	2416 <chHeapAllocAligned+0x16>
    24a2:	e7b5      	b.n	2410 <chHeapAllocAligned+0x10>

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
    24a4:	42a3      	cmp	r3, r4
    24a6:	4619      	mov	r1, r3

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
    24a8:	4665      	mov	r5, ip

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
    24aa:	d914      	bls.n	24d6 <chHeapAllocAligned+0xd6>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
    24ac:	ebcc 0203 	rsb	r2, ip, r3
    24b0:	10d2      	asrs	r2, r2, #3
        if (bpages > pages) {
    24b2:	45b2      	cmp	sl, r6
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
    24b4:	6062      	str	r2, [r4, #4]
        if (bpages > pages) {
    24b6:	d20b      	bcs.n	24d0 <chHeapAllocAligned+0xd0>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
    24b8:	f10a 0001 	add.w	r0, sl, #1
    24bc:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
    24c0:	ea6f 0a0a 	mvn.w	sl, sl
          H_PAGES(fp) = (bpages - pages) - 1U;

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
    24c4:	6825      	ldr	r5, [r4, #0]
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
          H_PAGES(fp) = (bpages - pages) - 1U;
    24c6:	4456      	add	r6, sl
    24c8:	6056      	str	r6, [r2, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
    24ca:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
          H_NEXT(hp) = fp;
    24ce:	6022      	str	r2, [r4, #0]
    24d0:	f103 0508 	add.w	r5, r3, #8
    24d4:	e00e      	b.n	24f4 <chHeapAllocAligned+0xf4>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
    24d6:	4582      	cmp	sl, r0
    24d8:	d015      	beq.n	2506 <chHeapAllocAligned+0x106>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
    24da:	f10a 0a01 	add.w	sl, sl, #1
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
    24de:	eb04 00ca 	add.w	r0, r4, sl, lsl #3
    24e2:	ebae 03ca 	sub.w	r3, lr, sl, lsl #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
    24e6:	6821      	ldr	r1, [r4, #0]
    24e8:	f844 103a 	str.w	r1, [r4, sl, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
    24ec:	10db      	asrs	r3, r3, #3
    24ee:	6043      	str	r3, [r0, #4]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    24f0:	4621      	mov	r1, r4
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
    24f2:	6010      	str	r0, [r2, #0]
      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
    24f4:	4658      	mov	r0, fp
          H_NEXT(qp) = fp;
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
    24f6:	604f      	str	r7, [r1, #4]
      H_HEAP(hp) = heapp;
    24f8:	f8c1 9000 	str.w	r9, [r1]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
    24fc:	f7ff fd28 	bl	1f50 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
    2500:	4628      	mov	r0, r5
    2502:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
    2506:	6823      	ldr	r3, [r4, #0]
    2508:	6013      	str	r3, [r2, #0]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    250a:	4621      	mov	r1, r4
    250c:	e7f2      	b.n	24f4 <chHeapAllocAligned+0xf4>
      return (void *)H_BLOCK(hp);
      /*lint -restore*/
    }
  }

  return NULL;
    250e:	2000      	movs	r0, #0
    2510:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2514:	00006ca0 	.word	0x00006ca0
    2518:	1ffff308 	.word	0x1ffff308
    251c:	f3af 8000 	nop.w

00002520 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2520:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
    2524:	4680      	mov	r8, r0
    2526:	b398      	cbz	r0, 2590 <chHeapFree+0x70>
    2528:	f010 0f07 	tst.w	r0, #7
    252c:	d130      	bne.n	2590 <chHeapFree+0x70>
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
    252e:	f858 3c04 	ldr.w	r3, [r8, #-4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
    2532:	f858 6c08 	ldr.w	r6, [r8, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
    2536:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
    2538:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
    253a:	f106 0710 	add.w	r7, r6, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
    253e:	f848 3c04 	str.w	r3, [r8, #-4]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
    2542:	4638      	mov	r0, r7
    2544:	f7ff fcdc 	bl	1f00 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
    2548:	3608      	adds	r6, #8
    254a:	4634      	mov	r4, r6
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
    254c:	f1a8 0508 	sub.w	r5, r8, #8

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
    2550:	42ac      	cmp	r4, r5
    2552:	d805      	bhi.n	2560 <chHeapFree+0x40>
    2554:	6863      	ldr	r3, [r4, #4]
    2556:	3301      	adds	r3, #1
    2558:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    255c:	429d      	cmp	r5, r3
    255e:	d30c      	bcc.n	257a <chHeapFree+0x5a>

    if (((qp == &heapp->header) || (hp > qp)) &&
    2560:	42b4      	cmp	r4, r6
    2562:	d00f      	beq.n	2584 <chHeapFree+0x64>
    2564:	42ac      	cmp	r4, r5
    2566:	d30d      	bcc.n	2584 <chHeapFree+0x64>
    2568:	6824      	ldr	r4, [r4, #0]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
    256a:	42ac      	cmp	r4, r5
    256c:	d8f8      	bhi.n	2560 <chHeapFree+0x40>
    256e:	6863      	ldr	r3, [r4, #4]
    2570:	3301      	adds	r3, #1
    2572:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    2576:	429d      	cmp	r5, r3
    2578:	d2f2      	bcs.n	2560 <chHeapFree+0x40>
    257a:	4820      	ldr	r0, [pc, #128]	; (25fc <chHeapFree+0xdc>)
    257c:	f7fe fd00 	bl	f80 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
    2580:	42b4      	cmp	r4, r6
    2582:	d1ef      	bne.n	2564 <chHeapFree+0x44>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
    2584:	6823      	ldr	r3, [r4, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
    2586:	b13b      	cbz	r3, 2598 <chHeapFree+0x78>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
    2588:	429d      	cmp	r5, r3
    258a:	d305      	bcc.n	2598 <chHeapFree+0x78>
    258c:	461c      	mov	r4, r3
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
  }
    258e:	e7df      	b.n	2550 <chHeapFree+0x30>
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
    2590:	481a      	ldr	r0, [pc, #104]	; (25fc <chHeapFree+0xdc>)
    2592:	f7fe fcf5 	bl	f80 <chSysHalt>
    2596:	e7ca      	b.n	252e <chHeapFree+0xe>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
    2598:	f858 2c04 	ldr.w	r2, [r8, #-4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
    259c:	f848 3c08 	str.w	r3, [r8, #-8]
      H_NEXT(qp) = hp;
    25a0:	6025      	str	r5, [r4, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
    25a2:	1c53      	adds	r3, r2, #1
    25a4:	f858 0c08 	ldr.w	r0, [r8, #-8]
    25a8:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
    25ac:	4281      	cmp	r1, r0
    25ae:	d00a      	beq.n	25c6 <chHeapFree+0xa6>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
    25b0:	6862      	ldr	r2, [r4, #4]
    25b2:	1c53      	adds	r3, r2, #1
    25b4:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    25b8:	429d      	cmp	r5, r3
    25ba:	d013      	beq.n	25e4 <chHeapFree+0xc4>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
    25bc:	4638      	mov	r0, r7

  return;
}
    25be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
    25c2:	f7ff bcc5 	b.w	1f50 <chMtxUnlock>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
    25c6:	6849      	ldr	r1, [r1, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
    25c8:	f855 3033 	ldr.w	r3, [r5, r3, lsl #3]
    25cc:	f848 3c08 	str.w	r3, [r8, #-8]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
    25d0:	1853      	adds	r3, r2, r1
    25d2:	3301      	adds	r3, #1
    25d4:	f848 3c04 	str.w	r3, [r8, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
    25d8:	6862      	ldr	r2, [r4, #4]
    25da:	1c53      	adds	r3, r2, #1
    25dc:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    25e0:	429d      	cmp	r5, r3
    25e2:	d1eb      	bne.n	25bc <chHeapFree+0x9c>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
    25e4:	e918 000a 	ldmdb	r8, {r1, r3}
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
    25e8:	4413      	add	r3, r2
    25ea:	3301      	adds	r3, #1
        H_NEXT(qp) = H_NEXT(hp);
    25ec:	6021      	str	r1, [r4, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
    25ee:	6063      	str	r3, [r4, #4]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
    25f0:	4638      	mov	r0, r7

  return;
}
    25f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
    25f6:	f7ff bcab 	b.w	1f50 <chMtxUnlock>
    25fa:	bf00      	nop
    25fc:	00006c90 	.word	0x00006c90

00002600 <chHeapStatus>:
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
    2600:	4b17      	ldr	r3, [pc, #92]	; (2660 <chHeapStatus+0x60>)
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
    2602:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
    2606:	2800      	cmp	r0, #0
    2608:	bf14      	ite	ne
    260a:	4604      	movne	r4, r0
    260c:	461c      	moveq	r4, r3
  }

  H_LOCK(heapp);
    260e:	f104 0810 	add.w	r8, r4, #16
  tpages = 0U;
  lpages = 0U;
    2612:	2500      	movs	r5, #0

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
    2614:	4640      	mov	r0, r8
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
    2616:	468a      	mov	sl, r1
    2618:	4691      	mov	r9, r2
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
    261a:	462e      	mov	r6, r5

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
    261c:	f7ff fc70 	bl	1f00 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
    2620:	462f      	mov	r7, r5
  qp = &heapp->header;
    2622:	f104 0308 	add.w	r3, r4, #8
  while (H_NEXT(qp) != NULL) {
    2626:	e006      	b.n	2636 <chHeapStatus+0x36>
    size_t pages = H_PAGES(H_NEXT(qp));
    2628:	685c      	ldr	r4, [r3, #4]
    262a:	42a5      	cmp	r5, r4

    /* Updating counters.*/
    n++;
    262c:	f107 0701 	add.w	r7, r7, #1
    tpages += pages;
    2630:	4426      	add	r6, r4
    2632:	bf38      	it	cc
    2634:	4625      	movcc	r5, r4
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    2636:	681b      	ldr	r3, [r3, #0]
    2638:	2b00      	cmp	r3, #0
    263a:	d1f5      	bne.n	2628 <chHeapStatus+0x28>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
    263c:	f1ba 0f00 	cmp.w	sl, #0
    2640:	d002      	beq.n	2648 <chHeapStatus+0x48>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
    2642:	00f6      	lsls	r6, r6, #3
    2644:	f8ca 6000 	str.w	r6, [sl]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
    2648:	f1b9 0f00 	cmp.w	r9, #0
    264c:	d002      	beq.n	2654 <chHeapStatus+0x54>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
    264e:	00ed      	lsls	r5, r5, #3
    2650:	f8c9 5000 	str.w	r5, [r9]
  }
  H_UNLOCK(heapp);
    2654:	4640      	mov	r0, r8
    2656:	f7ff fc7b 	bl	1f50 <chMtxUnlock>

  return n;
}
    265a:	4638      	mov	r0, r7
    265c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2660:	1ffff308 	.word	0x1ffff308
    2664:	f3af 8000 	nop.w
    2668:	f3af 8000 	nop.w
    266c:	f3af 8000 	nop.w

00002670 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    2670:	b538      	push	{r3, r4, r5, lr}
    2672:	4604      	mov	r4, r0
    2674:	460d      	mov	r5, r1
  struct pool_header *php = objp;

  chDbgCheckClassI();
    2676:	f7fe fd63 	bl	1140 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
    267a:	b124      	cbz	r4, 2686 <chPoolFreeI+0x16>
    267c:	b11d      	cbz	r5, 2686 <chPoolFreeI+0x16>

  php->next = mp->next;
    267e:	6823      	ldr	r3, [r4, #0]
    2680:	602b      	str	r3, [r5, #0]
  mp->next = php;
    2682:	6025      	str	r5, [r4, #0]
    2684:	bd38      	pop	{r3, r4, r5, pc}
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
    2686:	4803      	ldr	r0, [pc, #12]	; (2694 <chPoolFreeI+0x24>)
    2688:	f7fe fc7a 	bl	f80 <chSysHalt>

  php->next = mp->next;
    268c:	6823      	ldr	r3, [r4, #0]
    268e:	602b      	str	r3, [r5, #0]
  mp->next = php;
    2690:	6025      	str	r5, [r4, #0]
    2692:	bd38      	pop	{r3, r4, r5, pc}
    2694:	00006cd0 	.word	0x00006cd0
    2698:	f3af 8000 	nop.w
    269c:	f3af 8000 	nop.w

000026a0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    26a0:	b538      	push	{r3, r4, r5, lr}
    26a2:	4605      	mov	r5, r0
    26a4:	460c      	mov	r4, r1
    26a6:	2320      	movs	r3, #32
    26a8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    26ac:	f7ff fb00 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    26b0:	f7fe fcbe 	bl	1030 <_dbg_check_lock>

  chSysLock();
  chPoolFreeI(mp, objp);
    26b4:	4628      	mov	r0, r5
    26b6:	4621      	mov	r1, r4
    26b8:	f7ff ffda 	bl	2670 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    26bc:	f7fe fcc8 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    26c0:	f7ff fafe 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    26c4:	4b07      	ldr	r3, [pc, #28]	; (26e4 <chPoolFree+0x44>)
    26c6:	681a      	ldr	r2, [r3, #0]
    26c8:	429a      	cmp	r2, r3
    26ca:	d007      	beq.n	26dc <chPoolFree+0x3c>
    26cc:	6999      	ldr	r1, [r3, #24]
    26ce:	6893      	ldr	r3, [r2, #8]
    26d0:	688a      	ldr	r2, [r1, #8]
    26d2:	429a      	cmp	r2, r3
    26d4:	d202      	bcs.n	26dc <chPoolFree+0x3c>
    26d6:	4804      	ldr	r0, [pc, #16]	; (26e8 <chPoolFree+0x48>)
    26d8:	f7fe fc52 	bl	f80 <chSysHalt>
    26dc:	2300      	movs	r3, #0
    26de:	f383 8811 	msr	BASEPRI, r3
    26e2:	bd38      	pop	{r3, r4, r5, pc}
    26e4:	1ffff228 	.word	0x1ffff228
    26e8:	00006cc0 	.word	0x00006cc0
    26ec:	f3af 8000 	nop.w

000026f0 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
    26f0:	4a06      	ldr	r2, [pc, #24]	; (270c <SVC_Handler+0x1c>)
    26f2:	6853      	ldr	r3, [r2, #4]
    26f4:	f023 0301 	bic.w	r3, r3, #1
    26f8:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    26fa:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    26fe:	3368      	adds	r3, #104	; 0x68
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2700:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    2704:	2300      	movs	r3, #0
    2706:	f383 8811 	msr	BASEPRI, r3
    270a:	4770      	bx	lr
    270c:	e000ef30 	.word	0xe000ef30

00002710 <_port_irq_epilogue>:
    2710:	2320      	movs	r3, #32
    2712:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
    2716:	4b12      	ldr	r3, [pc, #72]	; (2760 <_port_irq_epilogue+0x50>)
    2718:	685b      	ldr	r3, [r3, #4]
    271a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
    271e:	d102      	bne.n	2726 <_port_irq_epilogue+0x16>
    2720:	f383 8811 	msr	BASEPRI, r3
    2724:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    2726:	b510      	push	{r4, lr}
#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
    2728:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    272c:	f3ef 8409 	mrs	r4, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
    2730:	4b0c      	ldr	r3, [pc, #48]	; (2764 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    2732:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
    2736:	68db      	ldr	r3, [r3, #12]
    2738:	f844 3c08 	str.w	r3, [r4, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    273c:	f844 2c4c 	str.w	r2, [r4, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    2740:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2744:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    2748:	f7fe fec2 	bl	14d0 <chSchIsPreemptionRequired>
    274c:	b118      	cbz	r0, 2756 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    274e:	4b06      	ldr	r3, [pc, #24]	; (2768 <_port_irq_epilogue+0x58>)
    2750:	f844 3c50 	str.w	r3, [r4, #-80]
    2754:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    2756:	4b05      	ldr	r3, [pc, #20]	; (276c <_port_irq_epilogue+0x5c>)
    2758:	f844 3c50 	str.w	r3, [r4, #-80]
    275c:	bd10      	pop	{r4, pc}
    275e:	bf00      	nop
    2760:	e000ed00 	.word	0xe000ed00
    2764:	e000ef30 	.word	0xe000ef30
    2768:	00000561 	.word	0x00000561
    276c:	00000574 	.word	0x00000574

00002770 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    2770:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    2772:	f000 fd05 	bl	3180 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    2776:	4808      	ldr	r0, [pc, #32]	; (2798 <halInit+0x28>)
    2778:	f000 ff1a 	bl	35b0 <_pal_lld_init>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
    277c:	f000 fa58 	bl	2c30 <extInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    2780:	f000 fa66 	bl	2c50 <i2cInit>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    2784:	f000 fb94 	bl	2eb0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    2788:	f000 fbf2 	bl	2f70 <spiInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    278c:	f001 fcd8 	bl	4140 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
    2790:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    2794:	f000 b804 	b.w	27a0 <stInit>
    2798:	00006e60 	.word	0x00006e60
    279c:	f3af 8000 	nop.w

000027a0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    27a0:	f001 bcb6 	b.w	4110 <st_lld_init>
    27a4:	f3af 8000 	nop.w
    27a8:	f3af 8000 	nop.w
    27ac:	f3af 8000 	nop.w

000027b0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    27b0:	b430      	push	{r4, r5}
    27b2:	9c02      	ldr	r4, [sp, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
    27b4:	6204      	str	r4, [r0, #32]
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
    27b6:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
    27b8:	440a      	add	r2, r1
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
    27ba:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
    27bc:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
    27be:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
    27c0:	6040      	str	r0, [r0, #4]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
    27c2:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
    27c4:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
    27c6:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
    27c8:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
    27ca:	bc30      	pop	{r4, r5}
    27cc:	4770      	bx	lr
    27ce:	bf00      	nop

000027d0 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    27d0:	b538      	push	{r3, r4, r5, lr}
    27d2:	4604      	mov	r4, r0
    27d4:	460d      	mov	r5, r1

  osalDbgCheckClassI();
    27d6:	f7fe fcb3 	bl	1140 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
    27da:	6963      	ldr	r3, [r4, #20]
    27dc:	69a2      	ldr	r2, [r4, #24]
    27de:	4293      	cmp	r3, r2
    27e0:	d011      	beq.n	2806 <iqPutI+0x36>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
    27e2:	68a2      	ldr	r2, [r4, #8]
  *iqp->q_wrptr++ = b;
    27e4:	1c59      	adds	r1, r3, #1

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
    27e6:	3201      	adds	r2, #1
    27e8:	60a2      	str	r2, [r4, #8]
  *iqp->q_wrptr++ = b;
    27ea:	6161      	str	r1, [r4, #20]
    27ec:	701d      	strb	r5, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
    27ee:	6962      	ldr	r2, [r4, #20]
    27f0:	6923      	ldr	r3, [r4, #16]
    27f2:	429a      	cmp	r2, r3
    27f4:	d301      	bcc.n	27fa <iqPutI+0x2a>
    iqp->q_wrptr = iqp->q_buffer;
    27f6:	68e3      	ldr	r3, [r4, #12]
    27f8:	6163      	str	r3, [r4, #20]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
    27fa:	4620      	mov	r0, r4
    27fc:	2100      	movs	r1, #0
    27fe:	f7ff f97f 	bl	1b00 <chThdDequeueNextI>
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

  return MSG_OK;
    2802:	2000      	movs	r0, #0
    2804:	bd38      	pop	{r3, r4, r5, pc}
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
    2806:	68a2      	ldr	r2, [r4, #8]
    2808:	2a00      	cmp	r2, #0
    280a:	d0ea      	beq.n	27e2 <iqPutI+0x12>
    return MSG_TIMEOUT;
    280c:	f04f 30ff 	mov.w	r0, #4294967295
    2810:	bd38      	pop	{r3, r4, r5, pc}
    2812:	bf00      	nop
    2814:	f3af 8000 	nop.w
    2818:	f3af 8000 	nop.w
    281c:	f3af 8000 	nop.w

00002820 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    2820:	b570      	push	{r4, r5, r6, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    2822:	2320      	movs	r3, #32
    2824:	4604      	mov	r4, r0
    2826:	460e      	mov	r6, r1
    2828:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    282c:	f7ff fa40 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2830:	f7fe fbfe 	bl	1030 <_dbg_check_lock>
    2834:	e003      	b.n	283e <iqGetTimeout+0x1e>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
    2836:	f7ff f94b 	bl	1ad0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
    283a:	1e05      	subs	r5, r0, #0
    283c:	db15      	blt.n	286a <iqGetTimeout+0x4a>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    283e:	68a3      	ldr	r3, [r4, #8]
    2840:	4620      	mov	r0, r4
    2842:	4631      	mov	r1, r6
    2844:	2b00      	cmp	r3, #0
    2846:	d0f6      	beq.n	2836 <iqGetTimeout+0x16>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
    2848:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    284a:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    284c:	6920      	ldr	r0, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
    284e:	1c4a      	adds	r2, r1, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    2850:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    2852:	4282      	cmp	r2, r0
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    2854:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
    2856:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
    2858:	bf28      	it	cs
    285a:	68e3      	ldrcs	r3, [r4, #12]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
    285c:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
    285e:	bf28      	it	cs
    2860:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    2862:	69e3      	ldr	r3, [r4, #28]
    2864:	b10b      	cbz	r3, 286a <iqGetTimeout+0x4a>
    iqp->q_notify(iqp);
    2866:	4620      	mov	r0, r4
    2868:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    286a:	f7fe fbf1 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    286e:	f7ff fa27 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2872:	4b08      	ldr	r3, [pc, #32]	; (2894 <iqGetTimeout+0x74>)
    2874:	681a      	ldr	r2, [r3, #0]
    2876:	429a      	cmp	r2, r3
    2878:	d007      	beq.n	288a <iqGetTimeout+0x6a>
    287a:	6999      	ldr	r1, [r3, #24]
    287c:	6893      	ldr	r3, [r2, #8]
    287e:	688a      	ldr	r2, [r1, #8]
    2880:	429a      	cmp	r2, r3
    2882:	d202      	bcs.n	288a <iqGetTimeout+0x6a>
    2884:	4804      	ldr	r0, [pc, #16]	; (2898 <iqGetTimeout+0x78>)
    2886:	f7fe fb7b 	bl	f80 <chSysHalt>
    288a:	2300      	movs	r3, #0
    288c:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
    2890:	4628      	mov	r0, r5
}
    2892:	bd70      	pop	{r4, r5, r6, pc}
    2894:	1ffff228 	.word	0x1ffff228
    2898:	00006ce0 	.word	0x00006ce0
    289c:	f3af 8000 	nop.w

000028a0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    28a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    28a4:	4682      	mov	sl, r0
    28a6:	b083      	sub	sp, #12
    28a8:	460c      	mov	r4, r1
    28aa:	4698      	mov	r8, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    28ac:	f8d0 901c 	ldr.w	r9, [r0, #28]
  size_t r = 0;

  osalDbgCheck(n > 0U);
    28b0:	4615      	mov	r5, r2
    28b2:	2a00      	cmp	r2, #0
    28b4:	d078      	beq.n	29a8 <iqReadTimeout+0x108>
    28b6:	2320      	movs	r3, #32
    28b8:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
    28bc:	4e45      	ldr	r6, [pc, #276]	; (29d4 <iqReadTimeout+0x134>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    28be:	f7ff f9f7 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    28c2:	f7fe fbb5 	bl	1030 <_dbg_check_lock>
    28c6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    28c8:	4443      	add	r3, r8
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
    28ca:	2700      	movs	r7, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    28cc:	9301      	str	r3, [sp, #4]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    28ce:	46b3      	mov	fp, r6

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    28d0:	f8da 3008 	ldr.w	r3, [sl, #8]
    28d4:	2b00      	cmp	r3, #0
    28d6:	d03d      	beq.n	2954 <iqReadTimeout+0xb4>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    28d8:	f8da 2018 	ldr.w	r2, [sl, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    28dc:	f8da 3008 	ldr.w	r3, [sl, #8]
    *bp++ = *iqp->q_rdptr++;
    28e0:	1c51      	adds	r1, r2, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    28e2:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
    28e4:	f8ca 1018 	str.w	r1, [sl, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    28e8:	f8ca 3008 	str.w	r3, [sl, #8]
    *bp++ = *iqp->q_rdptr++;
    28ec:	7813      	ldrb	r3, [r2, #0]
    28ee:	7023      	strb	r3, [r4, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
    28f0:	f8da 3010 	ldr.w	r3, [sl, #16]
    28f4:	f8da 2018 	ldr.w	r2, [sl, #24]
    28f8:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
    28fa:	bf24      	itt	cs
    28fc:	f8da 300c 	ldrcs.w	r3, [sl, #12]
    2900:	f8ca 3018 	strcs.w	r3, [sl, #24]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    2904:	3401      	adds	r4, #1
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    2906:	f1b9 0f00 	cmp.w	r9, #0
    290a:	d001      	beq.n	2910 <iqReadTimeout+0x70>
      nfy(iqp);
    290c:	4650      	mov	r0, sl
    290e:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2910:	f7fe fb9e 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2914:	f7ff f9d4 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2918:	6833      	ldr	r3, [r6, #0]
    291a:	42b3      	cmp	r3, r6
    291c:	d008      	beq.n	2930 <iqReadTimeout+0x90>
    291e:	f8db 2018 	ldr.w	r2, [fp, #24]
    2922:	689b      	ldr	r3, [r3, #8]
    2924:	6892      	ldr	r2, [r2, #8]
    2926:	429a      	cmp	r2, r3
    2928:	d202      	bcs.n	2930 <iqReadTimeout+0x90>
    292a:	482b      	ldr	r0, [pc, #172]	; (29d8 <iqReadTimeout+0x138>)
    292c:	f7fe fb28 	bl	f80 <chSysHalt>
    2930:	2300      	movs	r3, #0
    2932:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
    2936:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    2938:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
    293c:	d029      	beq.n	2992 <iqReadTimeout+0xf2>
    293e:	2320      	movs	r3, #32
    2940:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2944:	f7ff f9b4 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2948:	f7fe fb72 	bl	1030 <_dbg_check_lock>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    294c:	f8da 3008 	ldr.w	r3, [sl, #8]
    2950:	2b00      	cmp	r3, #0
    2952:	d1c1      	bne.n	28d8 <iqReadTimeout+0x38>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    2954:	f108 33ff 	add.w	r3, r8, #4294967295
    2958:	3303      	adds	r3, #3
    295a:	d81e      	bhi.n	299a <iqReadTimeout+0xfa>
    295c:	6ab1      	ldr	r1, [r6, #40]	; 0x28
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    295e:	9a01      	ldr	r2, [sp, #4]
    2960:	4b1c      	ldr	r3, [pc, #112]	; (29d4 <iqReadTimeout+0x134>)
    2962:	1a51      	subs	r1, r2, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    2964:	4588      	cmp	r8, r1
    2966:	d323      	bcc.n	29b0 <iqReadTimeout+0x110>
    2968:	4650      	mov	r0, sl
    296a:	f7ff f8b1 	bl	1ad0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    296e:	2800      	cmp	r0, #0
    2970:	d0ae      	beq.n	28d0 <iqReadTimeout+0x30>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2972:	f7fe fb6d 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2976:	f7ff f9a3 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    297a:	6833      	ldr	r3, [r6, #0]
    297c:	4a15      	ldr	r2, [pc, #84]	; (29d4 <iqReadTimeout+0x134>)
    297e:	42b3      	cmp	r3, r6
    2980:	d004      	beq.n	298c <iqReadTimeout+0xec>
    2982:	6992      	ldr	r2, [r2, #24]
    2984:	689b      	ldr	r3, [r3, #8]
    2986:	6892      	ldr	r2, [r2, #8]
    2988:	429a      	cmp	r2, r3
    298a:	d31f      	bcc.n	29cc <iqReadTimeout+0x12c>
    298c:	2300      	movs	r3, #0
    298e:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
    2992:	4638      	mov	r0, r7
    2994:	b003      	add	sp, #12
    2996:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    299a:	4650      	mov	r0, sl
    299c:	4641      	mov	r1, r8
    299e:	f7ff f897 	bl	1ad0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    29a2:	2800      	cmp	r0, #0
    29a4:	d094      	beq.n	28d0 <iqReadTimeout+0x30>
    29a6:	e7e4      	b.n	2972 <iqReadTimeout+0xd2>
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
    29a8:	480c      	ldr	r0, [pc, #48]	; (29dc <iqReadTimeout+0x13c>)
    29aa:	f7fe fae9 	bl	f80 <chSysHalt>
    29ae:	e782      	b.n	28b6 <iqReadTimeout+0x16>
    29b0:	9301      	str	r3, [sp, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    29b2:	f7fe fb4d 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    29b6:	f7ff f983 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    29ba:	9b01      	ldr	r3, [sp, #4]
    29bc:	681a      	ldr	r2, [r3, #0]
    29be:	429a      	cmp	r2, r3
    29c0:	d0e4      	beq.n	298c <iqReadTimeout+0xec>
    29c2:	6999      	ldr	r1, [r3, #24]
    29c4:	6893      	ldr	r3, [r2, #8]
    29c6:	688a      	ldr	r2, [r1, #8]
    29c8:	429a      	cmp	r2, r3
    29ca:	d2df      	bcs.n	298c <iqReadTimeout+0xec>
    29cc:	4802      	ldr	r0, [pc, #8]	; (29d8 <iqReadTimeout+0x138>)
    29ce:	f7fe fad7 	bl	f80 <chSysHalt>
    29d2:	e7db      	b.n	298c <iqReadTimeout+0xec>
    29d4:	1ffff228 	.word	0x1ffff228
    29d8:	00006ce0 	.word	0x00006ce0
    29dc:	00006d00 	.word	0x00006d00

000029e0 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    29e0:	b430      	push	{r4, r5}
    29e2:	9c02      	ldr	r4, [sp, #8]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
    29e4:	6204      	str	r4, [r0, #32]
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
    29e6:	188d      	adds	r5, r1, r2
    29e8:	6105      	str	r5, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
    29ea:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
    29ec:	6040      	str	r0, [r0, #4]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
    29ee:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
    29f0:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
    29f2:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
    29f4:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
    29f6:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
    29f8:	bc30      	pop	{r4, r5}
    29fa:	4770      	bx	lr
    29fc:	f3af 8000 	nop.w

00002a00 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    2a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a02:	4604      	mov	r4, r0
    2a04:	460f      	mov	r7, r1
    2a06:	4616      	mov	r6, r2
    2a08:	2320      	movs	r3, #32
    2a0a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2a0e:	f7ff f94f 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2a12:	f7fe fb0d 	bl	1030 <_dbg_check_lock>
    2a16:	e003      	b.n	2a20 <oqPutTimeout+0x20>
    2a18:	f7ff f85a 	bl	1ad0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
    2a1c:	1e05      	subs	r5, r0, #0
    2a1e:	db26      	blt.n	2a6e <oqPutTimeout+0x6e>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    2a20:	68a3      	ldr	r3, [r4, #8]
    2a22:	4620      	mov	r0, r4
    2a24:	4631      	mov	r1, r6
    2a26:	2b00      	cmp	r3, #0
    2a28:	d0f6      	beq.n	2a18 <oqPutTimeout+0x18>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
    2a2a:	6962      	ldr	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    2a2c:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
    2a2e:	1c51      	adds	r1, r2, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    2a30:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
    2a32:	6161      	str	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    2a34:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
    2a36:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
    2a38:	6923      	ldr	r3, [r4, #16]
    2a3a:	6962      	ldr	r2, [r4, #20]
    2a3c:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
    2a3e:	bf24      	itt	cs
    2a40:	68e3      	ldrcs	r3, [r4, #12]
    2a42:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    2a44:	69e3      	ldr	r3, [r4, #28]
    2a46:	b10b      	cbz	r3, 2a4c <oqPutTimeout+0x4c>
    oqp->q_notify(oqp);
    2a48:	4620      	mov	r0, r4
    2a4a:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2a4c:	f7fe fb00 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2a50:	f7ff f936 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2a54:	4b14      	ldr	r3, [pc, #80]	; (2aa8 <oqPutTimeout+0xa8>)
    2a56:	681a      	ldr	r2, [r3, #0]
    2a58:	429a      	cmp	r2, r3
    2a5a:	d004      	beq.n	2a66 <oqPutTimeout+0x66>
    2a5c:	6999      	ldr	r1, [r3, #24]
    2a5e:	6893      	ldr	r3, [r2, #8]
    2a60:	688a      	ldr	r2, [r1, #8]
    2a62:	429a      	cmp	r2, r3
    2a64:	d318      	bcc.n	2a98 <oqPutTimeout+0x98>
    2a66:	2000      	movs	r0, #0
    2a68:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
    2a6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2a6e:	f7fe faef 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2a72:	f7ff f925 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2a76:	4b0c      	ldr	r3, [pc, #48]	; (2aa8 <oqPutTimeout+0xa8>)
    2a78:	681a      	ldr	r2, [r3, #0]
    2a7a:	429a      	cmp	r2, r3
    2a7c:	d007      	beq.n	2a8e <oqPutTimeout+0x8e>
    2a7e:	6999      	ldr	r1, [r3, #24]
    2a80:	6893      	ldr	r3, [r2, #8]
    2a82:	688a      	ldr	r2, [r1, #8]
    2a84:	429a      	cmp	r2, r3
    2a86:	d202      	bcs.n	2a8e <oqPutTimeout+0x8e>
    2a88:	4808      	ldr	r0, [pc, #32]	; (2aac <oqPutTimeout+0xac>)
    2a8a:	f7fe fa79 	bl	f80 <chSysHalt>
    2a8e:	2300      	movs	r3, #0
    2a90:	f383 8811 	msr	BASEPRI, r3
    2a94:	4628      	mov	r0, r5
  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
      osalSysUnlock();
      return msg;
    2a96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2a98:	4804      	ldr	r0, [pc, #16]	; (2aac <oqPutTimeout+0xac>)
    2a9a:	f7fe fa71 	bl	f80 <chSysHalt>
    2a9e:	2000      	movs	r0, #0
    2aa0:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
    2aa4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2aa6:	bf00      	nop
    2aa8:	1ffff228 	.word	0x1ffff228
    2aac:	00006ce0 	.word	0x00006ce0

00002ab0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    2ab0:	b538      	push	{r3, r4, r5, lr}
    2ab2:	4604      	mov	r4, r0
  uint8_t b;

  osalDbgCheckClassI();
    2ab4:	f7fe fb44 	bl	1140 <chDbgCheckClassI>

  if (oqIsEmptyI(oqp)) {
    2ab8:	69a3      	ldr	r3, [r4, #24]
    2aba:	6962      	ldr	r2, [r4, #20]
    2abc:	429a      	cmp	r2, r3
    2abe:	d010      	beq.n	2ae2 <oqGetI+0x32>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
    2ac0:	68a2      	ldr	r2, [r4, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
    2ac2:	6920      	ldr	r0, [r4, #16]
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
    2ac4:	1c59      	adds	r1, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
    2ac6:	3201      	adds	r2, #1
    2ac8:	60a2      	str	r2, [r4, #8]
  b = *oqp->q_rdptr++;
    2aca:	61a1      	str	r1, [r4, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
    2acc:	4281      	cmp	r1, r0
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
    2ace:	781d      	ldrb	r5, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
    2ad0:	d301      	bcc.n	2ad6 <oqGetI+0x26>
    oqp->q_rdptr = oqp->q_buffer;
    2ad2:	68e3      	ldr	r3, [r4, #12]
    2ad4:	61a3      	str	r3, [r4, #24]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
    2ad6:	4620      	mov	r0, r4
    2ad8:	2100      	movs	r1, #0
    2ada:	f7ff f811 	bl	1b00 <chThdDequeueNextI>
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

  return (msg_t)b;
    2ade:	4628      	mov	r0, r5
    2ae0:	bd38      	pop	{r3, r4, r5, pc}
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
    2ae2:	68a2      	ldr	r2, [r4, #8]
    2ae4:	2a00      	cmp	r2, #0
    2ae6:	d0eb      	beq.n	2ac0 <oqGetI+0x10>
    return MSG_TIMEOUT;
    2ae8:	f04f 30ff 	mov.w	r0, #4294967295
    2aec:	bd38      	pop	{r3, r4, r5, pc}
    2aee:	bf00      	nop

00002af0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    2af0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2af4:	4682      	mov	sl, r0
    2af6:	b083      	sub	sp, #12
    2af8:	460c      	mov	r4, r1
    2afa:	4698      	mov	r8, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    2afc:	f8d0 901c 	ldr.w	r9, [r0, #28]
  size_t w = 0;

  osalDbgCheck(n > 0U);
    2b00:	4615      	mov	r5, r2
    2b02:	2a00      	cmp	r2, #0
    2b04:	d078      	beq.n	2bf8 <oqWriteTimeout+0x108>
    2b06:	2320      	movs	r3, #32
    2b08:	f383 8811 	msr	BASEPRI, r3
    2b0c:	4e45      	ldr	r6, [pc, #276]	; (2c24 <oqWriteTimeout+0x134>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2b0e:	f7ff f8cf 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2b12:	f7fe fa8d 	bl	1030 <_dbg_check_lock>
    2b16:	6ab3      	ldr	r3, [r6, #40]	; 0x28
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    2b18:	4443      	add	r3, r8
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
    2b1a:	2700      	movs	r7, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    2b1c:	9301      	str	r3, [sp, #4]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2b1e:	46b3      	mov	fp, r6

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    2b20:	f8da 3008 	ldr.w	r3, [sl, #8]
    2b24:	2b00      	cmp	r3, #0
    2b26:	d03d      	beq.n	2ba4 <oqWriteTimeout+0xb4>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
    2b28:	f8da 2014 	ldr.w	r2, [sl, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    2b2c:	f8da 3008 	ldr.w	r3, [sl, #8]
    *oqp->q_wrptr++ = *bp++;
    2b30:	1c51      	adds	r1, r2, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    2b32:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
    2b34:	f8ca 1014 	str.w	r1, [sl, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    2b38:	f8ca 3008 	str.w	r3, [sl, #8]
    *oqp->q_wrptr++ = *bp++;
    2b3c:	7823      	ldrb	r3, [r4, #0]
    2b3e:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
    2b40:	f8da 3010 	ldr.w	r3, [sl, #16]
    2b44:	f8da 2014 	ldr.w	r2, [sl, #20]
    2b48:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
    2b4a:	bf24      	itt	cs
    2b4c:	f8da 300c 	ldrcs.w	r3, [sl, #12]
    2b50:	f8ca 3014 	strcs.w	r3, [sl, #20]
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
    2b54:	3401      	adds	r4, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    2b56:	f1b9 0f00 	cmp.w	r9, #0
    2b5a:	d001      	beq.n	2b60 <oqWriteTimeout+0x70>
      nfy(oqp);
    2b5c:	4650      	mov	r0, sl
    2b5e:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2b60:	f7fe fa76 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2b64:	f7ff f8ac 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2b68:	6833      	ldr	r3, [r6, #0]
    2b6a:	42b3      	cmp	r3, r6
    2b6c:	d008      	beq.n	2b80 <oqWriteTimeout+0x90>
    2b6e:	f8db 2018 	ldr.w	r2, [fp, #24]
    2b72:	689b      	ldr	r3, [r3, #8]
    2b74:	6892      	ldr	r2, [r2, #8]
    2b76:	429a      	cmp	r2, r3
    2b78:	d202      	bcs.n	2b80 <oqWriteTimeout+0x90>
    2b7a:	482b      	ldr	r0, [pc, #172]	; (2c28 <oqWriteTimeout+0x138>)
    2b7c:	f7fe fa00 	bl	f80 <chSysHalt>
    2b80:	2300      	movs	r3, #0
    2b82:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
    2b86:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    2b88:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
    2b8c:	d029      	beq.n	2be2 <oqWriteTimeout+0xf2>
    2b8e:	2320      	movs	r3, #32
    2b90:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2b94:	f7ff f88c 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2b98:	f7fe fa4a 	bl	1030 <_dbg_check_lock>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    2b9c:	f8da 3008 	ldr.w	r3, [sl, #8]
    2ba0:	2b00      	cmp	r3, #0
    2ba2:	d1c1      	bne.n	2b28 <oqWriteTimeout+0x38>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    2ba4:	f108 33ff 	add.w	r3, r8, #4294967295
    2ba8:	3303      	adds	r3, #3
    2baa:	d81e      	bhi.n	2bea <oqWriteTimeout+0xfa>
    2bac:	6ab1      	ldr	r1, [r6, #40]	; 0x28
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    2bae:	9a01      	ldr	r2, [sp, #4]
    2bb0:	4b1c      	ldr	r3, [pc, #112]	; (2c24 <oqWriteTimeout+0x134>)
    2bb2:	1a51      	subs	r1, r2, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    2bb4:	4588      	cmp	r8, r1
    2bb6:	d323      	bcc.n	2c00 <oqWriteTimeout+0x110>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
    2bb8:	4650      	mov	r0, sl
    2bba:	f7fe ff89 	bl	1ad0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    2bbe:	2800      	cmp	r0, #0
    2bc0:	d0ae      	beq.n	2b20 <oqWriteTimeout+0x30>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2bc2:	f7fe fa45 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2bc6:	f7ff f87b 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2bca:	6833      	ldr	r3, [r6, #0]
    2bcc:	4a15      	ldr	r2, [pc, #84]	; (2c24 <oqWriteTimeout+0x134>)
    2bce:	42b3      	cmp	r3, r6
    2bd0:	d004      	beq.n	2bdc <oqWriteTimeout+0xec>
    2bd2:	6992      	ldr	r2, [r2, #24]
    2bd4:	689b      	ldr	r3, [r3, #8]
    2bd6:	6892      	ldr	r2, [r2, #8]
    2bd8:	429a      	cmp	r2, r3
    2bda:	d31f      	bcc.n	2c1c <oqWriteTimeout+0x12c>
    2bdc:	2300      	movs	r3, #0
    2bde:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
    2be2:	4638      	mov	r0, r7
    2be4:	b003      	add	sp, #12
    2be6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2bea:	4650      	mov	r0, sl
    2bec:	4641      	mov	r1, r8
    2bee:	f7fe ff6f 	bl	1ad0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    2bf2:	2800      	cmp	r0, #0
    2bf4:	d094      	beq.n	2b20 <oqWriteTimeout+0x30>
    2bf6:	e7e4      	b.n	2bc2 <oqWriteTimeout+0xd2>
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
    2bf8:	480c      	ldr	r0, [pc, #48]	; (2c2c <oqWriteTimeout+0x13c>)
    2bfa:	f7fe f9c1 	bl	f80 <chSysHalt>
    2bfe:	e782      	b.n	2b06 <oqWriteTimeout+0x16>
    2c00:	9301      	str	r3, [sp, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2c02:	f7fe fa25 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2c06:	f7ff f85b 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2c0a:	9b01      	ldr	r3, [sp, #4]
    2c0c:	681a      	ldr	r2, [r3, #0]
    2c0e:	429a      	cmp	r2, r3
    2c10:	d0e4      	beq.n	2bdc <oqWriteTimeout+0xec>
    2c12:	6999      	ldr	r1, [r3, #24]
    2c14:	6893      	ldr	r3, [r2, #8]
    2c16:	688a      	ldr	r2, [r1, #8]
    2c18:	429a      	cmp	r2, r3
    2c1a:	d2df      	bcs.n	2bdc <oqWriteTimeout+0xec>
    2c1c:	4802      	ldr	r0, [pc, #8]	; (2c28 <oqWriteTimeout+0x138>)
    2c1e:	f7fe f9af 	bl	f80 <chSysHalt>
    2c22:	e7db      	b.n	2bdc <oqWriteTimeout+0xec>
    2c24:	1ffff228 	.word	0x1ffff228
    2c28:	00006ce0 	.word	0x00006ce0
    2c2c:	00006cf0 	.word	0x00006cf0

00002c30 <extInit>:
 *
 * @init
 */
void extInit(void) {

  ext_lld_init();
    2c30:	f001 ba46 	b.w	40c0 <ext_lld_init>
    2c34:	f3af 8000 	nop.w
    2c38:	f3af 8000 	nop.w
    2c3c:	f3af 8000 	nop.w

00002c40 <extObjectInit>:
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
  extp->config = NULL;
    2c40:	2201      	movs	r2, #1
    2c42:	2300      	movs	r3, #0
    2c44:	e880 000c 	stmia.w	r0, {r2, r3}
    2c48:	4770      	bx	lr
    2c4a:	bf00      	nop
    2c4c:	f3af 8000 	nop.w

00002c50 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    2c50:	f001 b826 	b.w	3ca0 <i2c_lld_init>
    2c54:	f3af 8000 	nop.w
    2c58:	f3af 8000 	nop.w
    2c5c:	f3af 8000 	nop.w

00002c60 <i2cObjectInit>:
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
  i2cp->config = NULL;
    2c60:	2201      	movs	r2, #1
    2c62:	2300      	movs	r3, #0
    2c64:	e880 000c 	stmia.w	r0, {r2, r3}
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    2c68:	300c      	adds	r0, #12
    2c6a:	f7ff b8b9 	b.w	1de0 <chMtxObjectInit>
    2c6e:	bf00      	nop

00002c70 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    2c70:	b538      	push	{r3, r4, r5, lr}
    2c72:	460d      	mov	r5, r1

  osalDbgCheck((i2cp != NULL) && (config != NULL));
    2c74:	4604      	mov	r4, r0
    2c76:	b350      	cbz	r0, 2cce <i2cStart+0x5e>
    2c78:	b349      	cbz	r1, 2cce <i2cStart+0x5e>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    2c7a:	6823      	ldr	r3, [r4, #0]
    2c7c:	1e5a      	subs	r2, r3, #1
    2c7e:	2a01      	cmp	r2, #1
    2c80:	d904      	bls.n	2c8c <i2cStart+0x1c>
    2c82:	2b05      	cmp	r3, #5
    2c84:	d002      	beq.n	2c8c <i2cStart+0x1c>
    2c86:	4814      	ldr	r0, [pc, #80]	; (2cd8 <i2cStart+0x68>)
    2c88:	f7fe f97a 	bl	f80 <chSysHalt>
    2c8c:	2320      	movs	r3, #32
    2c8e:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2c92:	f7ff f80d 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2c96:	f7fe f9cb 	bl	1030 <_dbg_check_lock>
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
  i2c_lld_start(i2cp);
    2c9a:	4620      	mov	r0, r4
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
    2c9c:	6065      	str	r5, [r4, #4]
  i2c_lld_start(i2cp);
    2c9e:	f001 f81f 	bl	3ce0 <i2c_lld_start>
  i2cp->state = I2C_READY;
    2ca2:	2302      	movs	r3, #2
    2ca4:	6023      	str	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2ca6:	f7fe f9d3 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2caa:	f7ff f809 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2cae:	4b0b      	ldr	r3, [pc, #44]	; (2cdc <i2cStart+0x6c>)
    2cb0:	681a      	ldr	r2, [r3, #0]
    2cb2:	429a      	cmp	r2, r3
    2cb4:	d007      	beq.n	2cc6 <i2cStart+0x56>
    2cb6:	6999      	ldr	r1, [r3, #24]
    2cb8:	6893      	ldr	r3, [r2, #8]
    2cba:	688a      	ldr	r2, [r1, #8]
    2cbc:	429a      	cmp	r2, r3
    2cbe:	d202      	bcs.n	2cc6 <i2cStart+0x56>
    2cc0:	4807      	ldr	r0, [pc, #28]	; (2ce0 <i2cStart+0x70>)
    2cc2:	f7fe f95d 	bl	f80 <chSysHalt>
    2cc6:	2300      	movs	r3, #0
    2cc8:	f383 8811 	msr	BASEPRI, r3
    2ccc:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {

  osalDbgCheck((i2cp != NULL) && (config != NULL));
    2cce:	4802      	ldr	r0, [pc, #8]	; (2cd8 <i2cStart+0x68>)
    2cd0:	f7fe f956 	bl	f80 <chSysHalt>
    2cd4:	e7d1      	b.n	2c7a <i2cStart+0xa>
    2cd6:	bf00      	nop
    2cd8:	00006d40 	.word	0x00006d40
    2cdc:	1ffff228 	.word	0x1ffff228
    2ce0:	00006d10 	.word	0x00006d10
    2ce4:	f3af 8000 	nop.w
    2ce8:	f3af 8000 	nop.w
    2cec:	f3af 8000 	nop.w

00002cf0 <i2cGetErrors>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @return              The errors mask.
 *
 * @api
 */
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {
    2cf0:	b510      	push	{r4, lr}

  osalDbgCheck(i2cp != NULL);
    2cf2:	4604      	mov	r4, r0
    2cf4:	b108      	cbz	r0, 2cfa <i2cGetErrors+0xa>

  return i2c_lld_get_errors(i2cp);
}
    2cf6:	68a0      	ldr	r0, [r4, #8]
    2cf8:	bd10      	pop	{r4, pc}
 *
 * @api
 */
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);
    2cfa:	4802      	ldr	r0, [pc, #8]	; (2d04 <i2cGetErrors+0x14>)
    2cfc:	f7fe f940 	bl	f80 <chSysHalt>

  return i2c_lld_get_errors(i2cp);
}
    2d00:	68a0      	ldr	r0, [r4, #8]
    2d02:	bd10      	pop	{r4, pc}
    2d04:	00006d50 	.word	0x00006d50
    2d08:	f3af 8000 	nop.w
    2d0c:	f3af 8000 	nop.w

00002d10 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
    2d10:	e92d 46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
    2d14:	b085      	sub	sp, #20
    2d16:	460e      	mov	r6, r1
    2d18:	4692      	mov	sl, r2
    2d1a:	4699      	mov	r9, r3
    2d1c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
    2d1e:	4604      	mov	r4, r0
    2d20:	b108      	cbz	r0, 2d26 <i2cMasterTransmitTimeout+0x16>
    2d22:	2900      	cmp	r1, #0
    2d24:	d13b      	bne.n	2d9e <i2cMasterTransmitTimeout+0x8e>
    2d26:	4824      	ldr	r0, [pc, #144]	; (2db8 <i2cMasterTransmitTimeout+0xa8>)
    2d28:	f7fe f92a 	bl	f80 <chSysHalt>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
    2d2c:	6823      	ldr	r3, [r4, #0]
    2d2e:	2b02      	cmp	r3, #2
    2d30:	d002      	beq.n	2d38 <i2cMasterTransmitTimeout+0x28>
    2d32:	4821      	ldr	r0, [pc, #132]	; (2db8 <i2cMasterTransmitTimeout+0xa8>)
    2d34:	f7fe f924 	bl	f80 <chSysHalt>
    2d38:	2320      	movs	r3, #32
    2d3a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2d3e:	f7fe ffb7 	bl	1cb0 <_stats_start_measure_crit_thd>

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
    2d42:	2700      	movs	r7, #0
  _dbg_check_lock();
    2d44:	f7fe f974 	bl	1030 <_dbg_check_lock>
  i2cp->state = I2C_ACTIVE_TX;
    2d48:	2003      	movs	r0, #3
    2d4a:	6020      	str	r0, [r4, #0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
    2d4c:	4631      	mov	r1, r6
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
    2d4e:	60a7      	str	r7, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
    2d50:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    2d52:	9501      	str	r5, [sp, #4]
    2d54:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    2d56:	9502      	str	r5, [sp, #8]
    2d58:	4652      	mov	r2, sl
    2d5a:	464b      	mov	r3, r9
    2d5c:	4620      	mov	r0, r4
    2d5e:	9600      	str	r6, [sp, #0]
    2d60:	f000 fff6 	bl	3d50 <i2c_lld_master_transmit_timeout>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    2d64:	1c43      	adds	r3, r0, #1
    i2cp->state = I2C_LOCKED;
    2d66:	bf0c      	ite	eq
    2d68:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
    2d6a:	2302      	movne	r3, #2
    2d6c:	6023      	str	r3, [r4, #0]
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
    2d6e:	4605      	mov	r5, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2d70:	f7fe f96e 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2d74:	f7fe ffa4 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2d78:	4b10      	ldr	r3, [pc, #64]	; (2dbc <i2cMasterTransmitTimeout+0xac>)
    2d7a:	681a      	ldr	r2, [r3, #0]
    2d7c:	429a      	cmp	r2, r3
    2d7e:	d007      	beq.n	2d90 <i2cMasterTransmitTimeout+0x80>
    2d80:	6999      	ldr	r1, [r3, #24]
    2d82:	6893      	ldr	r3, [r2, #8]
    2d84:	688a      	ldr	r2, [r1, #8]
    2d86:	429a      	cmp	r2, r3
    2d88:	d202      	bcs.n	2d90 <i2cMasterTransmitTimeout+0x80>
    2d8a:	480d      	ldr	r0, [pc, #52]	; (2dc0 <i2cMasterTransmitTimeout+0xb0>)
    2d8c:	f7fe f8f8 	bl	f80 <chSysHalt>
    2d90:	2300      	movs	r3, #0
    2d92:	f383 8811 	msr	BASEPRI, r3
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
    2d96:	4628      	mov	r0, r5
    2d98:	b005      	add	sp, #20
    2d9a:	e8bd 86f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, pc}
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
    2d9e:	2b00      	cmp	r3, #0
    2da0:	d0c1      	beq.n	2d26 <i2cMasterTransmitTimeout+0x16>
    2da2:	2a00      	cmp	r2, #0
    2da4:	d0bf      	beq.n	2d26 <i2cMasterTransmitTimeout+0x16>
    2da6:	b115      	cbz	r5, 2dae <i2cMasterTransmitTimeout+0x9e>
    2da8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    2daa:	2b00      	cmp	r3, #0
    2dac:	d0bb      	beq.n	2d26 <i2cMasterTransmitTimeout+0x16>
    2dae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    2db0:	2b00      	cmp	r3, #0
    2db2:	d1bb      	bne.n	2d2c <i2cMasterTransmitTimeout+0x1c>
    2db4:	e7b7      	b.n	2d26 <i2cMasterTransmitTimeout+0x16>
    2db6:	bf00      	nop
    2db8:	00006d60 	.word	0x00006d60
    2dbc:	1ffff228 	.word	0x1ffff228
    2dc0:	00006d10 	.word	0x00006d10
    2dc4:	f3af 8000 	nop.w
    2dc8:	f3af 8000 	nop.w
    2dcc:	f3af 8000 	nop.w

00002dd0 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
    2dd0:	b510      	push	{r4, lr}

  osalDbgCheck(i2cp != NULL);
    2dd2:	4604      	mov	r4, r0
    2dd4:	b128      	cbz	r0, 2de2 <i2cAcquireBus+0x12>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
    2dd6:	f104 000c 	add.w	r0, r4, #12

  osalMutexLock(&i2cp->mutex);
}
    2dda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2dde:	f7ff b88f 	b.w	1f00 <chMtxLock>
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);
    2de2:	4804      	ldr	r0, [pc, #16]	; (2df4 <i2cAcquireBus+0x24>)
    2de4:	f7fe f8cc 	bl	f80 <chSysHalt>
    2de8:	f104 000c 	add.w	r0, r4, #12

  osalMutexLock(&i2cp->mutex);
}
    2dec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2df0:	f7ff b886 	b.w	1f00 <chMtxLock>
    2df4:	00006d20 	.word	0x00006d20
    2df8:	f3af 8000 	nop.w
    2dfc:	f3af 8000 	nop.w

00002e00 <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
    2e00:	b510      	push	{r4, lr}

  osalDbgCheck(i2cp != NULL);
    2e02:	4604      	mov	r4, r0
    2e04:	b128      	cbz	r0, 2e12 <i2cReleaseBus+0x12>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
    2e06:	f104 000c 	add.w	r0, r4, #12

  osalMutexUnlock(&i2cp->mutex);
}
    2e0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2e0e:	f7ff b89f 	b.w	1f50 <chMtxUnlock>
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);
    2e12:	4804      	ldr	r0, [pc, #16]	; (2e24 <i2cReleaseBus+0x24>)
    2e14:	f7fe f8b4 	bl	f80 <chSysHalt>
    2e18:	f104 000c 	add.w	r0, r4, #12

  osalMutexUnlock(&i2cp->mutex);
}
    2e1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2e20:	f7ff b896 	b.w	1f50 <chMtxUnlock>
    2e24:	00006d30 	.word	0x00006d30
    2e28:	f3af 8000 	nop.w
    2e2c:	f3af 8000 	nop.w

00002e30 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    2e30:	300c      	adds	r0, #12
    2e32:	f7ff bd35 	b.w	28a0 <iqReadTimeout>
    2e36:	bf00      	nop
    2e38:	f3af 8000 	nop.w
    2e3c:	f3af 8000 	nop.w

00002e40 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    2e40:	300c      	adds	r0, #12
    2e42:	f04f 33ff 	mov.w	r3, #4294967295
    2e46:	f7ff bd2b 	b.w	28a0 <iqReadTimeout>
    2e4a:	bf00      	nop
    2e4c:	f3af 8000 	nop.w

00002e50 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    2e50:	3030      	adds	r0, #48	; 0x30
    2e52:	f7ff be4d 	b.w	2af0 <oqWriteTimeout>
    2e56:	bf00      	nop
    2e58:	f3af 8000 	nop.w
    2e5c:	f3af 8000 	nop.w

00002e60 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    2e60:	3030      	adds	r0, #48	; 0x30
    2e62:	f04f 33ff 	mov.w	r3, #4294967295
    2e66:	f7ff be43 	b.w	2af0 <oqWriteTimeout>
    2e6a:	bf00      	nop
    2e6c:	f3af 8000 	nop.w

00002e70 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    2e70:	300c      	adds	r0, #12
    2e72:	f7ff bcd5 	b.w	2820 <iqGetTimeout>
    2e76:	bf00      	nop
    2e78:	f3af 8000 	nop.w
    2e7c:	f3af 8000 	nop.w

00002e80 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    2e80:	300c      	adds	r0, #12
    2e82:	f04f 31ff 	mov.w	r1, #4294967295
    2e86:	f7ff bccb 	b.w	2820 <iqGetTimeout>
    2e8a:	bf00      	nop
    2e8c:	f3af 8000 	nop.w

00002e90 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    2e90:	3030      	adds	r0, #48	; 0x30
    2e92:	f7ff bdb5 	b.w	2a00 <oqPutTimeout>
    2e96:	bf00      	nop
    2e98:	f3af 8000 	nop.w
    2e9c:	f3af 8000 	nop.w

00002ea0 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    2ea0:	3030      	adds	r0, #48	; 0x30
    2ea2:	f04f 32ff 	mov.w	r2, #4294967295
    2ea6:	f7ff bdab 	b.w	2a00 <oqPutTimeout>
    2eaa:	bf00      	nop
    2eac:	f3af 8000 	nop.w

00002eb0 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    2eb0:	f000 bc76 	b.w	37a0 <sd_lld_init>
    2eb4:	f3af 8000 	nop.w
    2eb8:	f3af 8000 	nop.w
    2ebc:	f3af 8000 	nop.w

00002ec0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    2ec0:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
    2ec2:	4b0e      	ldr	r3, [pc, #56]	; (2efc <sdObjectInit+0x3c>)
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    2ec4:	4604      	mov	r4, r0
    2ec6:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
    2ec8:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    2ecc:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2ece:	9400      	str	r4, [sp, #0]
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    2ed0:	460b      	mov	r3, r1
    2ed2:	4615      	mov	r5, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
    2ed4:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2ed6:	f104 0154 	add.w	r1, r4, #84	; 0x54
    2eda:	f104 000c 	add.w	r0, r4, #12
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    2ede:	60a6      	str	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2ee0:	2210      	movs	r2, #16
    2ee2:	f7ff fc65 	bl	27b0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    2ee6:	9400      	str	r4, [sp, #0]
    2ee8:	462b      	mov	r3, r5
    2eea:	f104 0030 	add.w	r0, r4, #48	; 0x30
    2eee:	f104 0164 	add.w	r1, r4, #100	; 0x64
    2ef2:	2210      	movs	r2, #16
    2ef4:	f7ff fd74 	bl	29e0 <oqObjectInit>
}
    2ef8:	b002      	add	sp, #8
    2efa:	bd70      	pop	{r4, r5, r6, pc}
    2efc:	00006da0 	.word	0x00006da0

00002f00 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    2f00:	b538      	push	{r3, r4, r5, lr}
    2f02:	460d      	mov	r5, r1

  osalDbgCheck(sdp != NULL);
    2f04:	4604      	mov	r4, r0
    2f06:	b338      	cbz	r0, 2f58 <sdStart+0x58>
    2f08:	2320      	movs	r3, #32
    2f0a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2f0e:	f7fe fecf 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2f12:	f7fe f88d 	bl	1030 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    2f16:	68a3      	ldr	r3, [r4, #8]
    2f18:	3b01      	subs	r3, #1
    2f1a:	2b01      	cmp	r3, #1
    2f1c:	d902      	bls.n	2f24 <sdStart+0x24>
    2f1e:	4810      	ldr	r0, [pc, #64]	; (2f60 <sdStart+0x60>)
    2f20:	f7fe f82e 	bl	f80 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
    2f24:	4629      	mov	r1, r5
    2f26:	4620      	mov	r0, r4
    2f28:	f000 fc7a 	bl	3820 <sd_lld_start>
  sdp->state = SD_READY;
    2f2c:	2302      	movs	r3, #2
    2f2e:	60a3      	str	r3, [r4, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2f30:	f7fe f88e 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2f34:	f7fe fec4 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2f38:	4b0a      	ldr	r3, [pc, #40]	; (2f64 <sdStart+0x64>)
    2f3a:	681a      	ldr	r2, [r3, #0]
    2f3c:	429a      	cmp	r2, r3
    2f3e:	d007      	beq.n	2f50 <sdStart+0x50>
    2f40:	6999      	ldr	r1, [r3, #24]
    2f42:	6893      	ldr	r3, [r2, #8]
    2f44:	688a      	ldr	r2, [r1, #8]
    2f46:	429a      	cmp	r2, r3
    2f48:	d202      	bcs.n	2f50 <sdStart+0x50>
    2f4a:	4807      	ldr	r0, [pc, #28]	; (2f68 <sdStart+0x68>)
    2f4c:	f7fe f818 	bl	f80 <chSysHalt>
    2f50:	2300      	movs	r3, #0
    2f52:	f383 8811 	msr	BASEPRI, r3
    2f56:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {

  osalDbgCheck(sdp != NULL);
    2f58:	4801      	ldr	r0, [pc, #4]	; (2f60 <sdStart+0x60>)
    2f5a:	f7fe f811 	bl	f80 <chSysHalt>
    2f5e:	e7d3      	b.n	2f08 <sdStart+0x8>
    2f60:	00006d90 	.word	0x00006d90
    2f64:	1ffff228 	.word	0x1ffff228
    2f68:	00006d80 	.word	0x00006d80
    2f6c:	f3af 8000 	nop.w

00002f70 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    2f70:	f000 bcee 	b.w	3950 <spi_lld_init>
    2f74:	f3af 8000 	nop.w
    2f78:	f3af 8000 	nop.w
    2f7c:	f3af 8000 	nop.w

00002f80 <spiObjectInit>:
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
  spip->config = NULL;
    2f80:	2300      	movs	r3, #0
    2f82:	2201      	movs	r2, #1
    2f84:	e880 000c 	stmia.w	r0, {r2, r3}
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    2f88:	6083      	str	r3, [r0, #8]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    2f8a:	300c      	adds	r0, #12
    2f8c:	f7fe bf28 	b.w	1de0 <chMtxObjectInit>

00002f90 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    2f90:	b538      	push	{r3, r4, r5, lr}
    2f92:	460d      	mov	r5, r1

  osalDbgCheck((spip != NULL) && (config != NULL));
    2f94:	4604      	mov	r4, r0
    2f96:	b340      	cbz	r0, 2fea <spiStart+0x5a>
    2f98:	b339      	cbz	r1, 2fea <spiStart+0x5a>
    2f9a:	2320      	movs	r3, #32
    2f9c:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    2fa0:	f7fe fe86 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2fa4:	f7fe f844 	bl	1030 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    2fa8:	6823      	ldr	r3, [r4, #0]
    2faa:	3b01      	subs	r3, #1
    2fac:	2b01      	cmp	r3, #1
    2fae:	d902      	bls.n	2fb6 <spiStart+0x26>
    2fb0:	4810      	ldr	r0, [pc, #64]	; (2ff4 <spiStart+0x64>)
    2fb2:	f7fd ffe5 	bl	f80 <chSysHalt>
                "invalid state");
  spip->config = config;
  spi_lld_start(spip);
    2fb6:	4620      	mov	r0, r4
  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    2fb8:	6065      	str	r5, [r4, #4]
  spi_lld_start(spip);
    2fba:	f000 fcd1 	bl	3960 <spi_lld_start>
  spip->state = SPI_READY;
    2fbe:	2302      	movs	r3, #2
    2fc0:	6023      	str	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    2fc2:	f7fe f845 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2fc6:	f7fe fe7b 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2fca:	4b0b      	ldr	r3, [pc, #44]	; (2ff8 <spiStart+0x68>)
    2fcc:	681a      	ldr	r2, [r3, #0]
    2fce:	429a      	cmp	r2, r3
    2fd0:	d007      	beq.n	2fe2 <spiStart+0x52>
    2fd2:	6999      	ldr	r1, [r3, #24]
    2fd4:	6893      	ldr	r3, [r2, #8]
    2fd6:	688a      	ldr	r2, [r1, #8]
    2fd8:	429a      	cmp	r2, r3
    2fda:	d202      	bcs.n	2fe2 <spiStart+0x52>
    2fdc:	4807      	ldr	r0, [pc, #28]	; (2ffc <spiStart+0x6c>)
    2fde:	f7fd ffcf 	bl	f80 <chSysHalt>
    2fe2:	2300      	movs	r3, #0
    2fe4:	f383 8811 	msr	BASEPRI, r3
    2fe8:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {

  osalDbgCheck((spip != NULL) && (config != NULL));
    2fea:	4802      	ldr	r0, [pc, #8]	; (2ff4 <spiStart+0x64>)
    2fec:	f7fd ffc8 	bl	f80 <chSysHalt>
    2ff0:	e7d3      	b.n	2f9a <spiStart+0xa>
    2ff2:	bf00      	nop
    2ff4:	00006dd0 	.word	0x00006dd0
    2ff8:	1ffff228 	.word	0x1ffff228
    2ffc:	00006dc0 	.word	0x00006dc0

00003000 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
    3000:	b510      	push	{r4, lr}

  osalDbgCheck(spip != NULL);
    3002:	4604      	mov	r4, r0
    3004:	b318      	cbz	r0, 304e <spiSelect+0x4e>
    3006:	2320      	movs	r3, #32
    3008:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    300c:	f7fe fe50 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    3010:	f7fe f80e 	bl	1030 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
    3014:	6823      	ldr	r3, [r4, #0]
    3016:	2b02      	cmp	r3, #2
    3018:	d002      	beq.n	3020 <spiSelect+0x20>
    301a:	480f      	ldr	r0, [pc, #60]	; (3058 <spiSelect+0x58>)
    301c:	f7fd ffb0 	bl	f80 <chSysHalt>
  spiSelectI(spip);
    3020:	4620      	mov	r0, r4
    3022:	f000 fd35 	bl	3a90 <spi_lld_select>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    3026:	f7fe f813 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    302a:	f7fe fe49 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    302e:	4b0b      	ldr	r3, [pc, #44]	; (305c <spiSelect+0x5c>)
    3030:	681a      	ldr	r2, [r3, #0]
    3032:	429a      	cmp	r2, r3
    3034:	d007      	beq.n	3046 <spiSelect+0x46>
    3036:	6999      	ldr	r1, [r3, #24]
    3038:	6893      	ldr	r3, [r2, #8]
    303a:	688a      	ldr	r2, [r1, #8]
    303c:	429a      	cmp	r2, r3
    303e:	d202      	bcs.n	3046 <spiSelect+0x46>
    3040:	4807      	ldr	r0, [pc, #28]	; (3060 <spiSelect+0x60>)
    3042:	f7fd ff9d 	bl	f80 <chSysHalt>
    3046:	2300      	movs	r3, #0
    3048:	f383 8811 	msr	BASEPRI, r3
    304c:	bd10      	pop	{r4, pc}
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
    304e:	4802      	ldr	r0, [pc, #8]	; (3058 <spiSelect+0x58>)
    3050:	f7fd ff96 	bl	f80 <chSysHalt>
    3054:	e7d7      	b.n	3006 <spiSelect+0x6>
    3056:	bf00      	nop
    3058:	00006de0 	.word	0x00006de0
    305c:	1ffff228 	.word	0x1ffff228
    3060:	00006dc0 	.word	0x00006dc0
    3064:	f3af 8000 	nop.w
    3068:	f3af 8000 	nop.w
    306c:	f3af 8000 	nop.w

00003070 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
    3070:	b510      	push	{r4, lr}

  osalDbgCheck(spip != NULL);
    3072:	4604      	mov	r4, r0
    3074:	b318      	cbz	r0, 30be <spiUnselect+0x4e>
    3076:	2320      	movs	r3, #32
    3078:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    307c:	f7fe fe18 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    3080:	f7fd ffd6 	bl	1030 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
    3084:	6823      	ldr	r3, [r4, #0]
    3086:	2b02      	cmp	r3, #2
    3088:	d002      	beq.n	3090 <spiUnselect+0x20>
    308a:	480f      	ldr	r0, [pc, #60]	; (30c8 <spiUnselect+0x58>)
    308c:	f7fd ff78 	bl	f80 <chSysHalt>
  spiUnselectI(spip);
    3090:	4620      	mov	r0, r4
    3092:	f000 fd05 	bl	3aa0 <spi_lld_unselect>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    3096:	f7fd ffdb 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    309a:	f7fe fe11 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    309e:	4b0b      	ldr	r3, [pc, #44]	; (30cc <spiUnselect+0x5c>)
    30a0:	681a      	ldr	r2, [r3, #0]
    30a2:	429a      	cmp	r2, r3
    30a4:	d007      	beq.n	30b6 <spiUnselect+0x46>
    30a6:	6999      	ldr	r1, [r3, #24]
    30a8:	6893      	ldr	r3, [r2, #8]
    30aa:	688a      	ldr	r2, [r1, #8]
    30ac:	429a      	cmp	r2, r3
    30ae:	d202      	bcs.n	30b6 <spiUnselect+0x46>
    30b0:	4807      	ldr	r0, [pc, #28]	; (30d0 <spiUnselect+0x60>)
    30b2:	f7fd ff65 	bl	f80 <chSysHalt>
    30b6:	2300      	movs	r3, #0
    30b8:	f383 8811 	msr	BASEPRI, r3
    30bc:	bd10      	pop	{r4, pc}
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
    30be:	4802      	ldr	r0, [pc, #8]	; (30c8 <spiUnselect+0x58>)
    30c0:	f7fd ff5e 	bl	f80 <chSysHalt>
    30c4:	e7d7      	b.n	3076 <spiUnselect+0x6>
    30c6:	bf00      	nop
    30c8:	00006df0 	.word	0x00006df0
    30cc:	1ffff228 	.word	0x1ffff228
    30d0:	00006dc0 	.word	0x00006dc0
    30d4:	f3af 8000 	nop.w
    30d8:	f3af 8000 	nop.w
    30dc:	f3af 8000 	nop.w

000030e0 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    30e0:	0943      	lsrs	r3, r0, #5
    30e2:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    30e4:	b410      	push	{r4}
    30e6:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
    30ea:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
    30ee:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
    30f2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    30f6:	0109      	lsls	r1, r1, #4
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    30f8:	f000 001f 	and.w	r0, r0, #31
    30fc:	2201      	movs	r2, #1
    30fe:	4082      	lsls	r2, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
    3100:	b2c9      	uxtb	r1, r1
    3102:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    3106:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
    310a:	601a      	str	r2, [r3, #0]
}
    310c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3110:	4770      	bx	lr
    3112:	bf00      	nop
    3114:	f3af 8000 	nop.w
    3118:	f3af 8000 	nop.w
    311c:	f3af 8000 	nop.w

00003120 <nvicDisableVector>:
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
    3120:	4908      	ldr	r1, [pc, #32]	; (3144 <nvicDisableVector+0x24>)
    3122:	0943      	lsrs	r3, r0, #5
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
    3124:	b410      	push	{r4}

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
    3126:	3320      	adds	r3, #32
    3128:	f000 041f 	and.w	r4, r0, #31
    312c:	2201      	movs	r2, #1
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
    312e:	4408      	add	r0, r1
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
    3130:	40a2      	lsls	r2, r4
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
    3132:	2400      	movs	r4, #0
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
    3134:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
    3138:	f880 4300 	strb.w	r4, [r0, #768]	; 0x300
#endif
}
    313c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3140:	4770      	bx	lr
    3142:	bf00      	nop
    3144:	e000e100 	.word	0xe000e100
    3148:	f3af 8000 	nop.w
    314c:	f3af 8000 	nop.w

00003150 <nvicSetSystemHandlerPriority>:
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {

  osalDbgCheck(handler < 12U);
    3150:	280b      	cmp	r0, #11
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
    3152:	b538      	push	{r3, r4, r5, lr}
    3154:	4604      	mov	r4, r0
    3156:	460d      	mov	r5, r1

  osalDbgCheck(handler < 12U);
    3158:	d902      	bls.n	3160 <nvicSetSystemHandlerPriority+0x10>
    315a:	4805      	ldr	r0, [pc, #20]	; (3170 <nvicSetSystemHandlerPriority+0x20>)
    315c:	f7fd ff10 	bl	f80 <chSysHalt>
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
    3160:	f104 4060 	add.w	r0, r4, #3758096384	; 0xe0000000
    3164:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
    3168:	012d      	lsls	r5, r5, #4
    316a:	b2ed      	uxtb	r5, r5
    316c:	7605      	strb	r5, [r0, #24]
    316e:	bd38      	pop	{r3, r4, r5, pc}
    3170:	00006e00 	.word	0x00006e00
    3174:	f3af 8000 	nop.w
    3178:	f3af 8000 	nop.w
    317c:	f3af 8000 	nop.w

00003180 <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 * @todo    Use a macro to define the system clock frequency.
 *
 * @notapi
 */
void hal_lld_init(void) {
    3180:	4770      	bx	lr
    3182:	bf00      	nop
    3184:	f3af 8000 	nop.w
    3188:	f3af 8000 	nop.w
    318c:	f3af 8000 	nop.w

00003190 <k22x_clock_init>:
 * @special
 */
void k22x_clock_init(void) {
#if !KINETIS_NO_INIT
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
    3190:	4958      	ldr	r1, [pc, #352]	; (32f4 <k22x_clock_init+0x164>)
#endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */

  /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
    3192:	4b59      	ldr	r3, [pc, #356]	; (32f8 <k22x_clock_init+0x168>)
 * @special
 */
void k22x_clock_init(void) {
#if !KINETIS_NO_INIT
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
    3194:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
                 WDOG_STCTRLH_ALLOWUPDATE_MASK |
                 WDOG_STCTRLH_CLKSRC_MASK |
                 0x0100U;

#ifdef CLOCK_SETUP
  if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
    3198:	4858      	ldr	r0, [pc, #352]	; (32fc <k22x_clock_init+0x16c>)
 *          @p board.c.
 * @todo    This function needs to be more generic.
 *
 * @special
 */
void k22x_clock_init(void) {
    319a:	b4f0      	push	{r4, r5, r6, r7}
#if !KINETIS_NO_INIT
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
    319c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
#endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */

  /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
    31a0:	f24c 5620 	movw	r6, #50464	; 0xc520
  /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
    31a4:	f64d 1528 	movw	r5, #55592	; 0xd928
  /* WDOG->STCTRLH: ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
  WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |
    31a8:	f44f 74e9 	mov.w	r4, #466	; 0x1d2
 * @special
 */
void k22x_clock_init(void) {
#if !KINETIS_NO_INIT
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
    31ac:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
#endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */

  /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
    31b0:	81de      	strh	r6, [r3, #14]
  /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
    31b2:	81dd      	strh	r5, [r3, #14]
  /* WDOG->STCTRLH: ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
  WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |
    31b4:	801c      	strh	r4, [r3, #0]
                 WDOG_STCTRLH_ALLOWUPDATE_MASK |
                 WDOG_STCTRLH_CLKSRC_MASK |
                 0x0100U;

#ifdef CLOCK_SETUP
  if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
    31b6:	7803      	ldrb	r3, [r0, #0]
    31b8:	07d8      	lsls	r0, r3, #31
    31ba:	d57b      	bpl.n	32b4 <k22x_clock_init+0x124>
  {
    if((PMC->REGSC & PMC_REGSC_ACKISO_MASK) != 0x00U)
    31bc:	4b50      	ldr	r3, [pc, #320]	; (3300 <k22x_clock_init+0x170>)
    31be:	789a      	ldrb	r2, [r3, #2]
    31c0:	0711      	lsls	r1, r2, #28
    31c2:	f100 8092 	bmi.w	32ea <k22x_clock_init+0x15a>
#endif
  }

  /* Power mode protection initialization */
#ifdef SYSTEM_SMC_PMPROT_VALUE
  SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
    31c6:	4b4f      	ldr	r3, [pc, #316]	; (3304 <k22x_clock_init+0x174>)
    31c8:	22aa      	movs	r2, #170	; 0xaa
#endif

  /* High speed run mode enable */
#if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x03U << SMC_PMCTRL_RUNM_SHIFT))
  SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable HSRUN mode */
    31ca:	2160      	movs	r1, #96	; 0x60
#endif
  }

  /* Power mode protection initialization */
#ifdef SYSTEM_SMC_PMPROT_VALUE
  SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
    31cc:	701a      	strb	r2, [r3, #0]
#endif

  /* High speed run mode enable */
#if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x03U << SMC_PMCTRL_RUNM_SHIFT))
  SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable HSRUN mode */
  while(SMC->PMSTAT != 0x80U) {        /* Wait until the system is in HSRUN mode */
    31ce:	461a      	mov	r2, r3
  SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
#endif

  /* High speed run mode enable */
#if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x03U << SMC_PMCTRL_RUNM_SHIFT))
  SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable HSRUN mode */
    31d0:	7059      	strb	r1, [r3, #1]
  while(SMC->PMSTAT != 0x80U) {        /* Wait until the system is in HSRUN mode */
    31d2:	78d3      	ldrb	r3, [r2, #3]
    31d4:	b2db      	uxtb	r3, r3
    31d6:	2b80      	cmp	r3, #128	; 0x80
    31d8:	d1fb      	bne.n	31d2 <k22x_clock_init+0x42>
#if defined(SLOW_TRIM_ADDRESS)
  }
  #endif /* defined(SLOW_TRIM_ADDRESS) */

  /* Set system prescalers and clock sources */
  SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
    31da:	4a4b      	ldr	r2, [pc, #300]	; (3308 <k22x_clock_init+0x178>)
    31dc:	4f4b      	ldr	r7, [pc, #300]	; (330c <k22x_clock_init+0x17c>)
  /* Set MCG and OSC */
#if  (((SYSTEM_OSC_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)
  /* SIM_SCGC5: PORTA=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
  /* PORTA_PCR18: ISF=0,MUX=0 */
  PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    31de:	4d4c      	ldr	r5, [pc, #304]	; (3310 <k22x_clock_init+0x180>)
  if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS_MASK) != 0x00U) {
  /* PORTA_PCR19: ISF=0,MUX=0 */
  PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  }
#endif
  MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
    31e0:	494c      	ldr	r1, [pc, #304]	; (3314 <k22x_clock_init+0x184>)
  MCG->C2 = (MCG->C2 & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (SYSTEM_MCG_C2_VALUE & (uint8_t)(~(MCG_C2_LP_MASK))); /* Set C2 (freq. range, ext. and int. reference selection etc. excluding trim bits; low power bit is set later) */
  OSC->CR = SYSTEM_OSC_CR_VALUE;       /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    31e2:	4c4d      	ldr	r4, [pc, #308]	; (3318 <k22x_clock_init+0x188>)
#if defined(SLOW_TRIM_ADDRESS)
  }
  #endif /* defined(SLOW_TRIM_ADDRESS) */

  /* Set system prescalers and clock sources */
  SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
    31e4:	f241 0044 	movw	r0, #4164	; 0x1044
  SIM->SOPT1 = ((SIM->SOPT1) & (uint32_t)(~(SIM_SOPT1_OSC32KSEL_MASK))) | ((SYSTEM_SIM_SOPT1_VALUE) & (SIM_SOPT1_OSC32KSEL_MASK)); /* Set 32 kHz clock source (ERCLK32K) */
  SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_PLLFLLSEL_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_PLLFLLSEL_MASK)); /* Selects the high frequency clock for various peripheral clocking options. */
    31e8:	f241 0604 	movw	r6, #4100	; 0x1004
#if defined(SLOW_TRIM_ADDRESS)
  }
  #endif /* defined(SLOW_TRIM_ADDRESS) */

  /* Set system prescalers and clock sources */
  SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
    31ec:	5017      	str	r7, [r2, r0]
  SIM->SOPT1 = ((SIM->SOPT1) & (uint32_t)(~(SIM_SOPT1_OSC32KSEL_MASK))) | ((SYSTEM_SIM_SOPT1_VALUE) & (SIM_SOPT1_OSC32KSEL_MASK)); /* Set 32 kHz clock source (ERCLK32K) */
    31ee:	6810      	ldr	r0, [r2, #0]
    31f0:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
    31f4:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
    31f8:	6010      	str	r0, [r2, #0]
  SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_PLLFLLSEL_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_PLLFLLSEL_MASK)); /* Selects the high frequency clock for various peripheral clocking options. */
    31fa:	5990      	ldr	r0, [r2, r6]
    31fc:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
    3200:	5190      	str	r0, [r2, r6]

#else /* MCG_MODE */
  /* Set MCG and OSC */
#if  (((SYSTEM_OSC_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)
  /* SIM_SCGC5: PORTA=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
    3202:	f241 0638 	movw	r6, #4152	; 0x1038
  if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS_MASK) != 0x00U) {
  /* PORTA_PCR19: ISF=0,MUX=0 */
  PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  }
#endif
  MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
    3206:	2700      	movs	r7, #0

#else /* MCG_MODE */
  /* Set MCG and OSC */
#if  (((SYSTEM_OSC_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)
  /* SIM_SCGC5: PORTA=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
    3208:	5990      	ldr	r0, [r2, r6]
    320a:	f440 7000 	orr.w	r0, r0, #512	; 0x200
    320e:	5190      	str	r0, [r2, r6]
  /* PORTA_PCR18: ISF=0,MUX=0 */
  PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    3210:	6caa      	ldr	r2, [r5, #72]	; 0x48
    3212:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    3216:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    321a:	64aa      	str	r2, [r5, #72]	; 0x48
  if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS_MASK) != 0x00U) {
  /* PORTA_PCR19: ISF=0,MUX=0 */
  PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    321c:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    321e:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    3222:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3226:	64ea      	str	r2, [r5, #76]	; 0x4c
  }
#endif
  MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
    3228:	720f      	strb	r7, [r1, #8]
  MCG->C2 = (MCG->C2 & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (SYSTEM_MCG_C2_VALUE & (uint8_t)(~(MCG_C2_LP_MASK))); /* Set C2 (freq. range, ext. and int. reference selection etc. excluding trim bits; low power bit is set later) */
    322a:	784a      	ldrb	r2, [r1, #1]
    322c:	f002 029b 	and.w	r2, r2, #155	; 0x9b
    3230:	f042 0224 	orr.w	r2, r2, #36	; 0x24
  OSC->CR = SYSTEM_OSC_CR_VALUE;       /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
  MCG->C7 = SYSTEM_MCG_C7_VALUE;       /* Set C7 (OSC Clock Select) */
    3234:	2601      	movs	r6, #1
  MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    3236:	2502      	movs	r5, #2
  /* PORTA_PCR19: ISF=0,MUX=0 */
  PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  }
#endif
  MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
  MCG->C2 = (MCG->C2 & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (SYSTEM_MCG_C2_VALUE & (uint8_t)(~(MCG_C2_LP_MASK))); /* Set C2 (freq. range, ext. and int. reference selection etc. excluding trim bits; low power bit is set later) */
    3238:	704a      	strb	r2, [r1, #1]
  /* Check that the source of the FLL reference clock is the requested one. */
  if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
    while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
    }
  } else {
    while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
    323a:	4608      	mov	r0, r1
  PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  }
#endif
  MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
  MCG->C2 = (MCG->C2 & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (SYSTEM_MCG_C2_VALUE & (uint8_t)(~(MCG_C2_LP_MASK))); /* Set C2 (freq. range, ext. and int. reference selection etc. excluding trim bits; low power bit is set later) */
  OSC->CR = SYSTEM_OSC_CR_VALUE;       /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    323c:	7023      	strb	r3, [r4, #0]
  MCG->C7 = SYSTEM_MCG_C7_VALUE;       /* Set C7 (OSC Clock Select) */
    323e:	730e      	strb	r6, [r1, #12]
  MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    3240:	700d      	strb	r5, [r1, #0]
  /* Check that the source of the FLL reference clock is the requested one. */
  if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
    while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
    }
  } else {
    while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
    3242:	7983      	ldrb	r3, [r0, #6]
    3244:	4a33      	ldr	r2, [pc, #204]	; (3314 <k22x_clock_init+0x184>)
    3246:	f003 0310 	and.w	r3, r3, #16
    324a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    324e:	2b00      	cmp	r3, #0
    3250:	d1f7      	bne.n	3242 <k22x_clock_init+0xb2>
    }
  }
  MCG->C4 = ((SYSTEM_MCG_C4_VALUE)  & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
    3252:	78d3      	ldrb	r3, [r2, #3]
    3254:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
    3258:	70d3      	strb	r3, [r2, #3]

#if (MCG_MODE == MCG_MODE_BLPE)
  MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
#endif
#if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
    325a:	4610      	mov	r0, r2
  MCG->C4 = ((SYSTEM_MCG_C4_VALUE)  & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
#endif /* MCG_MODE */

  /* Common for all MCG modes */

  MCG->C6 = SYSTEM_MCG_C6_VALUE;
    325c:	7151      	strb	r1, [r2, #5]

#if (MCG_MODE == MCG_MODE_BLPE)
  MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
#endif
#if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
    325e:	7983      	ldrb	r3, [r0, #6]
    3260:	f013 030c 	ands.w	r3, r3, #12
    3264:	d1fb      	bne.n	325e <k22x_clock_init+0xce>
  }
  /* Use LPTMR to wait for 1ms for FLL clock stabilization */
  SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
    3266:	4c28      	ldr	r4, [pc, #160]	; (3308 <k22x_clock_init+0x178>)
  LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
    3268:	4a2c      	ldr	r2, [pc, #176]	; (331c <k22x_clock_init+0x18c>)
#endif
#if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
  }
  /* Use LPTMR to wait for 1ms for FLL clock stabilization */
  SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
    326a:	f241 0038 	movw	r0, #4152	; 0x1038
  LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
    326e:	2780      	movs	r7, #128	; 0x80
#endif
#if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
  }
  /* Use LPTMR to wait for 1ms for FLL clock stabilization */
  SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
    3270:	5821      	ldr	r1, [r4, r0]
  LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
    3272:	2605      	movs	r6, #5
#endif
#if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
  }
  /* Use LPTMR to wait for 1ms for FLL clock stabilization */
  SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
    3274:	f041 0101 	orr.w	r1, r1, #1
  LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
  LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
    3278:	2501      	movs	r5, #1
#endif
#if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
  }
  /* Use LPTMR to wait for 1ms for FLL clock stabilization */
  SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
    327a:	5021      	str	r1, [r4, r0]
  LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
    327c:	6093      	str	r3, [r2, #8]
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
  LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
  while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
    327e:	4611      	mov	r1, r2
  while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
  }
  /* Use LPTMR to wait for 1ms for FLL clock stabilization */
  SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
  LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
    3280:	6017      	str	r7, [r2, #0]
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
    3282:	6056      	str	r6, [r2, #4]
  LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
    3284:	6015      	str	r5, [r2, #0]
  while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
    3286:	680b      	ldr	r3, [r1, #0]
    3288:	4a24      	ldr	r2, [pc, #144]	; (331c <k22x_clock_init+0x18c>)
    328a:	061b      	lsls	r3, r3, #24
    328c:	d5fb      	bpl.n	3286 <k22x_clock_init+0xf6>
  }
  LPTMR0_CSR = 0x00;                   /* Disable LPTMR */
  SIM_SCGC5 &= (uint32_t)~(uint32_t)SIM_SCGC5_LPTMR_MASK;
    328e:	491e      	ldr	r1, [pc, #120]	; (3308 <k22x_clock_init+0x178>)
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
  LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
  while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
  }
  LPTMR0_CSR = 0x00;                   /* Disable LPTMR */
    3290:	2300      	movs	r3, #0
  SIM_SCGC5 &= (uint32_t)~(uint32_t)SIM_SCGC5_LPTMR_MASK;
    3292:	f241 0038 	movw	r0, #4152	; 0x1038
  LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
  LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
  while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
  }
  LPTMR0_CSR = 0x00;                   /* Disable LPTMR */
    3296:	6013      	str	r3, [r2, #0]
  SIM_SCGC5 &= (uint32_t)~(uint32_t)SIM_SCGC5_LPTMR_MASK;
    3298:	580b      	ldr	r3, [r1, r0]
    329a:	f023 0301 	bic.w	r3, r3, #1
  while(SMC->PMSTAT != 0x04U) {        /* Wait until the system is in VLPR mode */
  }
#endif

#if defined(SYSTEM_SIM_CLKDIV2_VALUE)
  SIM->CLKDIV2 = ((SIM->CLKDIV2) & (uint32_t)(~(SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK))) | ((SYSTEM_SIM_CLKDIV2_VALUE) & (SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK)); /* Selects the USB clock divider. */
    329e:	f241 0248 	movw	r2, #4168	; 0x1048
  LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
  LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
  while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
  }
  LPTMR0_CSR = 0x00;                   /* Disable LPTMR */
  SIM_SCGC5 &= (uint32_t)~(uint32_t)SIM_SCGC5_LPTMR_MASK;
    32a2:	500b      	str	r3, [r1, r0]
  while(SMC->PMSTAT != 0x04U) {        /* Wait until the system is in VLPR mode */
  }
#endif

#if defined(SYSTEM_SIM_CLKDIV2_VALUE)
  SIM->CLKDIV2 = ((SIM->CLKDIV2) & (uint32_t)(~(SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK))) | ((SYSTEM_SIM_CLKDIV2_VALUE) & (SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK)); /* Selects the USB clock divider. */
    32a4:	588b      	ldr	r3, [r1, r2]
    32a6:	f023 030f 	bic.w	r3, r3, #15
    32aa:	f043 0302 	orr.w	r3, r3, #2
    32ae:	508b      	str	r3, [r1, r2]
#endif
#endif
  
#endif /* !KINETIS_NO_INIT */
}
    32b0:	bcf0      	pop	{r4, r5, r6, r7}
    32b2:	4770      	bx	lr
    {
       PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
    }
  } else {
#ifdef SYSTEM_RTC_CR_VALUE
    SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
    32b4:	4814      	ldr	r0, [pc, #80]	; (3308 <k22x_clock_init+0x178>)
    if ((RTC_CR & RTC_CR_OSCE_MASK) == 0x00U) { /* Only if the OSCILLATOR is not already enabled */
    32b6:	4b1a      	ldr	r3, [pc, #104]	; (3320 <k22x_clock_init+0x190>)
    {
       PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
    }
  } else {
#ifdef SYSTEM_RTC_CR_VALUE
    SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
    32b8:	f241 013c 	movw	r1, #4156	; 0x103c
    32bc:	5842      	ldr	r2, [r0, r1]
    32be:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
    32c2:	5042      	str	r2, [r0, r1]
    if ((RTC_CR & RTC_CR_OSCE_MASK) == 0x00U) { /* Only if the OSCILLATOR is not already enabled */
    32c4:	691a      	ldr	r2, [r3, #16]
    32c6:	05d2      	lsls	r2, r2, #23
    32c8:	f53f af7d 	bmi.w	31c6 <k22x_clock_init+0x36>
      RTC_CR = (uint32_t)((RTC_CR & (uint32_t)~(uint32_t)(RTC_CR_SC2P_MASK | RTC_CR_SC4P_MASK | RTC_CR_SC8P_MASK | RTC_CR_SC16P_MASK)) | (uint32_t)SYSTEM_RTC_CR_VALUE);
    32cc:	691a      	ldr	r2, [r3, #16]
    32ce:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    32d2:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    32d6:	611a      	str	r2, [r3, #16]
      RTC_CR |= (uint32_t)RTC_CR_OSCE_MASK;
    32d8:	691a      	ldr	r2, [r3, #16]
    32da:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    32de:	611a      	str	r2, [r3, #16]
      RTC_CR &= (uint32_t)~(uint32_t)RTC_CR_CLKO_MASK;
    32e0:	691a      	ldr	r2, [r3, #16]
    32e2:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    32e6:	611a      	str	r2, [r3, #16]
    32e8:	e76d      	b.n	31c6 <k22x_clock_init+0x36>
#ifdef CLOCK_SETUP
  if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
  {
    if((PMC->REGSC & PMC_REGSC_ACKISO_MASK) != 0x00U)
    {
       PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
    32ea:	789a      	ldrb	r2, [r3, #2]
    32ec:	f042 0208 	orr.w	r2, r2, #8
    32f0:	709a      	strb	r2, [r3, #2]
    32f2:	e768      	b.n	31c6 <k22x_clock_init+0x36>
    32f4:	e000ed00 	.word	0xe000ed00
    32f8:	40052000 	.word	0x40052000
    32fc:	4007f000 	.word	0x4007f000
    3300:	4007d000 	.word	0x4007d000
    3304:	4007e000 	.word	0x4007e000
    3308:	40047000 	.word	0x40047000
    330c:	01030000 	.word	0x01030000
    3310:	40049000 	.word	0x40049000
    3314:	40064000 	.word	0x40064000
    3318:	40065000 	.word	0x40065000
    331c:	40040000 	.word	0x40040000
    3320:	4003d000 	.word	0x4003d000
    3324:	f3af 8000 	nop.w
    3328:	f3af 8000 	nop.w
    332c:	f3af 8000 	nop.w

00003330 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate (void) {

  uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
  uint16_t Divider;

  if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U) {
    3330:	4b51      	ldr	r3, [pc, #324]	; (3478 <SystemCoreClockUpdate+0x148>)
    3332:	781a      	ldrb	r2, [r3, #0]
    3334:	f012 0fc0 	tst.w	r2, #192	; 0xc0
    /* FLL is selected */
    if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
    3338:	781a      	ldrb	r2, [r3, #0]
void SystemCoreClockUpdate (void) {

  uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
  uint16_t Divider;

  if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U) {
    333a:	d120      	bne.n	337e <SystemCoreClockUpdate+0x4e>
    /* FLL is selected */
    if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
    333c:	0751      	lsls	r1, r2, #29
    333e:	d528      	bpl.n	3392 <SystemCoreClockUpdate+0x62>
      } else {/* ((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) */
        Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
      }
      MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
    } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
    3340:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
    /* Select correct multiplier to calculate the MCG output clock  */
    switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
    3344:	4a4c      	ldr	r2, [pc, #304]	; (3478 <SystemCoreClockUpdate+0x148>)
    3346:	78d2      	ldrb	r2, [r2, #3]
    3348:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
    334c:	2a60      	cmp	r2, #96	; 0x60
    334e:	d07c      	beq.n	344a <SystemCoreClockUpdate+0x11a>
    3350:	d94f      	bls.n	33f2 <SystemCoreClockUpdate+0xc2>
    3352:	2aa0      	cmp	r2, #160	; 0xa0
    3354:	d048      	beq.n	33e8 <SystemCoreClockUpdate+0xb8>
    3356:	d96c      	bls.n	3432 <SystemCoreClockUpdate+0x102>
    3358:	2ac0      	cmp	r2, #192	; 0xc0
    335a:	d071      	beq.n	3440 <SystemCoreClockUpdate+0x110>
    335c:	2ae0      	cmp	r2, #224	; 0xe0
    335e:	d103      	bne.n	3368 <SystemCoreClockUpdate+0x38>
        break;
      case 0xC0U:
        MCGOUTClock *= 2197U;
        break;
      case 0xE0U:
        MCGOUTClock *= 2929U;
    3360:	f640 3271 	movw	r2, #2929	; 0xb71
    3364:	fb02 f303 	mul.w	r3, r2, r3
    }
  } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
    /* Reserved value */
    return;
  } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
  SystemCoreClock = (MCGOUTClock / (0x01U + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
    3368:	4844      	ldr	r0, [pc, #272]	; (347c <SystemCoreClockUpdate+0x14c>)
    336a:	4945      	ldr	r1, [pc, #276]	; (3480 <SystemCoreClockUpdate+0x150>)
    336c:	f241 0244 	movw	r2, #4164	; 0x1044
    3370:	5882      	ldr	r2, [r0, r2]
    3372:	0f12      	lsrs	r2, r2, #28
    3374:	3201      	adds	r2, #1
    3376:	fbb3 f3f2 	udiv	r3, r3, r2
    337a:	600b      	str	r3, [r1, #0]
    337c:	4770      	bx	lr
        MCGOUTClock *= 2929U;
        break;
      default:
        break;
    }
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
    337e:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
    3382:	2a40      	cmp	r2, #64	; 0x40
    3384:	d022      	beq.n	33cc <SystemCoreClockUpdate+0x9c>
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
    } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
      Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
      MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
    } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U) {
    3386:	781a      	ldrb	r2, [r3, #0]
    3388:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
    338c:	2a80      	cmp	r2, #128	; 0x80
    338e:	d043      	beq.n	3418 <SystemCoreClockUpdate+0xe8>
    3390:	4770      	bx	lr

  if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U) {
    /* FLL is selected */
    if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
      /* External reference clock is selected */
      switch (MCG->C7 & MCG_C7_OSCSEL_MASK) {
    3392:	7b1b      	ldrb	r3, [r3, #12]
    3394:	f013 0303 	ands.w	r3, r3, #3
    3398:	d024      	beq.n	33e4 <SystemCoreClockUpdate+0xb4>
      case 0x01U:
        MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
        break;
      case 0x02U:
      default:
        MCGOUTClock = CPU_INT_IRC_CLK_HZ; /* IRC 48MHz oscillator drives MCG clock */
    339a:	2b01      	cmp	r3, #1
    339c:	4a39      	ldr	r2, [pc, #228]	; (3484 <SystemCoreClockUpdate+0x154>)
    339e:	bf08      	it	eq
    33a0:	f44f 4200 	moveq.w	r2, #32768	; 0x8000
        break;
      }
      if (((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) && ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x01U)) {
    33a4:	4b34      	ldr	r3, [pc, #208]	; (3478 <SystemCoreClockUpdate+0x148>)
    33a6:	7859      	ldrb	r1, [r3, #1]
    33a8:	f011 0f30 	tst.w	r1, #48	; 0x30
    33ac:	d02b      	beq.n	3406 <SystemCoreClockUpdate+0xd6>
    33ae:	7b19      	ldrb	r1, [r3, #12]
    33b0:	f001 0103 	and.w	r1, r1, #3
    33b4:	2901      	cmp	r1, #1
    33b6:	d026      	beq.n	3406 <SystemCoreClockUpdate+0xd6>
        switch (MCG->C1 & MCG_C1_FRDIV_MASK) {
    33b8:	7819      	ldrb	r1, [r3, #0]
    33ba:	f001 0138 	and.w	r1, r1, #56	; 0x38
    33be:	2930      	cmp	r1, #48	; 0x30
    33c0:	d057      	beq.n	3472 <SystemCoreClockUpdate+0x142>
    33c2:	2938      	cmp	r1, #56	; 0x38
    33c4:	d14d      	bne.n	3462 <SystemCoreClockUpdate+0x132>
    33c6:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    33ca:	e022      	b.n	3412 <SystemCoreClockUpdate+0xe2>
      default:
        break;
    }
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
    /* Internal reference clock is selected */
    if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U) {
    33cc:	785a      	ldrb	r2, [r3, #1]
    33ce:	07d2      	lsls	r2, r2, #31
    33d0:	d52c      	bpl.n	342c <SystemCoreClockUpdate+0xfc>
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
    } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
      Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
    33d2:	7a19      	ldrb	r1, [r3, #8]
      MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
    33d4:	4a2c      	ldr	r2, [pc, #176]	; (3488 <SystemCoreClockUpdate+0x158>)
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
    /* Internal reference clock is selected */
    if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U) {
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
    } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
      Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
    33d6:	f3c1 0142 	ubfx	r1, r1, #1, #3
    33da:	2301      	movs	r3, #1
    33dc:	408b      	lsls	r3, r1
      MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
    33de:	fbb2 f3f3 	udiv	r3, r2, r3
    33e2:	e7c1      	b.n	3368 <SystemCoreClockUpdate+0x38>
    /* FLL is selected */
    if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
      /* External reference clock is selected */
      switch (MCG->C7 & MCG_C7_OSCSEL_MASK) {
      case 0x00U:
        MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
    33e4:	4a29      	ldr	r2, [pc, #164]	; (348c <SystemCoreClockUpdate+0x15c>)
    33e6:	e7dd      	b.n	33a4 <SystemCoreClockUpdate+0x74>
        break;
      case 0x80U:
        MCGOUTClock *= 732U;
        break;
      case 0xA0U:
        MCGOUTClock *= 1464U;
    33e8:	f44f 62b7 	mov.w	r2, #1464	; 0x5b8
    33ec:	fb02 f303 	mul.w	r3, r2, r3
        break;
    33f0:	e7ba      	b.n	3368 <SystemCoreClockUpdate+0x38>
      MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
    } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
    } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
    /* Select correct multiplier to calculate the MCG output clock  */
    switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
    33f2:	2a20      	cmp	r2, #32
    33f4:	d031      	beq.n	345a <SystemCoreClockUpdate+0x12a>
    33f6:	2a40      	cmp	r2, #64	; 0x40
    33f8:	d02b      	beq.n	3452 <SystemCoreClockUpdate+0x122>
    33fa:	2a00      	cmp	r2, #0
    33fc:	d1b4      	bne.n	3368 <SystemCoreClockUpdate+0x38>
      case 0x00U:
        MCGOUTClock *= 640U;
    33fe:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    3402:	01db      	lsls	r3, r3, #7
        break;
    3404:	e7b0      	b.n	3368 <SystemCoreClockUpdate+0x38>
        default:
          Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
          break;
        }
      } else {/* ((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) */
        Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
    3406:	4b1c      	ldr	r3, [pc, #112]	; (3478 <SystemCoreClockUpdate+0x148>)
    3408:	7819      	ldrb	r1, [r3, #0]
    340a:	2301      	movs	r3, #1
    340c:	f3c1 01c2 	ubfx	r1, r1, #3, #3
    3410:	408b      	lsls	r3, r1
      }
      MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
    3412:	fbb2 f3f3 	udiv	r3, r2, r3
    3416:	e795      	b.n	3344 <SystemCoreClockUpdate+0x14>
      Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
      MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
    } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U) {
    /* External reference clock is selected */
    switch (MCG->C7 & MCG_C7_OSCSEL_MASK) {
    3418:	7b1b      	ldrb	r3, [r3, #12]
    341a:	f013 0203 	ands.w	r2, r3, #3
    341e:	d026      	beq.n	346e <SystemCoreClockUpdate+0x13e>
    case 0x01U:
      MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
      break;
    case 0x02U:
    default:
      MCGOUTClock = CPU_INT_IRC_CLK_HZ; /* IRC 48MHz oscillator drives MCG clock */
    3420:	2a01      	cmp	r2, #1
    3422:	4b18      	ldr	r3, [pc, #96]	; (3484 <SystemCoreClockUpdate+0x154>)
    3424:	bf08      	it	eq
    3426:	f44f 4300 	moveq.w	r3, #32768	; 0x8000
    342a:	e79d      	b.n	3368 <SystemCoreClockUpdate+0x38>
        break;
    }
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
    /* Internal reference clock is selected */
    if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U) {
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
    342c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3430:	e79a      	b.n	3368 <SystemCoreClockUpdate+0x38>
      MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
    } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
      MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
    } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
    /* Select correct multiplier to calculate the MCG output clock  */
    switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
    3432:	2a80      	cmp	r2, #128	; 0x80
    3434:	d198      	bne.n	3368 <SystemCoreClockUpdate+0x38>
        break;
      case 0x60U:
        MCGOUTClock *= 2560U;
        break;
      case 0x80U:
        MCGOUTClock *= 732U;
    3436:	f44f 7237 	mov.w	r2, #732	; 0x2dc
    343a:	fb02 f303 	mul.w	r3, r2, r3
        break;
    343e:	e793      	b.n	3368 <SystemCoreClockUpdate+0x38>
      case 0xA0U:
        MCGOUTClock *= 1464U;
        break;
      case 0xC0U:
        MCGOUTClock *= 2197U;
    3440:	f640 0295 	movw	r2, #2197	; 0x895
    3444:	fb02 f303 	mul.w	r3, r2, r3
        break;
    3448:	e78e      	b.n	3368 <SystemCoreClockUpdate+0x38>
        break;
      case 0x40U:
        MCGOUTClock *= 1920U;
        break;
      case 0x60U:
        MCGOUTClock *= 2560U;
    344a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    344e:	025b      	lsls	r3, r3, #9
        break;
    3450:	e78a      	b.n	3368 <SystemCoreClockUpdate+0x38>
        break;
      case 0x20U:
        MCGOUTClock *= 1280U;
        break;
      case 0x40U:
        MCGOUTClock *= 1920U;
    3452:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
    3456:	01db      	lsls	r3, r3, #7
        break;
    3458:	e786      	b.n	3368 <SystemCoreClockUpdate+0x38>
    switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
      case 0x00U:
        MCGOUTClock *= 640U;
        break;
      case 0x20U:
        MCGOUTClock *= 1280U;
    345a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    345e:	021b      	lsls	r3, r3, #8
        break;
    3460:	e782      	b.n	3368 <SystemCoreClockUpdate+0x38>
          break;
        case 0x30U:
          Divider = 1280U;
          break;
        default:
          Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
    3462:	7819      	ldrb	r1, [r3, #0]
    3464:	2320      	movs	r3, #32
    3466:	f3c1 01c2 	ubfx	r1, r1, #3, #3
    346a:	408b      	lsls	r3, r1
          break;
    346c:	e7d1      	b.n	3412 <SystemCoreClockUpdate+0xe2>
    } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U) {
    /* External reference clock is selected */
    switch (MCG->C7 & MCG_C7_OSCSEL_MASK) {
    case 0x00U:
      MCGOUTClock = CPU_XTAL_CLK_HZ;   /* System oscillator drives MCG clock */
    346e:	4b07      	ldr	r3, [pc, #28]	; (348c <SystemCoreClockUpdate+0x15c>)
    3470:	e77a      	b.n	3368 <SystemCoreClockUpdate+0x38>
      default:
        MCGOUTClock = CPU_INT_IRC_CLK_HZ; /* IRC 48MHz oscillator drives MCG clock */
        break;
      }
      if (((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) && ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x01U)) {
        switch (MCG->C1 & MCG_C1_FRDIV_MASK) {
    3472:	f44f 63a0 	mov.w	r3, #1280	; 0x500
    3476:	e7cc      	b.n	3412 <SystemCoreClockUpdate+0xe2>
    3478:	40064000 	.word	0x40064000
    347c:	40047000 	.word	0x40047000
    3480:	1ffff000 	.word	0x1ffff000
    3484:	02dc6c00 	.word	0x02dc6c00
    3488:	003d0900 	.word	0x003d0900
    348c:	007a1200 	.word	0x007a1200

00003490 <_pal_lld_readpad>:
 * @notapi
 */
uint8_t _pal_lld_readpad(ioportid_t port,
                         uint8_t pad) {

  return (port->PDIR & ((uint32_t) 1 << pad)) ? PAL_HIGH : PAL_LOW;
    3490:	6900      	ldr	r0, [r0, #16]
    3492:	40c8      	lsrs	r0, r1
}
    3494:	f000 0001 	and.w	r0, r0, #1
    3498:	4770      	bx	lr
    349a:	bf00      	nop
    349c:	f3af 8000 	nop.w

000034a0 <_pal_lld_setpadmode>:
                         uint8_t pad,
                         iomode_t mode) {

  PORT_TypeDef *portcfg = NULL;

  osalDbgAssert(pad < PADS_PER_PORT, "pal_lld_setpadmode() #1, invalid pad");
    34a0:	291f      	cmp	r1, #31
 *
 * @notapi
 */
void _pal_lld_setpadmode(ioportid_t port,
                         uint8_t pad,
                         iomode_t mode) {
    34a2:	b570      	push	{r4, r5, r6, lr}
    34a4:	460e      	mov	r6, r1
    34a6:	4604      	mov	r4, r0
    34a8:	4615      	mov	r5, r2

  PORT_TypeDef *portcfg = NULL;

  osalDbgAssert(pad < PADS_PER_PORT, "pal_lld_setpadmode() #1, invalid pad");
    34aa:	d82c      	bhi.n	3506 <_pal_lld_setpadmode+0x66>

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
    34ac:	6962      	ldr	r2, [r4, #20]
    34ae:	2301      	movs	r3, #1
    34b0:	40b3      	lsls	r3, r6

  PORT_TypeDef *portcfg = NULL;

  osalDbgAssert(pad < PADS_PER_PORT, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    34b2:	2d06      	cmp	r5, #6
    port->PDDR |= ((uint32_t) 1 << pad);
    34b4:	bf0c      	ite	eq
    34b6:	4313      	orreq	r3, r2
  else
    port->PDDR &= ~((uint32_t) 1 << pad);
    34b8:	ea22 0303 	bicne.w	r3, r2, r3
    34bc:	6163      	str	r3, [r4, #20]

  if (port == IOPORT1)
    34be:	4b34      	ldr	r3, [pc, #208]	; (3590 <_pal_lld_setpadmode+0xf0>)
    34c0:	429c      	cmp	r4, r3
    34c2:	d05c      	beq.n	357e <_pal_lld_setpadmode+0xde>
    portcfg = PORTA;
  else if (port == IOPORT2)
    34c4:	3340      	adds	r3, #64	; 0x40
    34c6:	429c      	cmp	r4, r3
    34c8:	d05b      	beq.n	3582 <_pal_lld_setpadmode+0xe2>
    portcfg = PORTB;
  else if (port == IOPORT3)
    34ca:	3340      	adds	r3, #64	; 0x40
    34cc:	429c      	cmp	r4, r3
    34ce:	d05a      	beq.n	3586 <_pal_lld_setpadmode+0xe6>
    portcfg = PORTC;
  else if (port == IOPORT4)
    34d0:	3340      	adds	r3, #64	; 0x40
    34d2:	429c      	cmp	r4, r3
    34d4:	d059      	beq.n	358a <_pal_lld_setpadmode+0xea>
    portcfg = PORTD;
  else if (port == IOPORT5)
    34d6:	3340      	adds	r3, #64	; 0x40
    34d8:	429c      	cmp	r4, r3
    34da:	d04e      	beq.n	357a <_pal_lld_setpadmode+0xda>
    portcfg = PORTE;

  osalDbgAssert(portcfg != NULL, "pal_lld_setpadmode() #2, invalid port");
    34dc:	482d      	ldr	r0, [pc, #180]	; (3594 <_pal_lld_setpadmode+0xf4>)
    34de:	f7fd fd4f 	bl	f80 <chSysHalt>
 */
void _pal_lld_setpadmode(ioportid_t port,
                         uint8_t pad,
                         iomode_t mode) {

  PORT_TypeDef *portcfg = NULL;
    34e2:	2300      	movs	r3, #0
  else if (port == IOPORT5)
    portcfg = PORTE;

  osalDbgAssert(portcfg != NULL, "pal_lld_setpadmode() #2, invalid port");

  switch (mode) {
    34e4:	2d16      	cmp	r5, #22
    34e6:	d80d      	bhi.n	3504 <_pal_lld_setpadmode+0x64>
    34e8:	e8df f005 	tbb	[pc, r5]
    34ec:	20112511 	.word	0x20112511
    34f0:	1611251b 	.word	0x1611251b
    34f4:	0c0c0c0c 	.word	0x0c0c0c0c
    34f8:	0c0c0c0c 	.word	0x0c0c0c0c
    34fc:	383d4211 	.word	0x383d4211
    3500:	2e33      	.short	0x2e33
    3502:	29          	.byte	0x29
    3503:	00          	.byte	0x00
    3504:	bd70      	pop	{r4, r5, r6, pc}
                         uint8_t pad,
                         iomode_t mode) {

  PORT_TypeDef *portcfg = NULL;

  osalDbgAssert(pad < PADS_PER_PORT, "pal_lld_setpadmode() #1, invalid pad");
    3506:	4823      	ldr	r0, [pc, #140]	; (3594 <_pal_lld_setpadmode+0xf4>)
    3508:	f7fd fd3a 	bl	f80 <chSysHalt>
    350c:	e7ce      	b.n	34ac <_pal_lld_setpadmode+0xc>
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_ANALOG:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(0);
    break;
  case PAL_MODE_ALTERNATIVE_1:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    350e:	f44f 7280 	mov.w	r2, #256	; 0x100
    3512:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    3516:	bd70      	pop	{r4, r5, r6, pc}
  case PAL_MODE_OUTPUT_PUSHPULL:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    break;
#if KINETIS_GPIO_HAS_OPENDRAIN
  case PAL_MODE_OUTPUT_OPENDRAIN:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    3518:	f44f 7290 	mov.w	r2, #288	; 0x120
    351c:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
                        PORTx_PCRn_ODE;
    break;
    3520:	bd70      	pop	{r4, r5, r6, pc}
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
                        PORTx_PCRn_PE |
                        PORTx_PCRn_PS;
      break;
  case PAL_MODE_INPUT_PULLDOWN:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    3522:	f44f 7281 	mov.w	r2, #258	; 0x102
    3526:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
                        PORTx_PCRn_PE;
      break;
    352a:	bd70      	pop	{r4, r5, r6, pc}
    break;
#else
#undef PAL_MODE_OUTPUT_OPENDRAIN
#endif
  case PAL_MODE_INPUT_PULLUP:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    352c:	f240 1203 	movw	r2, #259	; 0x103
    3530:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
                        PORTx_PCRn_PE |
                        PORTx_PCRn_PS;
      break;
    3534:	bd70      	pop	{r4, r5, r6, pc}
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
                        PORTx_PCRn_PE;
      break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_ANALOG:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(0);
    3536:	2200      	movs	r2, #0
    3538:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    353c:	bd70      	pop	{r4, r5, r6, pc}
    break;
  case PAL_MODE_ALTERNATIVE_6:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(6);
    break;
  case PAL_MODE_ALTERNATIVE_7:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(7);
    353e:	f44f 62e0 	mov.w	r2, #1792	; 0x700
    3542:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    3546:	bd70      	pop	{r4, r5, r6, pc}
    break;
  case PAL_MODE_ALTERNATIVE_5:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(5);
    break;
  case PAL_MODE_ALTERNATIVE_6:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(6);
    3548:	f44f 62c0 	mov.w	r2, #1536	; 0x600
    354c:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    3550:	bd70      	pop	{r4, r5, r6, pc}
    break;
  case PAL_MODE_ALTERNATIVE_4:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(4);
    break;
  case PAL_MODE_ALTERNATIVE_5:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(5);
    3552:	f44f 62a0 	mov.w	r2, #1280	; 0x500
    3556:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    355a:	bd70      	pop	{r4, r5, r6, pc}
    break;
  case PAL_MODE_ALTERNATIVE_3:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(3);
    break;
  case PAL_MODE_ALTERNATIVE_4:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(4);
    355c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    3560:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    3564:	bd70      	pop	{r4, r5, r6, pc}
    break;
  case PAL_MODE_ALTERNATIVE_2:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(2);
    break;
  case PAL_MODE_ALTERNATIVE_3:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(3);
    3566:	f44f 7240 	mov.w	r2, #768	; 0x300
    356a:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    356e:	bd70      	pop	{r4, r5, r6, pc}
    break;
  case PAL_MODE_ALTERNATIVE_1:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    break;
  case PAL_MODE_ALTERNATIVE_2:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(2);
    3570:	f44f 7200 	mov.w	r2, #512	; 0x200
    3574:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    break;
    3578:	bd70      	pop	{r4, r5, r6, pc}
  else if (port == IOPORT3)
    portcfg = PORTC;
  else if (port == IOPORT4)
    portcfg = PORTD;
  else if (port == IOPORT5)
    portcfg = PORTE;
    357a:	4b07      	ldr	r3, [pc, #28]	; (3598 <_pal_lld_setpadmode+0xf8>)
    357c:	e7b2      	b.n	34e4 <_pal_lld_setpadmode+0x44>
    port->PDDR |= ((uint32_t) 1 << pad);
  else
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    portcfg = PORTA;
    357e:	4b07      	ldr	r3, [pc, #28]	; (359c <_pal_lld_setpadmode+0xfc>)
    3580:	e7b0      	b.n	34e4 <_pal_lld_setpadmode+0x44>
  else if (port == IOPORT2)
    portcfg = PORTB;
    3582:	4b07      	ldr	r3, [pc, #28]	; (35a0 <_pal_lld_setpadmode+0x100>)
    3584:	e7ae      	b.n	34e4 <_pal_lld_setpadmode+0x44>
  else if (port == IOPORT3)
    portcfg = PORTC;
    3586:	4b07      	ldr	r3, [pc, #28]	; (35a4 <_pal_lld_setpadmode+0x104>)
    3588:	e7ac      	b.n	34e4 <_pal_lld_setpadmode+0x44>
  else if (port == IOPORT4)
    portcfg = PORTD;
    358a:	4b07      	ldr	r3, [pc, #28]	; (35a8 <_pal_lld_setpadmode+0x108>)
    358c:	e7aa      	b.n	34e4 <_pal_lld_setpadmode+0x44>
    358e:	bf00      	nop
    3590:	400ff000 	.word	0x400ff000
    3594:	00006e20 	.word	0x00006e20
    3598:	4004d000 	.word	0x4004d000
    359c:	40049000 	.word	0x40049000
    35a0:	4004a000 	.word	0x4004a000
    35a4:	4004b000 	.word	0x4004b000
    35a8:	4004c000 	.word	0x4004c000
    35ac:	f3af 8000 	nop.w

000035b0 <_pal_lld_init>:
void _pal_lld_init(const PALConfig *config) {

  int i, j;

  /* Enable clocking on all Ports */
  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    35b0:	490c      	ldr	r1, [pc, #48]	; (35e4 <_pal_lld_init+0x34>)
    35b2:	f241 0238 	movw	r2, #4152	; 0x1038
 *
 * @param[in] config    the Kinetis ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    35b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  int i, j;

  /* Enable clocking on all Ports */
  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    35b8:	588b      	ldr	r3, [r1, r2]
    35ba:	f443 5378 	orr.w	r3, r3, #15872	; 0x3e00
    35be:	508b      	str	r3, [r1, r2]
    35c0:	4606      	mov	r6, r0
    35c2:	f500 7725 	add.w	r7, r0, #660	; 0x294
 *
 * @param[in] config    the Kinetis ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    35c6:	4635      	mov	r5, r6
    35c8:	2400      	movs	r4, #0
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
      pal_lld_setpadmode(config->ports[i].port,
    35ca:	b2e1      	uxtb	r1, r4
    35cc:	6830      	ldr	r0, [r6, #0]
    35ce:	f855 2f04 	ldr.w	r2, [r5, #4]!
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
    35d2:	3401      	adds	r4, #1
      pal_lld_setpadmode(config->ports[i].port,
    35d4:	f7ff ff64 	bl	34a0 <_pal_lld_setpadmode>
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
    35d8:	2c20      	cmp	r4, #32
    35da:	d1f6      	bne.n	35ca <_pal_lld_init+0x1a>
    35dc:	3684      	adds	r6, #132	; 0x84
                SIM_SCGC5_PORTC |
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    35de:	42be      	cmp	r6, r7
    35e0:	d1f1      	bne.n	35c6 <_pal_lld_init+0x16>
    35e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    35e4:	40047000 	.word	0x40047000
    35e8:	f3af 8000 	nop.w
    35ec:	f3af 8000 	nop.w

000035f0 <notify4>:
}
#endif

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp)
{
    35f0:	b510      	push	{r4, lr}
 * @brief   Attempts a TX preload
 */
static void preload(SerialDriver *sdp) {
  UART_w_TypeDef *u = &(sdp->uart);

  if (*(u->s1_p) & UARTx_S1_TDRE) {
    35f2:	4c0f      	ldr	r4, [pc, #60]	; (3630 <notify4+0x40>)
    35f4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    35f8:	781b      	ldrb	r3, [r3, #0]
    35fa:	061b      	lsls	r3, r3, #24
    35fc:	d400      	bmi.n	3600 <notify4+0x10>
    35fe:	bd10      	pop	{r4, pc}
    msg_t b = oqGetI(&sdp->oqueue);
    3600:	f104 0030 	add.w	r0, r4, #48	; 0x30
    3604:	f7ff fa54 	bl	2ab0 <oqGetI>
    if (b < Q_OK) {
    3608:	2800      	cmp	r0, #0
    360a:	db0a      	blt.n	3622 <notify4+0x32>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      return;
    }
    *(u->d_p) = b;
    360c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    3610:	b2c0      	uxtb	r0, r0
    3612:	7018      	strb	r0, [r3, #0]
    *(u->c2_p) |= UARTx_C2_TIE;
    3614:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    3618:	7813      	ldrb	r3, [r2, #0]
    361a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    361e:	7013      	strb	r3, [r2, #0]
    3620:	bd10      	pop	{r4, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
    3622:	1d20      	adds	r0, r4, #4
    3624:	2108      	movs	r1, #8
#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp)
{
  (void)qp;
  preload(&SD4);
}
    3626:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    362a:	f7fe bd99 	b.w	2160 <chEvtBroadcastFlagsI>
    362e:	bf00      	nop
    3630:	1ffff328 	.word	0x1ffff328
    3634:	f3af 8000 	nop.w
    3638:	f3af 8000 	nop.w
    363c:	f3af 8000 	nop.w

00003640 <VectorB8>:
  OSAL_IRQ_EPILOGUE();
}
#endif

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(KINETIS_SERIAL3_IRQ_VECTOR) {
    3640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @param[in] sdp       communication channel associated to the UART
 */
static void serve_interrupt(SerialDriver *sdp) {
  UART_w_TypeDef *u = &(sdp->uart);
  uint8_t s1 = *(u->s1_p);
    3644:	4d52      	ldr	r5, [pc, #328]	; (3790 <VectorB8+0x150>)
}
#endif

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(KINETIS_SERIAL3_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();
    3646:	f7fe fb0b 	bl	1c60 <_stats_increase_irq>
    364a:	f7fd fd49 	bl	10e0 <_dbg_check_enter_isr>
 *
 * @param[in] sdp       communication channel associated to the UART
 */
static void serve_interrupt(SerialDriver *sdp) {
  UART_w_TypeDef *u = &(sdp->uart);
  uint8_t s1 = *(u->s1_p);
    364e:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    3652:	781c      	ldrb	r4, [r3, #0]
    3654:	b2e4      	uxtb	r4, r4

  if (s1 & UARTx_S1_RDRF) {
    3656:	06a3      	lsls	r3, r4, #26
    3658:	d413      	bmi.n	3682 <VectorB8+0x42>
    if (iqPutI(&sdp->iqueue, *(u->d_p)) < Q_OK)
      chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    osalSysUnlockFromISR();
  }

  if (s1 & UARTx_S1_TDRE) {
    365a:	0627      	lsls	r7, r4, #24
    365c:	d42c      	bmi.n	36b8 <VectorB8+0x78>
 *
 * @param[in] sdp       communication channel associated to the UART
 */
static void serve_error_interrupt(SerialDriver *sdp) {
  UART_w_TypeDef *u = &(sdp->uart);
  uint8_t s1 = *(u->s1_p);
    365e:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
    3662:	7813      	ldrb	r3, [r2, #0]
    3664:	b2db      	uxtb	r3, r3
#endif /* KL2x && KINETIS_SERIAL_USE_UART0 */

#if defined(K22x) && KINETIS_SERIAL_USE_UART3
  // LPUART also uses write-1-to-clear method
  if(sdp == &SD4) {
    if(s1 & UARTx_S1_IDLE) {
    3666:	06de      	lsls	r6, r3, #27
    3668:	d503      	bpl.n	3672 <VectorB8+0x32>
      *(u->s1_p) |= UARTx_S1_IDLE;
    366a:	7811      	ldrb	r1, [r2, #0]
    366c:	f041 0110 	orr.w	r1, r1, #16
    3670:	7011      	strb	r1, [r2, #0]
    }

    if(s1 & (UARTx_S1_OR | UARTx_S1_NF | UARTx_S1_FE | UARTx_S1_PF)) {
    3672:	0718      	lsls	r0, r3, #28
    3674:	d13c      	bne.n	36f0 <VectorB8+0xb0>

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(KINETIS_SERIAL3_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD4);
  OSAL_IRQ_EPILOGUE();
    3676:	f7fd fd4b 	bl	1110 <_dbg_check_leave_isr>
}
    367a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(KINETIS_SERIAL3_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD4);
  OSAL_IRQ_EPILOGUE();
    367e:	f7ff b847 	b.w	2710 <_port_irq_epilogue>
    3682:	2320      	movs	r3, #32
    3684:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    3688:	f7fe fb22 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    368c:	f7fd fcf8 	bl	1080 <_dbg_check_lock_from_isr>
  UART_w_TypeDef *u = &(sdp->uart);
  uint8_t s1 = *(u->s1_p);

  if (s1 & UARTx_S1_RDRF) {
    osalSysLockFromISR();
    if (iqIsEmptyI(&sdp->iqueue))
    3690:	696b      	ldr	r3, [r5, #20]
    3692:	2b00      	cmp	r3, #0
    3694:	d05b      	beq.n	374e <VectorB8+0x10e>
      chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    if (iqPutI(&sdp->iqueue, *(u->d_p)) < Q_OK)
    3696:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
    369a:	483e      	ldr	r0, [pc, #248]	; (3794 <VectorB8+0x154>)
    369c:	7819      	ldrb	r1, [r3, #0]
    369e:	f7ff f897 	bl	27d0 <iqPutI>
    36a2:	2800      	cmp	r0, #0
    36a4:	db58      	blt.n	3758 <VectorB8+0x118>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    36a6:	f7fd fd03 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    36aa:	f7fe fb19 	bl	1ce0 <_stats_stop_measure_crit_isr>
    36ae:	2300      	movs	r3, #0
    36b0:	f383 8811 	msr	BASEPRI, r3
      chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    osalSysUnlockFromISR();
  }

  if (s1 & UARTx_S1_TDRE) {
    36b4:	0627      	lsls	r7, r4, #24
    36b6:	d5d2      	bpl.n	365e <VectorB8+0x1e>
    36b8:	f04f 0820 	mov.w	r8, #32
    36bc:	f388 8811 	msr	BASEPRI, r8
    msg_t b;

    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    36c0:	4e33      	ldr	r6, [pc, #204]	; (3790 <VectorB8+0x150>)
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    36c2:	f7fe fb05 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    36c6:	f7fd fcdb 	bl	1080 <_dbg_check_lock_from_isr>
    36ca:	f106 0030 	add.w	r0, r6, #48	; 0x30
    36ce:	f7ff f9ef 	bl	2ab0 <oqGetI>
    36d2:	2700      	movs	r7, #0
    36d4:	4604      	mov	r4, r0
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    36d6:	f7fd fceb 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    36da:	f7fe fb01 	bl	1ce0 <_stats_stop_measure_crit_isr>
    36de:	f387 8811 	msr	BASEPRI, r7
    osalSysUnlockFromISR();

    if (b < Q_OK) {
    36e2:	42bc      	cmp	r4, r7
    36e4:	db3d      	blt.n	3762 <VectorB8+0x122>
      osalSysLockFromISR();
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      osalSysUnlockFromISR();
      *(u->c2_p) &= ~UARTx_C2_TIE;
    } else {
       *(u->d_p) = b;
    36e6:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
    36ea:	b2e4      	uxtb	r4, r4
    36ec:	701c      	strb	r4, [r3, #0]
    36ee:	e7b6      	b.n	365e <VectorB8+0x1e>
 */
static void set_error(SerialDriver *sdp, uint8_t s1) {
  eventflags_t sts = 0;

  if (s1 & UARTx_S1_OR)
    sts |= SD_OVERRUN_ERROR;
    36f0:	f013 0f08 	tst.w	r3, #8
    36f4:	bf0c      	ite	eq
    36f6:	2400      	moveq	r4, #0
    36f8:	2480      	movne	r4, #128	; 0x80
  if (s1 & UARTx_S1_PF)
    36fa:	07d9      	lsls	r1, r3, #31
    sts |= SD_PARITY_ERROR;
    36fc:	bf48      	it	mi
    36fe:	f044 0420 	orrmi.w	r4, r4, #32
  if (s1 & UARTx_S1_FE)
    3702:	079a      	lsls	r2, r3, #30
    sts |= SD_FRAMING_ERROR;
    3704:	bf48      	it	mi
    3706:	f044 0440 	orrmi.w	r4, r4, #64	; 0x40
  if (s1 & UARTx_S1_NF)
    370a:	075b      	lsls	r3, r3, #29
    sts |= SD_NOISE_ERROR;
    370c:	bf48      	it	mi
    370e:	f444 7480 	orrmi.w	r4, r4, #256	; 0x100
    3712:	2320      	movs	r3, #32
    3714:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    3718:	f7fe fada 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    371c:	f7fd fcb0 	bl	1080 <_dbg_check_lock_from_isr>
    3720:	4621      	mov	r1, r4
    3722:	481d      	ldr	r0, [pc, #116]	; (3798 <VectorB8+0x158>)
    3724:	f7fe fd1c 	bl	2160 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    3728:	f7fd fcc2 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    372c:	f7fe fad8 	bl	1ce0 <_stats_stop_measure_crit_isr>
    3730:	2300      	movs	r3, #0
    3732:	f383 8811 	msr	BASEPRI, r3
      *(u->s1_p) |= UARTx_S1_IDLE;
    }

    if(s1 & (UARTx_S1_OR | UARTx_S1_NF | UARTx_S1_FE | UARTx_S1_PF)) {
      set_error(sdp, s1);
      *(u->s1_p) |= UARTx_S1_OR | UARTx_S1_NF | UARTx_S1_FE | UARTx_S1_PF;
    3736:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
    373a:	7813      	ldrb	r3, [r2, #0]
    373c:	f043 030f 	orr.w	r3, r3, #15
    3740:	7013      	strb	r3, [r2, #0]

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(KINETIS_SERIAL3_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD4);
  OSAL_IRQ_EPILOGUE();
    3742:	f7fd fce5 	bl	1110 <_dbg_check_leave_isr>
}
    3746:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

#if KINETIS_SERIAL_USE_UART3 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(KINETIS_SERIAL3_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD4);
  OSAL_IRQ_EPILOGUE();
    374a:	f7fe bfe1 	b.w	2710 <_port_irq_epilogue>
    374e:	1d28      	adds	r0, r5, #4
    3750:	2104      	movs	r1, #4
    3752:	f7fe fd05 	bl	2160 <chEvtBroadcastFlagsI>
    3756:	e79e      	b.n	3696 <VectorB8+0x56>
    3758:	480f      	ldr	r0, [pc, #60]	; (3798 <VectorB8+0x158>)
    375a:	2180      	movs	r1, #128	; 0x80
    375c:	f7fe fd00 	bl	2160 <chEvtBroadcastFlagsI>
    3760:	e7a1      	b.n	36a6 <VectorB8+0x66>
    3762:	f388 8811 	msr	BASEPRI, r8
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    3766:	f7fe fab3 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    376a:	f7fd fc89 	bl	1080 <_dbg_check_lock_from_isr>
    376e:	1d30      	adds	r0, r6, #4
    3770:	2108      	movs	r1, #8
    3772:	f7fe fcf5 	bl	2160 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    3776:	f7fd fc9b 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    377a:	f7fe fab1 	bl	1ce0 <_stats_stop_measure_crit_isr>
    377e:	f387 8811 	msr	BASEPRI, r7

    if (b < Q_OK) {
      osalSysLockFromISR();
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      osalSysUnlockFromISR();
      *(u->c2_p) &= ~UARTx_C2_TIE;
    3782:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
    3786:	7813      	ldrb	r3, [r2, #0]
    3788:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    378c:	7013      	strb	r3, [r2, #0]
    378e:	e766      	b.n	365e <VectorB8+0x1e>
    3790:	1ffff328 	.word	0x1ffff328
    3794:	1ffff334 	.word	0x1ffff334
    3798:	1ffff32c 	.word	0x1ffff32c
    379c:	f3af 8000 	nop.w

000037a0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    37a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  SD3.uart.uart_p = UART2;
#endif /* KINETIS_SERIAL_USE_UART2 */

#if KINETIS_SERIAL_USE_UART3
  /* Driver initialization.*/
  sdObjectInit(&SD4, NULL, notify4);
    37a2:	4c13      	ldr	r4, [pc, #76]	; (37f0 <sd_lld_init+0x50>)
    37a4:	4a13      	ldr	r2, [pc, #76]	; (37f4 <sd_lld_init+0x54>)
  /* little endian! */
  SD4.uart.bdh_p = ((uint8_t *)&(LPUART0->BAUD)) + 1; /* BDH: BAUD, byte 3 */
  SD4.uart.bdl_p = ((uint8_t *)&(LPUART0->BAUD)) + 0; /* BDL: BAUD, byte 4 */
  SD4.uart.c1_p =  ((uint8_t *)&(LPUART0->CTRL)) + 0; /* C1: CTRL, byte 4 */
  SD4.uart.c2_p =  ((uint8_t *)&(LPUART0->CTRL)) + 2; /* C2: CTRL, byte 2 */
  SD4.uart.c3_p =  ((uint8_t *)&(LPUART0->CTRL)) + 3; /* C3: CTRL, byte 1 */
    37a6:	4f14      	ldr	r7, [pc, #80]	; (37f8 <sd_lld_init+0x58>)
  SD4.uart.c4_p =  ((uint8_t *)&(LPUART0->BAUD)) + 3; /* C4: BAUD, byte 1 */
    37a8:	4e14      	ldr	r6, [pc, #80]	; (37fc <sd_lld_init+0x5c>)
  SD4.uart.s1_p =  ((uint8_t *)&(LPUART0->STAT)) + 2; /* S1: STAT, byte 2 */
    37aa:	4d15      	ldr	r5, [pc, #84]	; (3800 <sd_lld_init+0x60>)
  SD3.uart.uart_p = UART2;
#endif /* KINETIS_SERIAL_USE_UART2 */

#if KINETIS_SERIAL_USE_UART3
  /* Driver initialization.*/
  sdObjectInit(&SD4, NULL, notify4);
    37ac:	4620      	mov	r0, r4
    37ae:	2100      	movs	r1, #0
    37b0:	f7ff fb86 	bl	2ec0 <sdObjectInit>
  SD4.uart.s1_p =  (volatile uint8_t *)&(UART3->S1);
  SD4.uart.s2_p =  &(UART3->S2);
  SD4.uart.d_p =   &(UART3->D);
#else /* ! KINETIS_SERIAL0_IS_LPUART */
  /* little endian! */
  SD4.uart.bdh_p = ((uint8_t *)&(LPUART0->BAUD)) + 1; /* BDH: BAUD, byte 3 */
    37b4:	4a13      	ldr	r2, [pc, #76]	; (3804 <sd_lld_init+0x64>)
  SD4.uart.bdl_p = ((uint8_t *)&(LPUART0->BAUD)) + 0; /* BDL: BAUD, byte 4 */
    37b6:	4b14      	ldr	r3, [pc, #80]	; (3808 <sd_lld_init+0x68>)
  SD4.uart.c1_p =  ((uint8_t *)&(LPUART0->CTRL)) + 0; /* C1: CTRL, byte 4 */
    37b8:	f8df c058 	ldr.w	ip, [pc, #88]	; 3814 <sd_lld_init+0x74>
  SD4.uart.c2_p =  ((uint8_t *)&(LPUART0->CTRL)) + 2; /* C2: CTRL, byte 2 */
    37bc:	f8df e058 	ldr.w	lr, [pc, #88]	; 3818 <sd_lld_init+0x78>
  SD4.uart.c3_p =  ((uint8_t *)&(LPUART0->CTRL)) + 3; /* C3: CTRL, byte 1 */
  SD4.uart.c4_p =  ((uint8_t *)&(LPUART0->BAUD)) + 3; /* C4: BAUD, byte 1 */
  SD4.uart.s1_p =  ((uint8_t *)&(LPUART0->STAT)) + 2; /* S1: STAT, byte 2 */
  SD4.uart.s2_p =  ((uint8_t *)&(LPUART0->STAT)) + 3; /* S2: STAT, byte 1 */
    37c0:	4812      	ldr	r0, [pc, #72]	; (380c <sd_lld_init+0x6c>)
  SD4.uart.d_p =   ((uint8_t *)&(LPUART0->DATA)) + 0; /* D: DATA, byte 4 */
    37c2:	4913      	ldr	r1, [pc, #76]	; (3810 <sd_lld_init+0x70>)
  SD4.uart.s1_p =  (volatile uint8_t *)&(UART3->S1);
  SD4.uart.s2_p =  &(UART3->S2);
  SD4.uart.d_p =   &(UART3->D);
#else /* ! KINETIS_SERIAL0_IS_LPUART */
  /* little endian! */
  SD4.uart.bdh_p = ((uint8_t *)&(LPUART0->BAUD)) + 1; /* BDH: BAUD, byte 3 */
    37c4:	6762      	str	r2, [r4, #116]	; 0x74
  SD4.uart.s2_p =  ((uint8_t *)&(LPUART0->STAT)) + 3; /* S2: STAT, byte 1 */
  SD4.uart.d_p =   ((uint8_t *)&(LPUART0->DATA)) + 0; /* D: DATA, byte 4 */
#endif /* ! KINETIS_SERIAL0_IS_LPUART */
#if KINETIS_SERIAL3_IS_LPUART
  SD4.uart.lpuart_p = LPUART0;
  SD4.uart.uart_p = NULL;
    37c6:	2200      	movs	r2, #0
  SD4.uart.d_p =   &(UART3->D);
#else /* ! KINETIS_SERIAL0_IS_LPUART */
  /* little endian! */
  SD4.uart.bdh_p = ((uint8_t *)&(LPUART0->BAUD)) + 1; /* BDH: BAUD, byte 3 */
  SD4.uart.bdl_p = ((uint8_t *)&(LPUART0->BAUD)) + 0; /* BDL: BAUD, byte 4 */
  SD4.uart.c1_p =  ((uint8_t *)&(LPUART0->CTRL)) + 0; /* C1: CTRL, byte 4 */
    37c8:	f8c4 c07c 	str.w	ip, [r4, #124]	; 0x7c
  SD4.uart.c2_p =  ((uint8_t *)&(LPUART0->CTRL)) + 2; /* C2: CTRL, byte 2 */
    37cc:	f8c4 e080 	str.w	lr, [r4, #128]	; 0x80
  SD4.uart.c3_p =  ((uint8_t *)&(LPUART0->CTRL)) + 3; /* C3: CTRL, byte 1 */
    37d0:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
  SD4.uart.c4_p =  ((uint8_t *)&(LPUART0->BAUD)) + 3; /* C4: BAUD, byte 1 */
    37d4:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
  SD4.uart.s1_p =  ((uint8_t *)&(LPUART0->STAT)) + 2; /* S1: STAT, byte 2 */
    37d8:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  SD4.uart.s2_p =  ((uint8_t *)&(LPUART0->STAT)) + 3; /* S2: STAT, byte 1 */
    37dc:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
  SD4.uart.d_p =   ((uint8_t *)&(LPUART0->DATA)) + 0; /* D: DATA, byte 4 */
    37e0:	f8c4 1094 	str.w	r1, [r4, #148]	; 0x94
#endif /* ! KINETIS_SERIAL0_IS_LPUART */
#if KINETIS_SERIAL3_IS_LPUART
  SD4.uart.lpuart_p = LPUART0;
  SD4.uart.uart_p = NULL;
    37e4:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
  SD4.uart.s2_p =  &(UART3->S2);
  SD4.uart.d_p =   &(UART3->D);
#else /* ! KINETIS_SERIAL0_IS_LPUART */
  /* little endian! */
  SD4.uart.bdh_p = ((uint8_t *)&(LPUART0->BAUD)) + 1; /* BDH: BAUD, byte 3 */
  SD4.uart.bdl_p = ((uint8_t *)&(LPUART0->BAUD)) + 0; /* BDL: BAUD, byte 4 */
    37e8:	67a3      	str	r3, [r4, #120]	; 0x78
  SD4.uart.s1_p =  ((uint8_t *)&(LPUART0->STAT)) + 2; /* S1: STAT, byte 2 */
  SD4.uart.s2_p =  ((uint8_t *)&(LPUART0->STAT)) + 3; /* S2: STAT, byte 1 */
  SD4.uart.d_p =   ((uint8_t *)&(LPUART0->DATA)) + 0; /* D: DATA, byte 4 */
#endif /* ! KINETIS_SERIAL0_IS_LPUART */
#if KINETIS_SERIAL3_IS_LPUART
  SD4.uart.lpuart_p = LPUART0;
    37ea:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
    37ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    37f0:	1ffff328 	.word	0x1ffff328
    37f4:	000035f1 	.word	0x000035f1
    37f8:	4002a00b 	.word	0x4002a00b
    37fc:	4002a003 	.word	0x4002a003
    3800:	4002a006 	.word	0x4002a006
    3804:	4002a001 	.word	0x4002a001
    3808:	4002a000 	.word	0x4002a000
    380c:	4002a007 	.word	0x4002a007
    3810:	4002a00c 	.word	0x4002a00c
    3814:	4002a008 	.word	0x4002a008
    3818:	4002a00a 	.word	0x4002a00a
    381c:	f3af 8000 	nop.w

00003820 <sd_lld_start>:
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    3820:	4a27      	ldr	r2, [pc, #156]	; (38c0 <sd_lld_start+0xa0>)

  if (sdp->state == SD_STOP) {
    3822:	6883      	ldr	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    3824:	2900      	cmp	r1, #0
    3826:	bf08      	it	eq
    3828:	4611      	moveq	r1, r2

  if (sdp->state == SD_STOP) {
    382a:	2b01      	cmp	r3, #1
    382c:	d000      	beq.n	3830 <sd_lld_start+0x10>
    382e:	4770      	bx	lr
#endif /* KINETIS_HAS_SERIAL_ERROR_IRQ */
    }
#endif /* KINETIS_SERIAL_USE_UART2 */

#if KINETIS_SERIAL_USE_UART3
    if (sdp == &SD4) {
    3830:	4b24      	ldr	r3, [pc, #144]	; (38c4 <sd_lld_start+0xa4>)
    3832:	4298      	cmp	r0, r3
    3834:	d1fb      	bne.n	382e <sd_lld_start+0xe>
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    3836:	b470      	push	{r4, r5, r6}

#if KINETIS_SERIAL_USE_UART3
    if (sdp == &SD4) {
      
#if KINETIS_SERIAL3_IS_LPUART
      SIM->SCGC6 |= SIM_SCGC6_LPUART0;
    3838:	4c23      	ldr	r4, [pc, #140]	; (38c8 <sd_lld_start+0xa8>)

  UART_w_TypeDef *uart = &(sdp->uart);
  uint32_t divisor;

  /* Discard any incoming data. */
  while (*(uart->s1_p) & UARTx_S1_RDRF) {
    383a:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c

#if KINETIS_SERIAL_USE_UART3
    if (sdp == &SD4) {
      
#if KINETIS_SERIAL3_IS_LPUART
      SIM->SCGC6 |= SIM_SCGC6_LPUART0;
    383e:	f241 063c 	movw	r6, #4156	; 0x103c
      SIM->SOPT2 =
              (SIM->SOPT2 & ~SIM_SOPT2_LPUARTSRC_MASK) |
    3842:	f241 0504 	movw	r5, #4100	; 0x1004

#if KINETIS_SERIAL_USE_UART3
    if (sdp == &SD4) {
      
#if KINETIS_SERIAL3_IS_LPUART
      SIM->SCGC6 |= SIM_SCGC6_LPUART0;
    3846:	59a2      	ldr	r2, [r4, r6]
    3848:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    384c:	51a2      	str	r2, [r4, r6]
      SIM->SOPT2 =
              (SIM->SOPT2 & ~SIM_SOPT2_LPUARTSRC_MASK) |
    384e:	5962      	ldr	r2, [r4, r5]
    3850:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
    3854:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
#if KINETIS_SERIAL_USE_UART3
    if (sdp == &SD4) {
      
#if KINETIS_SERIAL3_IS_LPUART
      SIM->SCGC6 |= SIM_SCGC6_LPUART0;
      SIM->SOPT2 =
    3858:	5162      	str	r2, [r4, r5]

  UART_w_TypeDef *uart = &(sdp->uart);
  uint32_t divisor;

  /* Discard any incoming data. */
  while (*(uart->s1_p) & UARTx_S1_RDRF) {
    385a:	7802      	ldrb	r2, [r0, #0]
    385c:	0694      	lsls	r4, r2, #26
    385e:	d505      	bpl.n	386c <sd_lld_start+0x4c>
    3860:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
    (void)*(uart->d_p);
    3864:	7822      	ldrb	r2, [r4, #0]

  UART_w_TypeDef *uart = &(sdp->uart);
  uint32_t divisor;

  /* Discard any incoming data. */
  while (*(uart->s1_p) & UARTx_S1_RDRF) {
    3866:	7802      	ldrb	r2, [r0, #0]
    3868:	0692      	lsls	r2, r2, #26
    386a:	d4fb      	bmi.n	3864 <sd_lld_start+0x44>
    (void)*(uart->d_p);
  }

  /* Disable UART while configuring */
  *(uart->c2_p) &= ~(UARTx_C2_RE | UARTx_C2_TE);
    386c:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
#error Baud rate selection not implemented for this MCU type
#endif /* K20x */

#if defined(K22x)
  divisor = 102000000;
  divisor = (divisor / (config->sc_speed * 17));
    3870:	4816      	ldr	r0, [pc, #88]	; (38cc <sd_lld_start+0xac>)
  while (*(uart->s1_p) & UARTx_S1_RDRF) {
    (void)*(uart->d_p);
  }

  /* Disable UART while configuring */
  *(uart->c2_p) &= ~(UARTx_C2_RE | UARTx_C2_TE);
    3872:	7822      	ldrb	r2, [r4, #0]
    3874:	f002 02f3 	and.w	r2, r2, #243	; 0xf3
    3878:	7022      	strb	r2, [r4, #0]

#if defined(K22x)
  divisor = 102000000;
  divisor = (divisor / (config->sc_speed * 17));
    
  *(uart->bdh_p) = UARTx_BDH_SBR(divisor >> 8) | (*(uart->bdh_p) & ~UARTx_BDH_SBR_MASK);
    387a:	6f5c      	ldr	r4, [r3, #116]	; 0x74
#error Baud rate selection not implemented for this MCU type
#endif /* K20x */

#if defined(K22x)
  divisor = 102000000;
  divisor = (divisor / (config->sc_speed * 17));
    387c:	680a      	ldr	r2, [r1, #0]
    
  *(uart->bdh_p) = UARTx_BDH_SBR(divisor >> 8) | (*(uart->bdh_p) & ~UARTx_BDH_SBR_MASK);
    387e:	7821      	ldrb	r1, [r4, #0]
#error Baud rate selection not implemented for this MCU type
#endif /* K20x */

#if defined(K22x)
  divisor = 102000000;
  divisor = (divisor / (config->sc_speed * 17));
    3880:	eb02 1202 	add.w	r2, r2, r2, lsl #4
    
  *(uart->bdh_p) = UARTx_BDH_SBR(divisor >> 8) | (*(uart->bdh_p) & ~UARTx_BDH_SBR_MASK);
    3884:	f001 01e0 	and.w	r1, r1, #224	; 0xe0
#error Baud rate selection not implemented for this MCU type
#endif /* K20x */

#if defined(K22x)
  divisor = 102000000;
  divisor = (divisor / (config->sc_speed * 17));
    3888:	fbb0 f2f2 	udiv	r2, r0, r2
    
  *(uart->bdh_p) = UARTx_BDH_SBR(divisor >> 8) | (*(uart->bdh_p) & ~UARTx_BDH_SBR_MASK);
    388c:	f3c2 2004 	ubfx	r0, r2, #8, #5
    3890:	4301      	orrs	r1, r0
    3892:	7021      	strb	r1, [r4, #0]
  *(uart->bdl_p) = UARTx_BDL_SBR(divisor) & 0xFF;
    3894:	6f99      	ldr	r1, [r3, #120]	; 0x78
    3896:	b2d2      	uxtb	r2, r2
    3898:	700a      	strb	r2, [r1, #0]
  *(uart->c4_p) = UARTx_C4_BRFA(divisor) | (*(uart->c4_p) & ~UARTx_C4_BRFA_MASK);
#endif /* K20x */
#endif

  /* Line settings. */
  *(uart->c1_p) = 0;
    389a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    389c:	2100      	movs	r1, #0
    389e:	7011      	strb	r1, [r2, #0]
  /* Enable error event interrupts (overrun, noise, framing, parity) */
  *(uart->c3_p) = UARTx_C3_ORIE | UARTx_C3_NEIE | UARTx_C3_FEIE | UARTx_C3_PEIE;
    38a0:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    38a4:	210f      	movs	r1, #15
    38a6:	7011      	strb	r1, [r2, #0]
  /* Enable the peripheral; including receive interrupts. */
  *(uart->c2_p) |= UARTx_C2_RE | UARTx_C2_RIE | UARTx_C2_TE;
    38a8:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
    38ac:	7813      	ldrb	r3, [r2, #0]
    38ae:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
    38b2:	7013      	strb	r3, [r2, #0]
#endif /* KINETIS_SERIAL3_IS_LPUART */
      
      configure_uart(sdp, config);
      
#if KINETIS_SERIAL3_IS_LPUART
      nvicEnableVector(LPUART0_IRQn, KINETIS_SERIAL_UART3_PRIORITY);
    38b4:	201e      	movs	r0, #30
    38b6:	210c      	movs	r1, #12
#endif /* KINETIS_SERIAL_USE_UART3 */
    
  }
  /* Configures the peripheral.*/

}
    38b8:	bc70      	pop	{r4, r5, r6}
#endif /* KINETIS_SERIAL3_IS_LPUART */
      
      configure_uart(sdp, config);
      
#if KINETIS_SERIAL3_IS_LPUART
      nvicEnableVector(LPUART0_IRQn, KINETIS_SERIAL_UART3_PRIORITY);
    38ba:	f7ff bc11 	b.w	30e0 <nvicEnableVector>
    38be:	bf00      	nop
    38c0:	00006e40 	.word	0x00006e40
    38c4:	1ffff328 	.word	0x1ffff328
    38c8:	40047000 	.word	0x40047000
    38cc:	06146580 	.word	0x06146580

000038d0 <Vector40>:

#endif

#if KINETIS_SPI_USE_SPI1 || defined(__DOXYGEN__)

OSAL_IRQ_HANDLER(KINETIS_DMA0_IRQ_VECTOR) {
    38d0:	b538      	push	{r3, r4, r5, lr}
    38d2:	4c1a      	ldr	r4, [pc, #104]	; (393c <Vector40+0x6c>)
  OSAL_IRQ_PROLOGUE();
    38d4:	f7fe f9c4 	bl	1c60 <_stats_increase_irq>
    38d8:	f7fd fc02 	bl	10e0 <_dbg_check_enter_isr>
    38dc:	69e3      	ldr	r3, [r4, #28]

  /* Clear bit 0 in Interrupt Request Register (INT) by writing 0 to CINT */
  DMA->CINT = KINETIS_SPI1_RX_DMA_CHANNEL;
    38de:	4818      	ldr	r0, [pc, #96]	; (3940 <Vector40+0x70>)
}

static void spi_stop_xfer(SPIDriver *spip)
{
  /* Halt the DSPI peripheral */
  spip->spi->MCR = SPIx_MCR_MSTR | SPIx_MCR_HALT;
    38e0:	4a18      	ldr	r2, [pc, #96]	; (3944 <Vector40+0x74>)
  /* Clear bit 0 in Interrupt Request Register (INT) by writing 0 to CINT */
  DMA->CINT = KINETIS_SPI1_RX_DMA_CHANNEL;

  spi_stop_xfer(&SPID2);

  _spi_isr_code(&SPID2);
    38e2:	6861      	ldr	r1, [r4, #4]

OSAL_IRQ_HANDLER(KINETIS_DMA0_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  /* Clear bit 0 in Interrupt Request Register (INT) by writing 0 to CINT */
  DMA->CINT = KINETIS_SPI1_RX_DMA_CHANNEL;
    38e4:	2500      	movs	r5, #0
    38e6:	77c5      	strb	r5, [r0, #31]
}

static void spi_stop_xfer(SPIDriver *spip)
{
  /* Halt the DSPI peripheral */
  spip->spi->MCR = SPIx_MCR_MSTR | SPIx_MCR_HALT;
    38e8:	601a      	str	r2, [r3, #0]

  /* Clear all the flags which are currently set. */
  spip->spi->SR |= spip->spi->SR;
    38ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    38ec:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  /* Clear bit 0 in Interrupt Request Register (INT) by writing 0 to CINT */
  DMA->CINT = KINETIS_SPI1_RX_DMA_CHANNEL;

  spi_stop_xfer(&SPID2);

  _spi_isr_code(&SPID2);
    38ee:	6809      	ldr	r1, [r1, #0]
{
  /* Halt the DSPI peripheral */
  spip->spi->MCR = SPIx_MCR_MSTR | SPIx_MCR_HALT;

  /* Clear all the flags which are currently set. */
  spip->spi->SR |= spip->spi->SR;
    38f0:	4302      	orrs	r2, r0
    38f2:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Clear bit 0 in Interrupt Request Register (INT) by writing 0 to CINT */
  DMA->CINT = KINETIS_SPI1_RX_DMA_CHANNEL;

  spi_stop_xfer(&SPID2);

  _spi_isr_code(&SPID2);
    38f4:	b1f1      	cbz	r1, 3934 <Vector40+0x64>
    38f6:	2304      	movs	r3, #4
    38f8:	6023      	str	r3, [r4, #0]
    38fa:	4620      	mov	r0, r4
    38fc:	4788      	blx	r1
    38fe:	6823      	ldr	r3, [r4, #0]
    3900:	2b04      	cmp	r3, #4
    3902:	d017      	beq.n	3934 <Vector40+0x64>
    3904:	2320      	movs	r3, #32
    3906:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    390a:	f7fe f9e1 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    390e:	f7fd fbb7 	bl	1080 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
    3912:	480d      	ldr	r0, [pc, #52]	; (3948 <Vector40+0x78>)
    3914:	2100      	movs	r1, #0
    3916:	f7fe f8c3 	bl	1aa0 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    391a:	f7fd fbc9 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    391e:	f7fe f9df 	bl	1ce0 <_stats_stop_measure_crit_isr>
    3922:	2300      	movs	r3, #0
    3924:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
    3928:	f7fd fbf2 	bl	1110 <_dbg_check_leave_isr>
}
    392c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  spi_stop_xfer(&SPID2);

  _spi_isr_code(&SPID2);

  OSAL_IRQ_EPILOGUE();
    3930:	f7fe beee 	b.w	2710 <_port_irq_epilogue>
  /* Clear bit 0 in Interrupt Request Register (INT) by writing 0 to CINT */
  DMA->CINT = KINETIS_SPI1_RX_DMA_CHANNEL;

  spi_stop_xfer(&SPID2);

  _spi_isr_code(&SPID2);
    3934:	2302      	movs	r3, #2
    3936:	6023      	str	r3, [r4, #0]
    3938:	e7e4      	b.n	3904 <Vector40+0x34>
    393a:	bf00      	nop
    393c:	1ffff3c8 	.word	0x1ffff3c8
    3940:	40008000 	.word	0x40008000
    3944:	80000001 	.word	0x80000001
    3948:	1ffff3d0 	.word	0x1ffff3d0
    394c:	f3af 8000 	nop.w

00003950 <spi_lld_init>:
void spi_lld_init(void) {
#if KINETIS_SPI_USE_SPI0
  spiObjectInit(&SPID1);
#endif
#if KINETIS_SPI_USE_SPI1
  spiObjectInit(&SPID2);
    3950:	4801      	ldr	r0, [pc, #4]	; (3958 <spi_lld_init+0x8>)
    3952:	f7ff bb15 	b.w	2f80 <spiObjectInit>
    3956:	bf00      	nop
    3958:	1ffff3c8 	.word	0x1ffff3c8
    395c:	f3af 8000 	nop.w

00003960 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
    3960:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
    3964:	6803      	ldr	r3, [r0, #0]
    3966:	2b01      	cmp	r3, #1
    3968:	d001      	beq.n	396e <spi_lld_start+0xe>
    396a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
    }
#endif

#if KINETIS_SPI_USE_SPI1
    if (&SPID2 == spip) {
    396e:	4b3e      	ldr	r3, [pc, #248]	; (3a68 <spi_lld_start+0x108>)
    3970:	4298      	cmp	r0, r3
    3972:	d068      	beq.n	3a46 <spi_lld_start+0xe6>
    3974:	4604      	mov	r4, r0
        spip->spi->CTAR[0] = KINETIS_SPI_TAR0_DEFAULT;
      }
    }
#endif

    nvicEnableVector(DMA0_IRQn, KINETIS_SPI0_RX_DMA_IRQ_PRIORITY);
    3976:	2108      	movs	r1, #8
    3978:	2000      	movs	r0, #0
    397a:	f7ff fbb1 	bl	30e0 <nvicEnableVector>

    SIM->SCGC6 |= SIM_SCGC6_DMAMUX;
    397e:	4f3b      	ldr	r7, [pc, #236]	; (3a6c <spi_lld_start+0x10c>)
    SIM->SCGC7 |= SIM_SCGC7_DMA;
    3980:	f8df e100 	ldr.w	lr, [pc, #256]	; 3a84 <spi_lld_start+0x124>

    /* Clear DMA error flags */
    DMA->ERR = 0x0F;
    3984:	4b3a      	ldr	r3, [pc, #232]	; (3a70 <spi_lld_start+0x110>)
    DMA->TCD[KINETIS_SPI0_TX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK;
#endif

#if KINETIS_SPI_USE_SPI1
    /* Rx, select SPI Rx FIFO */
    DMAMUX->CHCFG[KINETIS_SPI1_RX_DMAMUX_CHANNEL] = DMAMUX_CHCFGn_ENBL |
    3986:	483b      	ldr	r0, [pc, #236]	; (3a74 <spi_lld_start+0x114>)
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK |
        DMA_CSR_INTMAJOR_MASK;

    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    3988:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 3a88 <spi_lld_start+0x128>

    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    398c:	4d3a      	ldr	r5, [pc, #232]	; (3a78 <spi_lld_start+0x118>)
    398e:	4e3b      	ldr	r6, [pc, #236]	; (3a7c <spi_lld_start+0x11c>)
    }
#endif

    nvicEnableVector(DMA0_IRQn, KINETIS_SPI0_RX_DMA_IRQ_PRIORITY);

    SIM->SCGC6 |= SIM_SCGC6_DMAMUX;
    3990:	f241 013c 	movw	r1, #4156	; 0x103c
    SIM->SCGC7 |= SIM_SCGC7_DMA;

    /* Clear DMA error flags */
    DMA->ERR = 0x0F;
    3994:	f04f 080f 	mov.w	r8, #15
    }
#endif

    nvicEnableVector(DMA0_IRQn, KINETIS_SPI0_RX_DMA_IRQ_PRIORITY);

    SIM->SCGC6 |= SIM_SCGC6_DMAMUX;
    3998:	587a      	ldr	r2, [r7, r1]
    399a:	f042 0202 	orr.w	r2, r2, #2
    399e:	507a      	str	r2, [r7, r1]
    SIM->SCGC7 |= SIM_SCGC7_DMA;
    39a0:	f8de 2000 	ldr.w	r2, [lr]
    DMA->TCD[KINETIS_SPI0_TX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK;
#endif

#if KINETIS_SPI_USE_SPI1
    /* Rx, select SPI Rx FIFO */
    DMAMUX->CHCFG[KINETIS_SPI1_RX_DMAMUX_CHANNEL] = DMAMUX_CHCFGn_ENBL |
    39a4:	2790      	movs	r7, #144	; 0x90
#endif

    nvicEnableVector(DMA0_IRQn, KINETIS_SPI0_RX_DMA_IRQ_PRIORITY);

    SIM->SCGC6 |= SIM_SCGC6_DMAMUX;
    SIM->SCGC7 |= SIM_SCGC7_DMA;
    39a6:	f042 0202 	orr.w	r2, r2, #2
    39aa:	f8ce 2000 	str.w	r2, [lr]

    /* Clear DMA error flags */
    DMA->ERR = 0x0F;
    39ae:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
    DMA->TCD[KINETIS_SPI0_TX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK;
#endif

#if KINETIS_SPI_USE_SPI1
    /* Rx, select SPI Rx FIFO */
    DMAMUX->CHCFG[KINETIS_SPI1_RX_DMAMUX_CHANNEL] = DMAMUX_CHCFGn_ENBL |
    39b2:	7007      	strb	r7, [r0, #0]
        DMAMUX_CHCFGn_SOURCE(DMAMUX_SPI_RX_SOURCE);

    /* Tx, select SPI Tx FIFO */
    DMAMUX->CHCFG[KINETIS_SPI1_TX_DMAMUX_CHANNEL] = DMAMUX_CHCFGn_ENBL |
    39b4:	7047      	strb	r7, [r0, #1]
        DMAMUX_CHCFGn_SOURCE(DMAMUX_SPI_TX_SOURCE);

    /* Extract the frame size from the TAR */
    uint16_t frame_size = ((spip->spi->CTAR[0] >> SPIx_CTARn_FMSZ_SHIFT) &
    39b6:	69e2      	ldr	r2, [r4, #28]
    39b8:	68d2      	ldr	r2, [r2, #12]
    39ba:	f3c2 62c3 	ubfx	r2, r2, #27, #4
        SPIx_CTARn_FMSZ_MASK) + 1;

    /* DMA transfer size is 16 bits for a frame size > 8 bits */
    uint16_t dma_size = frame_size > 8 ? 1 : 0;
    39be:	3201      	adds	r2, #1
    39c0:	2a08      	cmp	r2, #8
    39c2:	bf94      	ite	ls
    39c4:	2200      	movls	r2, #0
    39c6:	2201      	movhi	r2, #1

    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;
    39c8:	2a00      	cmp	r2, #0
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    39ca:	f241 0b08 	movw	fp, #4104	; 0x1008

    /* DMA transfer size is 16 bits for a frame size > 8 bits */
    uint16_t dma_size = frame_size > 8 ? 1 : 0;

    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;
    39ce:	bf14      	ite	ne
    39d0:	2002      	movne	r0, #2
    39d2:	2001      	moveq	r0, #1

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    39d4:	f241 0918 	movw	r9, #4120	; 0x1018
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK |
        DMA_CSR_INTMAJOR_MASK;

    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    39d8:	f241 082c 	movw	r8, #4140	; 0x102c
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    39dc:	f241 0e30 	movw	lr, #4144	; 0x1030
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    39e0:	f241 0738 	movw	r7, #4152	; 0x1038
    spip->word_size = frame_size > 8 ? 2 : 1;

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    39e4:	f241 0a0c 	movw	sl, #4108	; 0x100c

    /* DMA transfer size is 16 bits for a frame size > 8 bits */
    uint16_t dma_size = frame_size > 8 ? 1 : 0;

    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;
    39e8:	6260      	str	r0, [r4, #36]	; 0x24
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    39ea:	f843 000b 	str.w	r0, [r3, fp]
    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    39ee:	2000      	movs	r0, #0
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    39f0:	f843 000a 	str.w	r0, [r3, sl]
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    39f4:	f843 0009 	str.w	r0, [r3, r9]
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK |
        DMA_CSR_INTMAJOR_MASK;

    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    39f8:	f843 0008 	str.w	r0, [r3, r8]
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    39fc:	f843 c00e 	str.w	ip, [r3, lr]
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    3a00:	51d8      	str	r0, [r3, r7]
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    3a02:	f241 0928 	movw	r9, #4136	; 0x1028

    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    3a06:	602e      	str	r6, [r5, #0]
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    3a08:	6a64      	ldr	r4, [r4, #36]	; 0x24
    3a0a:	f843 4009 	str.w	r4, [r3, r9]
    /* Extract the frame size from the TAR */
    uint16_t frame_size = ((spip->spi->CTAR[0] >> SPIx_CTARn_FMSZ_SHIFT) &
        SPIx_CTARn_FMSZ_MASK) + 1;

    /* DMA transfer size is 16 bits for a frame size > 8 bits */
    uint16_t dma_size = frame_size > 8 ? 1 : 0;
    3a0e:	b292      	uxth	r2, r2
    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    3a10:	f241 0804 	movw	r8, #4100	; 0x1004
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
    3a14:	0215      	lsls	r5, r2, #8
    3a16:	f241 0c06 	movw	ip, #4102	; 0x1006
    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
    3a1a:	f241 0e26 	movw	lr, #4134	; 0x1026
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK |
    3a1e:	f241 071c 	movw	r7, #4124	; 0x101c
        DMA_CSR_INTMAJOR_MASK;

    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    3a22:	f241 0634 	movw	r6, #4148	; 0x1034
    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
    3a26:	432a      	orrs	r2, r5
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK;
    3a28:	f04f 0908 	mov.w	r9, #8
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK |
    3a2c:	240a      	movs	r4, #10
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK;
    3a2e:	f823 9001 	strh.w	r9, [r3, r1]
    /* DMA word size is 2 for a 16 bit frame size */
    spip->word_size = frame_size > 8 ? 2 : 1;

    /* configure DMA RX fixed values */
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SADDR = (uint32_t)&SPI1->POPR;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SOFF = 0;
    3a32:	f823 0008 	strh.w	r0, [r3, r8]
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
    3a36:	f823 200c 	strh.w	r2, [r3, ip]
    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
    3a3a:	f823 200e 	strh.w	r2, [r3, lr]
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].DLASTSGA = 0;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].ATTR = DMA_ATTR_SSIZE(dma_size) |
        DMA_ATTR_DSIZE(dma_size);
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].NBYTES_MLNO = spip->word_size;
    DMA->TCD[KINETIS_SPI1_RX_DMA_CHANNEL].CSR = DMA_CSR_DREQ_MASK |
    3a3e:	53dc      	strh	r4, [r3, r7]
        DMA_CSR_INTMAJOR_MASK;

    /* configure DMA TX fixed values */
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].SLAST = 0;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DADDR = (uint32_t)&SPI1->PUSHR;
    DMA->TCD[KINETIS_SPI1_TX_DMA_CHANNEL].DOFF = 0;
    3a40:	5398      	strh	r0, [r3, r6]
    3a42:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

#if KINETIS_SPI_USE_SPI1
    if (&SPID2 == spip) {

      /* Enable the clock for SPI0 */
      SIM->SCGC6 |= SIM_SCGC6_SPI1;
    3a46:	4c09      	ldr	r4, [pc, #36]	; (3a6c <spi_lld_start+0x10c>)

      SPID2.spi = SPI1;

      if (spip->config->tar0) {
    3a48:	6845      	ldr	r5, [r0, #4]
    if (&SPID2 == spip) {

      /* Enable the clock for SPI0 */
      SIM->SCGC6 |= SIM_SCGC6_SPI1;

      SPID2.spi = SPI1;
    3a4a:	4a0d      	ldr	r2, [pc, #52]	; (3a80 <spi_lld_start+0x120>)

#if KINETIS_SPI_USE_SPI1
    if (&SPID2 == spip) {

      /* Enable the clock for SPI0 */
      SIM->SCGC6 |= SIM_SCGC6_SPI1;
    3a4c:	f241 013c 	movw	r1, #4156	; 0x103c
    3a50:	5863      	ldr	r3, [r4, r1]
    3a52:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    3a56:	5063      	str	r3, [r4, r1]

      SPID2.spi = SPI1;

      if (spip->config->tar0) {
    3a58:	68eb      	ldr	r3, [r5, #12]
    if (&SPID2 == spip) {

      /* Enable the clock for SPI0 */
      SIM->SCGC6 |= SIM_SCGC6_SPI1;

      SPID2.spi = SPI1;
    3a5a:	61c2      	str	r2, [r0, #28]

      if (spip->config->tar0) {
    3a5c:	b10b      	cbz	r3, 3a62 <spi_lld_start+0x102>
        spip->spi->CTAR[0] = spip->config->tar0;
      } else {
        spip->spi->CTAR[0] = KINETIS_SPI_TAR0_DEFAULT;
    3a5e:	60d3      	str	r3, [r2, #12]
    3a60:	e788      	b.n	3974 <spi_lld_start+0x14>
    3a62:	f04f 433e 	mov.w	r3, #3187671040	; 0xbe000000
    3a66:	e7fa      	b.n	3a5e <spi_lld_start+0xfe>
    3a68:	1ffff3c8 	.word	0x1ffff3c8
    3a6c:	40047000 	.word	0x40047000
    3a70:	40008000 	.word	0x40008000
    3a74:	40021000 	.word	0x40021000
    3a78:	40009000 	.word	0x40009000
    3a7c:	4002d038 	.word	0x4002d038
    3a80:	4002d000 	.word	0x4002d000
    3a84:	40048040 	.word	0x40048040
    3a88:	4002d034 	.word	0x4002d034
    3a8c:	f3af 8000 	nop.w

00003a90 <spi_lld_select>:
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {

  palClearPad(spip->config->ssport, spip->config->sspad);
    3a90:	6843      	ldr	r3, [r0, #4]
    3a92:	8919      	ldrh	r1, [r3, #8]
    3a94:	685a      	ldr	r2, [r3, #4]
    3a96:	2301      	movs	r3, #1
    3a98:	408b      	lsls	r3, r1
    3a9a:	6093      	str	r3, [r2, #8]
    3a9c:	4770      	bx	lr
    3a9e:	bf00      	nop

00003aa0 <spi_lld_unselect>:
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {

  palSetPad(spip->config->ssport, spip->config->sspad);
    3aa0:	6843      	ldr	r3, [r0, #4]
    3aa2:	8919      	ldrh	r1, [r3, #8]
    3aa4:	685a      	ldr	r2, [r3, #4]
    3aa6:	2301      	movs	r3, #1
    3aa8:	408b      	lsls	r3, r1
    3aaa:	6053      	str	r3, [r2, #4]
    3aac:	4770      	bx	lr
    3aae:	bf00      	nop

00003ab0 <serve_interrupt>:
 *          want to go through the whole ISR and have another interrupt soon
 *          after.
 *
 * @param[in] i2cp         pointer to an I2CDriver
 */
static void serve_interrupt(I2CDriver *i2cp) {
    3ab0:	b538      	push	{r3, r4, r5, lr}

  I2C_TypeDef *i2c = i2cp->i2c;
    3ab2:	6c03      	ldr	r3, [r0, #64]	; 0x40
  intstate_t state = i2cp->intstate;
    3ab4:	f890 103c 	ldrb.w	r1, [r0, #60]	; 0x3c

  /* check if we're master or slave */
  if (i2c->C1 & I2Cx_C1_MST) {
    3ab8:	789a      	ldrb	r2, [r3, #2]
 *          want to go through the whole ISR and have another interrupt soon
 *          after.
 *
 * @param[in] i2cp         pointer to an I2CDriver
 */
static void serve_interrupt(I2CDriver *i2cp) {
    3aba:	4604      	mov	r4, r0

  I2C_TypeDef *i2c = i2cp->i2c;
  intstate_t state = i2cp->intstate;

  /* check if we're master or slave */
  if (i2c->C1 & I2Cx_C1_MST) {
    3abc:	0690      	lsls	r0, r2, #26
    3abe:	d50f      	bpl.n	3ae0 <serve_interrupt+0x30>
    /* master */

    if (i2c->S & I2Cx_S_ARBL) {
    3ac0:	78da      	ldrb	r2, [r3, #3]
    3ac2:	06d2      	lsls	r2, r2, #27
    3ac4:	d509      	bpl.n	3ada <serve_interrupt+0x2a>
      /* check if we lost arbitration */
      i2cp->errors |= I2C_ARBITRATION_LOST;
    3ac6:	68a2      	ldr	r2, [r4, #8]
    3ac8:	f042 0202 	orr.w	r2, r2, #2
    3acc:	60a2      	str	r2, [r4, #8]
      i2c->S |= I2Cx_S_ARBL;
    3ace:	78da      	ldrb	r2, [r3, #3]
    3ad0:	f042 0210 	orr.w	r2, r2, #16
    3ad4:	70da      	strb	r2, [r3, #3]
    3ad6:	6c21      	ldr	r1, [r4, #64]	; 0x40
    3ad8:	e003      	b.n	3ae2 <serve_interrupt+0x32>
      i2c->S |= I2Cx_S_IICIF;
      _i2c_wakeup_isr(i2cp);
    }
#endif /* KL27Z RST workaround */

    else if (i2c->S & I2Cx_S_TCF) {
    3ada:	78da      	ldrb	r2, [r3, #3]
    3adc:	0615      	lsls	r5, r2, #24
    3ade:	d435      	bmi.n	3b4c <serve_interrupt+0x9c>
    3ae0:	4619      	mov	r1, r3
    /* Not implemented yet */
  }

  /* Reset other interrupt sources */
#if defined(I2Cx_FLT_STOPF) /* extra flags on KL26Z and KL27Z */
  i2cp->i2c->FLT |= I2Cx_FLT_STOPF;
    3ae2:	798a      	ldrb	r2, [r1, #6]
    3ae4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    3ae8:	718a      	strb	r2, [r1, #6]
#endif
#if defined(I2Cx_FLT_STARTF) /* extra flags on KL27Z */
  i2cp->i2c->FLT |= I2Cx_FLT_STARTF;
#endif
  /* Reset interrupt flag */
  i2c->S |= I2Cx_S_IICIF;
    3aea:	78da      	ldrb	r2, [r3, #3]
    3aec:	f042 0202 	orr.w	r2, r2, #2
    3af0:	70da      	strb	r2, [r3, #3]

  if (i2cp->errors != I2C_NO_ERROR)
    3af2:	68a3      	ldr	r3, [r4, #8]
    3af4:	b9ab      	cbnz	r3, 3b22 <serve_interrupt+0x72>
    _i2c_wakeup_error_isr(i2cp);

  if (i2cp->intstate == STATE_STOP)
    3af6:	f894 503c 	ldrb.w	r5, [r4, #60]	; 0x3c
    3afa:	b98d      	cbnz	r5, 3b20 <serve_interrupt+0x70>
    3afc:	2320      	movs	r3, #32
    3afe:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    3b02:	f7fe f8e5 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3b06:	f7fd fabb 	bl	1080 <_dbg_check_lock_from_isr>
    3b0a:	f104 001c 	add.w	r0, r4, #28
    3b0e:	4629      	mov	r1, r5
    3b10:	f7fd ffc6 	bl	1aa0 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    3b14:	f7fd facc 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3b18:	f7fe f8e2 	bl	1ce0 <_stats_stop_measure_crit_isr>
    3b1c:	f385 8811 	msr	BASEPRI, r5
    3b20:	bd38      	pop	{r3, r4, r5, pc}
    3b22:	2320      	movs	r3, #32
    3b24:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    3b28:	f7fe f8d2 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3b2c:	f7fd faa8 	bl	1080 <_dbg_check_lock_from_isr>
    3b30:	f104 001c 	add.w	r0, r4, #28
    3b34:	f06f 0101 	mvn.w	r1, #1
    3b38:	f7fd ffb2 	bl	1aa0 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    3b3c:	f7fd fab8 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3b40:	f7fe f8ce 	bl	1ce0 <_stats_stop_measure_crit_isr>
    3b44:	2300      	movs	r3, #0
    3b46:	f383 8811 	msr	BASEPRI, r3
    3b4a:	e7d4      	b.n	3af6 <serve_interrupt+0x46>
    }
#endif /* KL27Z RST workaround */

    else if (i2c->S & I2Cx_S_TCF) {
      /* just completed byte transfer */
      if (i2c->C1 & I2Cx_C1_TX) {
    3b4c:	789a      	ldrb	r2, [r3, #2]
    3b4e:	06d0      	lsls	r0, r2, #27
    3b50:	d41a      	bmi.n	3b88 <serve_interrupt+0xd8>
        } /* possibly check other states here - should not happen! */

      } else {
        /* the byte was received */

        if (state == STATE_RECV) {
    3b52:	2902      	cmp	r1, #2
    3b54:	d1c4      	bne.n	3ae0 <serve_interrupt+0x30>
          /* currently receiving stuff */
          /* the received byte is now in D */

          if (i2cp->rxbytes > 1) {
    3b56:	6b62      	ldr	r2, [r4, #52]	; 0x34
    3b58:	2a01      	cmp	r2, #1
    3b5a:	d90a      	bls.n	3b72 <serve_interrupt+0xc2>
            /* expecting at least one byte after this one */
            if (i2cp->rxidx == (i2cp->rxbytes - 2)) {
    3b5c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3b5e:	3a02      	subs	r2, #2
    3b60:	4291      	cmp	r1, r2
              /* expecting exactly one byte after this one, NAK that one */
              i2c->C1 |= I2Cx_C1_TXAK;
    3b62:	789a      	ldrb	r2, [r3, #2]
    3b64:	bf0c      	ite	eq
    3b66:	f042 0208 	orreq.w	r2, r2, #8
            } else {
              /* expecting more than one after this one, respond with ACK */
              i2c->C1 &= ~I2Cx_C1_TXAK;
    3b6a:	f002 02f7 	andne.w	r2, r2, #247	; 0xf7
    3b6e:	709a      	strb	r2, [r3, #2]
    3b70:	6b62      	ldr	r2, [r4, #52]	; 0x34
            }
          }

          if (i2cp->rxidx == i2cp->rxbytes - 1) {
    3b72:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3b74:	3a01      	subs	r2, #1
    3b76:	4291      	cmp	r1, r2
    3b78:	d037      	beq.n	3bea <serve_interrupt+0x13a>
            i2cp->intstate = STATE_STOP;
            /* this wakes up the waiting thread at the end of ISR */
          }

          /* get the data from D; this triggers the next receive */
          i2cp->rxbuf[i2cp->rxidx++] = i2c->D;
    3b7a:	1c4a      	adds	r2, r1, #1
    3b7c:	63a2      	str	r2, [r4, #56]	; 0x38
    3b7e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    3b80:	7918      	ldrb	r0, [r3, #4]
    3b82:	5450      	strb	r0, [r2, r1]
    3b84:	6c21      	ldr	r1, [r4, #64]	; 0x40
    3b86:	e7ac      	b.n	3ae2 <serve_interrupt+0x32>
    else if (i2c->S & I2Cx_S_TCF) {
      /* just completed byte transfer */
      if (i2c->C1 & I2Cx_C1_TX) {
        /* the byte was transmitted */

        if (state == STATE_SEND) {
    3b88:	2901      	cmp	r1, #1
    3b8a:	d014      	beq.n	3bb6 <serve_interrupt+0x106>
            /* slave ACK'd and we are done sending */
            i2cp->intstate = STATE_STOP;
            /* this wakes up the waiting thread at the end of ISR */
          }

        } else if (state == STATE_RECV) {
    3b8c:	2902      	cmp	r1, #2
    3b8e:	d1a7      	bne.n	3ae0 <serve_interrupt+0x30>
          /* should be receiving stuff, so we've just sent the address */

          if (i2c->S & I2Cx_S_RXAK) {
    3b90:	78da      	ldrb	r2, [r3, #3]
    3b92:	07d2      	lsls	r2, r2, #31
    3b94:	d41e      	bmi.n	3bd4 <serve_interrupt+0x124>
            i2cp->errors |= I2C_ACK_FAILURE;
            /* the thread will be woken up and release the bus */

          } else {
            /* slave ACK'd, we should be receiving next */
            i2c->C1 &= ~I2Cx_C1_TX;
    3b96:	789a      	ldrb	r2, [r3, #2]
    3b98:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    3b9c:	709a      	strb	r2, [r3, #2]

            if (i2cp->rxbytes > 1) {
    3b9e:	6b62      	ldr	r2, [r4, #52]	; 0x34
    3ba0:	2a01      	cmp	r2, #1
              /* multi-byte read, send ACK after next transfer */
              i2c->C1 &= ~I2Cx_C1_TXAK;
    3ba2:	789a      	ldrb	r2, [r3, #2]
    3ba4:	bf8c      	ite	hi
    3ba6:	f002 02f7 	andhi.w	r2, r2, #247	; 0xf7
            } else {
              /* only 1 byte remaining, send NAK */
              i2c->C1 |= I2Cx_C1_TXAK;
    3baa:	f042 0208 	orrls.w	r2, r2, #8
    3bae:	709a      	strb	r2, [r3, #2]
            }

            (void) i2c->D; /* dummy read; triggers next receive */
    3bb0:	791a      	ldrb	r2, [r3, #4]
    3bb2:	6c21      	ldr	r1, [r4, #64]	; 0x40
    3bb4:	e795      	b.n	3ae2 <serve_interrupt+0x32>
        /* the byte was transmitted */

        if (state == STATE_SEND) {
          /* currently sending stuff */

          if (i2c->S & I2Cx_S_RXAK) {
    3bb6:	78da      	ldrb	r2, [r3, #3]
    3bb8:	07d1      	lsls	r1, r2, #31
    3bba:	d40b      	bmi.n	3bd4 <serve_interrupt+0x124>
            /* slave did not ACK */
            i2cp->errors |= I2C_ACK_FAILURE;
            /* the thread will be woken up at the end of ISR and release the bus */

          } else if (i2cp->txbuf != NULL && i2cp->txidx < i2cp->txbytes) {
    3bbc:	6a61      	ldr	r1, [r4, #36]	; 0x24
    3bbe:	b179      	cbz	r1, 3be0 <serve_interrupt+0x130>
    3bc0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    3bc2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    3bc4:	4282      	cmp	r2, r0
    3bc6:	d20b      	bcs.n	3be0 <serve_interrupt+0x130>
            /* slave ACK'd and we want to send more */
            i2c->D = i2cp->txbuf[i2cp->txidx++];
    3bc8:	1c50      	adds	r0, r2, #1
    3bca:	62e0      	str	r0, [r4, #44]	; 0x2c
    3bcc:	5c8a      	ldrb	r2, [r1, r2]
    3bce:	711a      	strb	r2, [r3, #4]
    3bd0:	6c21      	ldr	r1, [r4, #64]	; 0x40
    3bd2:	e786      	b.n	3ae2 <serve_interrupt+0x32>
        } else if (state == STATE_RECV) {
          /* should be receiving stuff, so we've just sent the address */

          if (i2c->S & I2Cx_S_RXAK) {
            /* slave did not ACK */
            i2cp->errors |= I2C_ACK_FAILURE;
    3bd4:	68a2      	ldr	r2, [r4, #8]
    3bd6:	f042 0204 	orr.w	r2, r2, #4
    3bda:	60a2      	str	r2, [r4, #8]
    3bdc:	4619      	mov	r1, r3
    3bde:	e780      	b.n	3ae2 <serve_interrupt+0x32>
          } else if (i2cp->txbuf != NULL && i2cp->txidx < i2cp->txbytes) {
            /* slave ACK'd and we want to send more */
            i2c->D = i2cp->txbuf[i2cp->txidx++];
          } else {
            /* slave ACK'd and we are done sending */
            i2cp->intstate = STATE_STOP;
    3be0:	2200      	movs	r2, #0
    3be2:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    3be6:	4619      	mov	r1, r3
    3be8:	e77b      	b.n	3ae2 <serve_interrupt+0x32>
          if (i2cp->rxidx == i2cp->rxbytes - 1) {
            /* D is the last byte we're expecting */
            /* release bus: switch to RX mode, send STOP */
            /* need to do it now otherwise the I2C module will wait for another byte */
            // delayMicroseconds(1);
            i2c->C1 &= ~(I2Cx_C1_TX | I2Cx_C1_MST);
    3bea:	789a      	ldrb	r2, [r3, #2]
    3bec:	f002 02cf 	and.w	r2, r2, #207	; 0xcf
    3bf0:	709a      	strb	r2, [r3, #2]
            i2cp->intstate = STATE_STOP;
    3bf2:	2200      	movs	r2, #0
    3bf4:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3bf6:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    3bfa:	e7be      	b.n	3b7a <serve_interrupt+0xca>
    3bfc:	f3af 8000 	nop.w

00003c00 <config_frequency>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

void config_frequency(I2CDriver *i2cp) {
    3c00:	b5f0      	push	{r4, r5, r6, r7, lr}
    3c02:	4607      	mov	r7, r0
    3c04:	b0a1      	sub	sp, #132	; 0x84

  /* Each index in the table corresponds to a a frequency
   * divider used to generate the SCL clock from the main
   * system clock.
   */
  const uint16_t icr_table[] = {
    3c06:	4914      	ldr	r1, [pc, #80]	; (3c58 <config_frequency+0x58>)
    3c08:	4668      	mov	r0, sp
    3c0a:	2280      	movs	r2, #128	; 0x80
    3c0c:	f002 fd20 	bl	6650 <memcpy>
  int length = sizeof(icr_table) / sizeof(icr_table[0]);
  uint16_t divisor;
  uint8_t i = 0, index = 0;
  uint16_t best, diff;

  if (i2cp->config != NULL)
    3c10:	687b      	ldr	r3, [r7, #4]
    3c12:	b1f3      	cbz	r3, 3c52 <config_frequency+0x52>
    divisor = KINETIS_BUSCLK_FREQUENCY / i2cp->config->clock;
    3c14:	681c      	ldr	r4, [r3, #0]
    3c16:	4b11      	ldr	r3, [pc, #68]	; (3c5c <config_frequency+0x5c>)
    3c18:	fbb3 f4f4 	udiv	r4, r3, r4
    3c1c:	b2a4      	uxth	r4, r4

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

void config_frequency(I2CDriver *i2cp) {
    3c1e:	2300      	movs	r3, #0
    3c20:	469e      	mov	lr, r3
    3c22:	f1ad 0502 	sub.w	r5, sp, #2
    3c26:	f64f 70ff 	movw	r0, #65535	; 0xffff
   * approximation to the clock passed in config. To
   * stay on the safe side, only values that generate
   * lower frequency are used.
   */
  for (i = 0; i < length; i++) {
    if (icr_table[i] >= divisor) {
    3c2a:	f835 1f02 	ldrh.w	r1, [r5, #2]!
      diff = icr_table[i] - divisor;
    3c2e:	1b0a      	subs	r2, r1, r4
   * approximation to the clock passed in config. To
   * stay on the safe side, only values that generate
   * lower frequency are used.
   */
  for (i = 0; i < length; i++) {
    if (icr_table[i] >= divisor) {
    3c30:	42a1      	cmp	r1, r4
    3c32:	b2de      	uxtb	r6, r3
      diff = icr_table[i] - divisor;
    3c34:	b292      	uxth	r2, r2
    3c36:	f103 0301 	add.w	r3, r3, #1
   * approximation to the clock passed in config. To
   * stay on the safe side, only values that generate
   * lower frequency are used.
   */
  for (i = 0; i < length; i++) {
    if (icr_table[i] >= divisor) {
    3c3a:	d303      	bcc.n	3c44 <config_frequency+0x44>
      diff = icr_table[i] - divisor;
      if (diff < best) {
    3c3c:	4282      	cmp	r2, r0
    3c3e:	bf3c      	itt	cc
    3c40:	4610      	movcc	r0, r2
    3c42:	46b6      	movcc	lr, r6
  /* Tries to find the SCL clock which is the closest
   * approximation to the clock passed in config. To
   * stay on the safe side, only values that generate
   * lower frequency are used.
   */
  for (i = 0; i < length; i++) {
    3c44:	2b40      	cmp	r3, #64	; 0x40
    3c46:	d1f0      	bne.n	3c2a <config_frequency+0x2a>
        index = i;
      }
    }
  }

  i2cp->i2c->F = index;
    3c48:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    3c4a:	f883 e001 	strb.w	lr, [r3, #1]
}
    3c4e:	b021      	add	sp, #132	; 0x84
    3c50:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint16_t best, diff;

  if (i2cp->config != NULL)
    divisor = KINETIS_BUSCLK_FREQUENCY / i2cp->config->clock;
  else
    divisor = KINETIS_BUSCLK_FREQUENCY / 100000;
    3c52:	f240 14df 	movw	r4, #479	; 0x1df
    3c56:	e7e2      	b.n	3c1e <config_frequency+0x1e>
    3c58:	00006850 	.word	0x00006850
    3c5c:	02dc4000 	.word	0x02dc4000

00003c60 <VectorA0>:
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

#if KINETIS_I2C_USE_I2C0 || defined(__DOXYGEN__)

OSAL_IRQ_HANDLER(KINETIS_I2C0_IRQ_VECTOR) {
    3c60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3c62:	f7fd fffd 	bl	1c60 <_stats_increase_irq>
    3c66:	f7fd fa3b 	bl	10e0 <_dbg_check_enter_isr>
  serve_interrupt(&I2CD1);
    3c6a:	4804      	ldr	r0, [pc, #16]	; (3c7c <VectorA0+0x1c>)
    3c6c:	f7ff ff20 	bl	3ab0 <serve_interrupt>
  OSAL_IRQ_EPILOGUE();
    3c70:	f7fd fa4e 	bl	1110 <_dbg_check_leave_isr>
}
    3c74:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

OSAL_IRQ_HANDLER(KINETIS_I2C0_IRQ_VECTOR) {

  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&I2CD1);
  OSAL_IRQ_EPILOGUE();
    3c78:	f7fe bd4a 	b.w	2710 <_port_irq_epilogue>
    3c7c:	1ffff3f8 	.word	0x1ffff3f8

00003c80 <VectorA4>:

#endif

#if KINETIS_I2C_USE_I2C1 || defined(__DOXYGEN__)

OSAL_IRQ_HANDLER(KINETIS_I2C1_IRQ_VECTOR) {
    3c80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3c82:	f7fd ffed 	bl	1c60 <_stats_increase_irq>
    3c86:	f7fd fa2b 	bl	10e0 <_dbg_check_enter_isr>
  serve_interrupt(&I2CD2);
    3c8a:	4804      	ldr	r0, [pc, #16]	; (3c9c <VectorA4+0x1c>)
    3c8c:	f7ff ff10 	bl	3ab0 <serve_interrupt>
  OSAL_IRQ_EPILOGUE();
    3c90:	f7fd fa3e 	bl	1110 <_dbg_check_leave_isr>
}
    3c94:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

OSAL_IRQ_HANDLER(KINETIS_I2C1_IRQ_VECTOR) {

  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&I2CD2);
  OSAL_IRQ_EPILOGUE();
    3c98:	f7fe bd3a 	b.w	2710 <_port_irq_epilogue>
    3c9c:	1ffff43c 	.word	0x1ffff43c

00003ca0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
    3ca0:	b570      	push	{r4, r5, r6, lr}

#if KINETIS_I2C_USE_I2C0
  i2cObjectInit(&I2CD1);
    3ca2:	4d08      	ldr	r5, [pc, #32]	; (3cc4 <i2c_lld_init+0x24>)
  I2CD1.thread = NULL;
  I2CD1.i2c = I2C0;
#endif

#if KINETIS_I2C_USE_I2C1
  i2cObjectInit(&I2CD2);
    3ca4:	4c08      	ldr	r4, [pc, #32]	; (3cc8 <i2c_lld_init+0x28>)
 * @notapi
 */
void i2c_lld_init(void) {

#if KINETIS_I2C_USE_I2C0
  i2cObjectInit(&I2CD1);
    3ca6:	4628      	mov	r0, r5
    3ca8:	f7fe ffda 	bl	2c60 <i2cObjectInit>
  I2CD1.thread = NULL;
    3cac:	2600      	movs	r6, #0
  I2CD1.i2c = I2C0;
    3cae:	4b07      	ldr	r3, [pc, #28]	; (3ccc <i2c_lld_init+0x2c>)
    3cb0:	642b      	str	r3, [r5, #64]	; 0x40
#endif

#if KINETIS_I2C_USE_I2C1
  i2cObjectInit(&I2CD2);
    3cb2:	4620      	mov	r0, r4
 */
void i2c_lld_init(void) {

#if KINETIS_I2C_USE_I2C0
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
    3cb4:	61ee      	str	r6, [r5, #28]
  I2CD1.i2c = I2C0;
#endif

#if KINETIS_I2C_USE_I2C1
  i2cObjectInit(&I2CD2);
    3cb6:	f7fe ffd3 	bl	2c60 <i2cObjectInit>
  I2CD2.thread = NULL;
  I2CD2.i2c = I2C1;
    3cba:	4b05      	ldr	r3, [pc, #20]	; (3cd0 <i2c_lld_init+0x30>)
  I2CD1.i2c = I2C0;
#endif

#if KINETIS_I2C_USE_I2C1
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
    3cbc:	61e6      	str	r6, [r4, #28]
  I2CD2.i2c = I2C1;
    3cbe:	6423      	str	r3, [r4, #64]	; 0x40
    3cc0:	bd70      	pop	{r4, r5, r6, pc}
    3cc2:	bf00      	nop
    3cc4:	1ffff3f8 	.word	0x1ffff3f8
    3cc8:	1ffff43c 	.word	0x1ffff43c
    3ccc:	40066000 	.word	0x40066000
    3cd0:	40067000 	.word	0x40067000
    3cd4:	f3af 8000 	nop.w
    3cd8:	f3af 8000 	nop.w
    3cdc:	f3af 8000 	nop.w

00003ce0 <i2c_lld_start>:
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {

  if (i2cp->state == I2C_STOP) {
    3ce0:	6803      	ldr	r3, [r0, #0]
    3ce2:	2b01      	cmp	r3, #1
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    3ce4:	b510      	push	{r4, lr}
    3ce6:	4604      	mov	r4, r0

  if (i2cp->state == I2C_STOP) {
    3ce8:	d00c      	beq.n	3d04 <i2c_lld_start+0x24>
    }
#endif

  }

  config_frequency(i2cp);
    3cea:	4620      	mov	r0, r4
    3cec:	f7ff ff88 	bl	3c00 <config_frequency>
  i2cp->i2c->C1 = I2Cx_C1_IICEN | I2Cx_C1_IICIE; // reset I2C, enable interrupts
    3cf0:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3cf2:	22c0      	movs	r2, #192	; 0xc0
    3cf4:	709a      	strb	r2, [r3, #2]
  i2cp->i2c->S = I2Cx_S_IICIF | I2Cx_S_ARBL; // clear status flags just in case
    3cf6:	6c22      	ldr	r2, [r4, #64]	; 0x40
    3cf8:	2112      	movs	r1, #18
  i2cp->intstate = STATE_STOP; // internal state
    3cfa:	2300      	movs	r3, #0

  }

  config_frequency(i2cp);
  i2cp->i2c->C1 = I2Cx_C1_IICEN | I2Cx_C1_IICIE; // reset I2C, enable interrupts
  i2cp->i2c->S = I2Cx_S_IICIF | I2Cx_S_ARBL; // clear status flags just in case
    3cfc:	70d1      	strb	r1, [r2, #3]
  i2cp->intstate = STATE_STOP; // internal state
    3cfe:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    3d02:	bd10      	pop	{r4, pc}
   *   than be enabled. The easier way is enabling all PORTs at
   *   startup, which is currently being done in __early_init.
   */

#if KINETIS_I2C_USE_I2C0
    if (&I2CD1 == i2cp) {
    3d04:	4b0e      	ldr	r3, [pc, #56]	; (3d40 <i2c_lld_start+0x60>)
    3d06:	4298      	cmp	r0, r3
    3d08:	d00e      	beq.n	3d28 <i2c_lld_start+0x48>
      nvicEnableVector(I2C0_IRQn, KINETIS_I2C_I2C0_PRIORITY);
    }
#endif

#if KINETIS_I2C_USE_I2C1
    if (&I2CD2 == i2cp) {
    3d0a:	4b0e      	ldr	r3, [pc, #56]	; (3d44 <i2c_lld_start+0x64>)
    3d0c:	4298      	cmp	r0, r3
    3d0e:	d1ec      	bne.n	3cea <i2c_lld_start+0xa>
      SIM->SCGC4 |= SIM_SCGC4_I2C1;
    3d10:	490d      	ldr	r1, [pc, #52]	; (3d48 <i2c_lld_start+0x68>)
    3d12:	f241 0234 	movw	r2, #4148	; 0x1034
      nvicEnableVector(I2C1_IRQn, KINETIS_I2C_I2C1_PRIORITY);
    3d16:	2019      	movs	r0, #25
    }
#endif

#if KINETIS_I2C_USE_I2C1
    if (&I2CD2 == i2cp) {
      SIM->SCGC4 |= SIM_SCGC4_I2C1;
    3d18:	588b      	ldr	r3, [r1, r2]
    3d1a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3d1e:	508b      	str	r3, [r1, r2]
      nvicEnableVector(I2C1_IRQn, KINETIS_I2C_I2C1_PRIORITY);
    3d20:	2103      	movs	r1, #3
    3d22:	f7ff f9dd 	bl	30e0 <nvicEnableVector>
    3d26:	e7e0      	b.n	3cea <i2c_lld_start+0xa>
   *   startup, which is currently being done in __early_init.
   */

#if KINETIS_I2C_USE_I2C0
    if (&I2CD1 == i2cp) {
      SIM->SCGC4 |= SIM_SCGC4_I2C0;
    3d28:	4907      	ldr	r1, [pc, #28]	; (3d48 <i2c_lld_start+0x68>)
    3d2a:	f241 0234 	movw	r2, #4148	; 0x1034
      nvicEnableVector(I2C0_IRQn, KINETIS_I2C_I2C0_PRIORITY);
    3d2e:	2018      	movs	r0, #24
   *   startup, which is currently being done in __early_init.
   */

#if KINETIS_I2C_USE_I2C0
    if (&I2CD1 == i2cp) {
      SIM->SCGC4 |= SIM_SCGC4_I2C0;
    3d30:	588b      	ldr	r3, [r1, r2]
    3d32:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3d36:	508b      	str	r3, [r1, r2]
      nvicEnableVector(I2C0_IRQn, KINETIS_I2C_I2C0_PRIORITY);
    3d38:	2102      	movs	r1, #2
    3d3a:	f7ff f9d1 	bl	30e0 <nvicEnableVector>
    3d3e:	e7d4      	b.n	3cea <i2c_lld_start+0xa>
    3d40:	1ffff3f8 	.word	0x1ffff3f8
    3d44:	1ffff43c 	.word	0x1ffff43c
    3d48:	40047000 	.word	0x40047000
    3d4c:	f3af 8000 	nop.w

00003d50 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
    3d50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3d54:	4604      	mov	r4, r0
    3d56:	460e      	mov	r6, r1
  uint8_t op = (i2cp->intstate == STATE_SEND) ? 0 : 1;

  i2cp->errors = I2C_NO_ERROR;
  i2cp->addr = addr;

  i2cp->txbuf = txbuf;
    3d58:	6262      	str	r2, [r4, #36]	; 0x24
  i2cp->txbytes = txbytes;
    3d5a:	62a3      	str	r3, [r4, #40]	; 0x28
  i2cp->rsta_workaround = RSTA_WORKAROUND_OFF;
#endif /* KL27Z RST workaround */

  /* clear status flags */
#if defined(I2Cx_FLT_STOPF) /* extra flags on KL26Z and KL27Z */
  i2cp->i2c->FLT |= I2Cx_FLT_STOPF;
    3d5c:	6c21      	ldr	r1, [r4, #64]	; 0x40

  i2cp->txbuf = txbuf;
  i2cp->txbytes = txbytes;
  i2cp->txidx = 0;

  i2cp->rxbuf = rxbuf;
    3d5e:	9b08      	ldr	r3, [sp, #32]
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
    3d60:	9f09      	ldr	r7, [sp, #36]	; 0x24
  systime_t start, end;

  uint8_t op = (i2cp->intstate == STATE_SEND) ? 0 : 1;

  i2cp->errors = I2C_NO_ERROR;
  i2cp->addr = addr;
    3d62:	f884 6020 	strb.w	r6, [r4, #32]
  msg_t msg;
  systime_t start, end;

  uint8_t op = (i2cp->intstate == STATE_SEND) ? 0 : 1;

  i2cp->errors = I2C_NO_ERROR;
    3d66:	2200      	movs	r2, #0
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {

  i2cp->intstate = STATE_SEND;
    3d68:	2001      	movs	r0, #1
  msg_t msg;
  systime_t start, end;

  uint8_t op = (i2cp->intstate == STATE_SEND) ? 0 : 1;

  i2cp->errors = I2C_NO_ERROR;
    3d6a:	60a2      	str	r2, [r4, #8]
  i2cp->addr = addr;

  i2cp->txbuf = txbuf;
  i2cp->txbytes = txbytes;
  i2cp->txidx = 0;
    3d6c:	62e2      	str	r2, [r4, #44]	; 0x2c

  i2cp->rxbuf = rxbuf;
  i2cp->rxbytes = rxbytes;
  i2cp->rxidx = 0;
    3d6e:	63a2      	str	r2, [r4, #56]	; 0x38
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {

  i2cp->intstate = STATE_SEND;
    3d70:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

  i2cp->txbuf = txbuf;
  i2cp->txbytes = txbytes;
  i2cp->txidx = 0;

  i2cp->rxbuf = rxbuf;
    3d74:	6323      	str	r3, [r4, #48]	; 0x30
  i2cp->rxbytes = rxbytes;
    3d76:	6367      	str	r7, [r4, #52]	; 0x34
  i2cp->rsta_workaround = RSTA_WORKAROUND_OFF;
#endif /* KL27Z RST workaround */

  /* clear status flags */
#if defined(I2Cx_FLT_STOPF) /* extra flags on KL26Z and KL27Z */
  i2cp->i2c->FLT |= I2Cx_FLT_STOPF;
    3d78:	798b      	ldrb	r3, [r1, #6]
    3d7a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3d7e:	718b      	strb	r3, [r1, #6]
#endif
#if defined(I2Cx_FLT_STARTF) /* extra flags on KL27Z */
  i2cp->i2c->FLT |= I2Cx_FLT_STARTF;
#endif
  i2cp->i2c->S = I2Cx_S_IICIF|I2Cx_S_ARBL;
    3d80:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3d82:	2212      	movs	r2, #18
    3d84:	70da      	strb	r2, [r3, #3]

  /* acquire the bus */
  /* check to see if we already have the bus */
  if(i2cp->i2c->C1 & I2Cx_C1_MST) {
    3d86:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3d88:	789a      	ldrb	r2, [r3, #2]
    3d8a:	0691      	lsls	r1, r2, #26
    3d8c:	d52f      	bpl.n	3dee <i2c_lld_master_transmit_timeout+0x9e>
    i2cp->i2c->S |= I2Cx_S_IICIF|I2Cx_S_ARBL;
    i2cp->i2c->FLT |= I2Cx_FLT_SSIE;
#endif /* KL27Z RST workaround */

    /* send repeated start */
    i2cp->i2c->C1 |= I2Cx_C1_RSTA | I2Cx_C1_TX;
    3d8e:	789a      	ldrb	r2, [r3, #2]
    3d90:	f042 0214 	orr.w	r2, r2, #20
    3d94:	709a      	strb	r2, [r3, #2]
    /* send START */
    i2cp->i2c->C1 |= I2Cx_C1_MST|I2Cx_C1_TX;
  }

  /* send slave address */
  i2cp->i2c->D = addr << 1 | op;
    3d96:	0076      	lsls	r6, r6, #1
    3d98:	6c23      	ldr	r3, [r4, #64]	; 0x40
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {

  return chThdSuspendTimeoutS(trp, timeout);
    3d9a:	990a      	ldr	r1, [sp, #40]	; 0x28
    3d9c:	b2f6      	uxtb	r6, r6

  /* wait for the ISR to signal that the transmission (or receive if no transmission) phase is complete */
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
    3d9e:	f104 051c 	add.w	r5, r4, #28
    /* send START */
    i2cp->i2c->C1 |= I2Cx_C1_MST|I2Cx_C1_TX;
  }

  /* send slave address */
  i2cp->i2c->D = addr << 1 | op;
    3da2:	711e      	strb	r6, [r3, #4]
    3da4:	4628      	mov	r0, r5
    3da6:	f7fd fe5b 	bl	1a60 <chThdSuspendTimeoutS>
  //if (i2cp->i2c->S & I2Cx_S_RXAK)
  //  i2cp->errors |= I2C_ACK_FAILURE;

  /* the transmitting (or receiving if no transmission) phase has finished,
   * do we expect to receive something? */
  if (msg == MSG_OK && rxbuf != NULL && rxbytes > 0 && i2cp->rxidx < rxbytes) {
    3daa:	b9c8      	cbnz	r0, 3de0 <i2c_lld_master_transmit_timeout+0x90>
    3dac:	9b08      	ldr	r3, [sp, #32]
    3dae:	b1bb      	cbz	r3, 3de0 <i2c_lld_master_transmit_timeout+0x90>
    3db0:	b1b7      	cbz	r7, 3de0 <i2c_lld_master_transmit_timeout+0x90>
    3db2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3db4:	429f      	cmp	r7, r3
    3db6:	d913      	bls.n	3de0 <i2c_lld_master_transmit_timeout+0x90>
    i2cp->i2c->S |= I2Cx_S_IICIF|I2Cx_S_ARBL;
    i2cp->i2c->FLT |= I2Cx_FLT_SSIE;
#endif /* KL27Z RST workaround */

    /* send repeated start */
    i2cp->i2c->C1 |= I2Cx_C1_RSTA;
    3db8:	6c22      	ldr	r2, [r4, #64]	; 0x40
    3dba:	7893      	ldrb	r3, [r2, #2]
    3dbc:	f043 0304 	orr.w	r3, r3, #4
    3dc0:	7093      	strb	r3, [r2, #2]

    /* FIXME */
    // while (!(i2cp->i2c->S & I2Cx_S_BUSY));

    i2cp->intstate = STATE_RECV;
    i2cp->i2c->D = i2cp->addr << 1 | 1;
    3dc2:	f894 3020 	ldrb.w	r3, [r4, #32]
    3dc6:	6c22      	ldr	r2, [r4, #64]	; 0x40
    3dc8:	005b      	lsls	r3, r3, #1
    3dca:	f043 0301 	orr.w	r3, r3, #1
#endif /* KL27Z RST workaround */

    /* FIXME */
    // while (!(i2cp->i2c->S & I2Cx_S_BUSY));

    i2cp->intstate = STATE_RECV;
    3dce:	2102      	movs	r1, #2
    i2cp->i2c->D = i2cp->addr << 1 | 1;
    3dd0:	b2db      	uxtb	r3, r3
#endif /* KL27Z RST workaround */

    /* FIXME */
    // while (!(i2cp->i2c->S & I2Cx_S_BUSY));

    i2cp->intstate = STATE_RECV;
    3dd2:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
    3dd6:	4628      	mov	r0, r5
    3dd8:	990a      	ldr	r1, [sp, #40]	; 0x28
    i2cp->i2c->D = i2cp->addr << 1 | 1;
    3dda:	7113      	strb	r3, [r2, #4]
    3ddc:	f7fd fe40 	bl	1a60 <chThdSuspendTimeoutS>
    msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
  }

  /* release bus - RX mode, send STOP */
  // other kinetis I2C drivers wait here for 1us. is this needed?
  i2cp->i2c->C1 &= ~(I2Cx_C1_TX | I2Cx_C1_MST);
    3de0:	6c22      	ldr	r2, [r4, #64]	; 0x40
    3de2:	7893      	ldrb	r3, [r2, #2]
    3de4:	f003 03cf 	and.w	r3, r3, #207	; 0xcf
    3de8:	7093      	strb	r3, [r2, #2]
    3dea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3dee:	f8df 8090 	ldr.w	r8, [pc, #144]	; 3e80 <i2c_lld_master_transmit_timeout+0x130>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    3df2:	f7fd f92d 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    3df6:	f7fd ff63 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3dfa:	f8d8 3000 	ldr.w	r3, [r8]
    3dfe:	4543      	cmp	r3, r8
    3e00:	d005      	beq.n	3e0e <i2c_lld_master_transmit_timeout+0xbe>
    3e02:	f8d8 2018 	ldr.w	r2, [r8, #24]
    3e06:	689b      	ldr	r3, [r3, #8]
    3e08:	6892      	ldr	r2, [r2, #8]
    3e0a:	429a      	cmp	r2, r3
    3e0c:	d32f      	bcc.n	3e6e <i2c_lld_master_transmit_timeout+0x11e>
    3e0e:	2300      	movs	r3, #0
    3e10:	f383 8811 	msr	BASEPRI, r3
    3e14:	4d1a      	ldr	r5, [pc, #104]	; (3e80 <i2c_lld_master_transmit_timeout+0x130>)
    3e16:	f8d8 a028 	ldr.w	sl, [r8, #40]	; 0x28
    3e1a:	f04f 0920 	mov.w	r9, #32
    3e1e:	e017      	b.n	3e50 <i2c_lld_master_transmit_timeout+0x100>
    3e20:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
    3e24:	ebca 0303 	rsb	r3, sl, r3
         loop is exited in the locked state.*/
      if(!(i2cp->i2c->S & I2Cx_S_BUSY))
        break;
      /* If the system time went outside the allowed window then a timeout
         condition is returned.*/
      if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
    3e28:	2b31      	cmp	r3, #49	; 0x31
    3e2a:	d824      	bhi.n	3e76 <i2c_lld_master_transmit_timeout+0x126>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    3e2c:	f7fd f910 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    3e30:	f7fd ff46 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3e34:	682b      	ldr	r3, [r5, #0]
    3e36:	42ab      	cmp	r3, r5
    3e38:	d007      	beq.n	3e4a <i2c_lld_master_transmit_timeout+0xfa>
    3e3a:	69aa      	ldr	r2, [r5, #24]
    3e3c:	689b      	ldr	r3, [r3, #8]
    3e3e:	6892      	ldr	r2, [r2, #8]
    3e40:	429a      	cmp	r2, r3
    3e42:	d202      	bcs.n	3e4a <i2c_lld_master_transmit_timeout+0xfa>
    3e44:	480f      	ldr	r0, [pc, #60]	; (3e84 <i2c_lld_master_transmit_timeout+0x134>)
    3e46:	f7fd f89b 	bl	f80 <chSysHalt>
    3e4a:	2300      	movs	r3, #0
    3e4c:	f383 8811 	msr	BASEPRI, r3
    3e50:	f389 8811 	msr	BASEPRI, r9
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    3e54:	f7fd ff2c 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    3e58:	f7fd f8ea 	bl	1030 <_dbg_check_lock>

    while(true) {
      osalSysLock();
      /* If the bus is not busy then the operation can continue, note, the
         loop is exited in the locked state.*/
      if(!(i2cp->i2c->S & I2Cx_S_BUSY))
    3e5c:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3e5e:	78da      	ldrb	r2, [r3, #3]
    3e60:	0692      	lsls	r2, r2, #26
    3e62:	d4dd      	bmi.n	3e20 <i2c_lld_master_transmit_timeout+0xd0>
      }
      osalSysUnlock();
    }

    /* send START */
    i2cp->i2c->C1 |= I2Cx_C1_MST|I2Cx_C1_TX;
    3e64:	789a      	ldrb	r2, [r3, #2]
    3e66:	f042 0230 	orr.w	r2, r2, #48	; 0x30
    3e6a:	709a      	strb	r2, [r3, #2]
    3e6c:	e793      	b.n	3d96 <i2c_lld_master_transmit_timeout+0x46>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3e6e:	4805      	ldr	r0, [pc, #20]	; (3e84 <i2c_lld_master_transmit_timeout+0x134>)
    3e70:	f7fd f886 	bl	f80 <chSysHalt>
    3e74:	e7cb      	b.n	3e0e <i2c_lld_master_transmit_timeout+0xbe>
      if(!(i2cp->i2c->S & I2Cx_S_BUSY))
        break;
      /* If the system time went outside the allowed window then a timeout
         condition is returned.*/
      if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
        return MSG_TIMEOUT;
    3e76:	f04f 30ff 	mov.w	r0, #4294967295
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {

  i2cp->intstate = STATE_SEND;
  return _i2c_txrx_timeout(i2cp, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
}
    3e7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3e7e:	bf00      	nop
    3e80:	1ffff228 	.word	0x1ffff228
    3e84:	00006e50 	.word	0x00006e50
    3e88:	f3af 8000 	nop.w
    3e8c:	f3af 8000 	nop.w

00003e90 <Vector12C>:
 * @brief   PORTA interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTA_IRQ_VECTOR) && KINETIS_EXT_PORTA_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTA_IRQ_VECTOR) {
    3e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();
    3e94:	f7fd fee4 	bl	1c60 <_stats_increase_irq>
    3e98:	f7fd f922 	bl	10e0 <_dbg_check_enter_isr>
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3e9c:	4b12      	ldr	r3, [pc, #72]	; (3ee8 <Vector12C+0x58>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    3e9e:	4f13      	ldr	r7, [pc, #76]	; (3eec <Vector12C+0x5c>)
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3ea0:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3ea4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 3ef0 <Vector12C+0x60>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    3ea8:	f04f 32ff 	mov.w	r2, #4294967295
    3eac:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    3eb0:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    3eb2:	2501      	movs	r5, #1
    3eb4:	e002      	b.n	3ebc <Vector12C+0x2c>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3eb6:	3401      	adds	r4, #1
    3eb8:	2c14      	cmp	r4, #20
    3eba:	d00e      	beq.n	3eda <Vector12C+0x4a>
    if (isfr & (1 << pin)) {
    3ebc:	fa05 f304 	lsl.w	r3, r5, r4
    3ec0:	4233      	tst	r3, r6
    3ec2:	d0f8      	beq.n	3eb6 <Vector12C+0x26>
      expchannel_t channel = channel_map[pin];
    3ec4:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3ec6:	f8d8 3004 	ldr.w	r3, [r8, #4]
    3eca:	4809      	ldr	r0, [pc, #36]	; (3ef0 <Vector12C+0x60>)
    3ecc:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3ed0:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3ed2:	685b      	ldr	r3, [r3, #4]
    3ed4:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3ed6:	2c14      	cmp	r4, #20
    3ed8:	d1f0      	bne.n	3ebc <Vector12C+0x2c>
OSAL_IRQ_HANDLER(KINETIS_PORTA_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTA, KINETIS_EXT_PORTA_WIDTH, porta_channel_map);

  OSAL_IRQ_EPILOGUE();
    3eda:	f7fd f919 	bl	1110 <_dbg_check_leave_isr>
}
    3ede:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTA_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTA, KINETIS_EXT_PORTA_WIDTH, porta_channel_map);

  OSAL_IRQ_EPILOGUE();
    3ee2:	f7fe bc15 	b.w	2710 <_port_irq_epilogue>
    3ee6:	bf00      	nop
    3ee8:	40049000 	.word	0x40049000
    3eec:	1ffff4b4 	.word	0x1ffff4b4
    3ef0:	1ffff480 	.word	0x1ffff480
    3ef4:	f3af 8000 	nop.w
    3ef8:	f3af 8000 	nop.w
    3efc:	f3af 8000 	nop.w

00003f00 <Vector130>:
 * @brief   PORTB interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTB_IRQ_VECTOR) && KINETIS_EXT_PORTB_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTB_IRQ_VECTOR) {
    3f00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();
    3f04:	f7fd feac 	bl	1c60 <_stats_increase_irq>
    3f08:	f7fd f8ea 	bl	10e0 <_dbg_check_enter_isr>
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3f0c:	4b12      	ldr	r3, [pc, #72]	; (3f58 <Vector130+0x58>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    3f0e:	4f13      	ldr	r7, [pc, #76]	; (3f5c <Vector130+0x5c>)
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3f10:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3f14:	f8df 8048 	ldr.w	r8, [pc, #72]	; 3f60 <Vector130+0x60>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    3f18:	f04f 32ff 	mov.w	r2, #4294967295
    3f1c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    3f20:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    3f22:	2501      	movs	r5, #1
    3f24:	e002      	b.n	3f2c <Vector130+0x2c>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3f26:	3401      	adds	r4, #1
    3f28:	2c14      	cmp	r4, #20
    3f2a:	d00e      	beq.n	3f4a <Vector130+0x4a>
    if (isfr & (1 << pin)) {
    3f2c:	fa05 f304 	lsl.w	r3, r5, r4
    3f30:	4233      	tst	r3, r6
    3f32:	d0f8      	beq.n	3f26 <Vector130+0x26>
      expchannel_t channel = channel_map[pin];
    3f34:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3f36:	f8d8 3004 	ldr.w	r3, [r8, #4]
    3f3a:	4809      	ldr	r0, [pc, #36]	; (3f60 <Vector130+0x60>)
    3f3c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3f40:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3f42:	685b      	ldr	r3, [r3, #4]
    3f44:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3f46:	2c14      	cmp	r4, #20
    3f48:	d1f0      	bne.n	3f2c <Vector130+0x2c>
OSAL_IRQ_HANDLER(KINETIS_PORTB_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTB, KINETIS_EXT_PORTB_WIDTH, portb_channel_map);

  OSAL_IRQ_EPILOGUE();
    3f4a:	f7fd f8e1 	bl	1110 <_dbg_check_leave_isr>
}
    3f4e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTB_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTB, KINETIS_EXT_PORTB_WIDTH, portb_channel_map);

  OSAL_IRQ_EPILOGUE();
    3f52:	f7fe bbdd 	b.w	2710 <_port_irq_epilogue>
    3f56:	bf00      	nop
    3f58:	4004a000 	.word	0x4004a000
    3f5c:	1ffff4a0 	.word	0x1ffff4a0
    3f60:	1ffff480 	.word	0x1ffff480
    3f64:	f3af 8000 	nop.w
    3f68:	f3af 8000 	nop.w
    3f6c:	f3af 8000 	nop.w

00003f70 <Vector134>:
 * @brief   PORTC interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTC_IRQ_VECTOR) && KINETIS_EXT_PORTC_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTC_IRQ_VECTOR) {
    3f70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();
    3f74:	f7fd fe74 	bl	1c60 <_stats_increase_irq>
    3f78:	f7fd f8b2 	bl	10e0 <_dbg_check_enter_isr>
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3f7c:	4b12      	ldr	r3, [pc, #72]	; (3fc8 <Vector134+0x58>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    3f7e:	4f13      	ldr	r7, [pc, #76]	; (3fcc <Vector134+0x5c>)
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3f80:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3f84:	f8df 8048 	ldr.w	r8, [pc, #72]	; 3fd0 <Vector134+0x60>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    3f88:	f04f 32ff 	mov.w	r2, #4294967295
    3f8c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    3f90:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    3f92:	2501      	movs	r5, #1
    3f94:	e002      	b.n	3f9c <Vector134+0x2c>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3f96:	3401      	adds	r4, #1
    3f98:	2c0c      	cmp	r4, #12
    3f9a:	d00e      	beq.n	3fba <Vector134+0x4a>
    if (isfr & (1 << pin)) {
    3f9c:	fa05 f304 	lsl.w	r3, r5, r4
    3fa0:	4233      	tst	r3, r6
    3fa2:	d0f8      	beq.n	3f96 <Vector134+0x26>
      expchannel_t channel = channel_map[pin];
    3fa4:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3fa6:	f8d8 3004 	ldr.w	r3, [r8, #4]
    3faa:	4809      	ldr	r0, [pc, #36]	; (3fd0 <Vector134+0x60>)
    3fac:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3fb0:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3fb2:	685b      	ldr	r3, [r3, #4]
    3fb4:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    3fb6:	2c0c      	cmp	r4, #12
    3fb8:	d1f0      	bne.n	3f9c <Vector134+0x2c>
OSAL_IRQ_HANDLER(KINETIS_PORTC_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTC, KINETIS_EXT_PORTC_WIDTH, portc_channel_map);

  OSAL_IRQ_EPILOGUE();
    3fba:	f7fd f8a9 	bl	1110 <_dbg_check_leave_isr>
}
    3fbe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTC_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTC, KINETIS_EXT_PORTC_WIDTH, portc_channel_map);

  OSAL_IRQ_EPILOGUE();
    3fc2:	f7fe bba5 	b.w	2710 <_port_irq_epilogue>
    3fc6:	bf00      	nop
    3fc8:	4004b000 	.word	0x4004b000
    3fcc:	1ffff494 	.word	0x1ffff494
    3fd0:	1ffff480 	.word	0x1ffff480
    3fd4:	f3af 8000 	nop.w
    3fd8:	f3af 8000 	nop.w
    3fdc:	f3af 8000 	nop.w

00003fe0 <Vector138>:
 * @brief   PORTD interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTD_IRQ_VECTOR) && KINETIS_EXT_PORTD_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTD_IRQ_VECTOR) {
    3fe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();
    3fe4:	f7fd fe3c 	bl	1c60 <_stats_increase_irq>
    3fe8:	f7fd f87a 	bl	10e0 <_dbg_check_enter_isr>
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3fec:	4b12      	ldr	r3, [pc, #72]	; (4038 <Vector138+0x58>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    3fee:	4f13      	ldr	r7, [pc, #76]	; (403c <Vector138+0x5c>)
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    3ff0:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    3ff4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 4040 <Vector138+0x60>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    3ff8:	f04f 32ff 	mov.w	r2, #4294967295
    3ffc:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    4000:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    4002:	2501      	movs	r5, #1
    4004:	e002      	b.n	400c <Vector138+0x2c>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    4006:	3401      	adds	r4, #1
    4008:	2c08      	cmp	r4, #8
    400a:	d00e      	beq.n	402a <Vector138+0x4a>
    if (isfr & (1 << pin)) {
    400c:	fa05 f304 	lsl.w	r3, r5, r4
    4010:	4233      	tst	r3, r6
    4012:	d0f8      	beq.n	4006 <Vector138+0x26>
      expchannel_t channel = channel_map[pin];
    4014:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    4016:	f8d8 3004 	ldr.w	r3, [r8, #4]
    401a:	4809      	ldr	r0, [pc, #36]	; (4040 <Vector138+0x60>)
    401c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    4020:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    4022:	685b      	ldr	r3, [r3, #4]
    4024:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    4026:	2c08      	cmp	r4, #8
    4028:	d1f0      	bne.n	400c <Vector138+0x2c>
OSAL_IRQ_HANDLER(KINETIS_PORTD_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTD, KINETIS_EXT_PORTD_WIDTH, portd_channel_map);

  OSAL_IRQ_EPILOGUE();
    402a:	f7fd f871 	bl	1110 <_dbg_check_leave_isr>
}
    402e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTD_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTD, KINETIS_EXT_PORTD_WIDTH, portd_channel_map);

  OSAL_IRQ_EPILOGUE();
    4032:	f7fe bb6d 	b.w	2710 <_port_irq_epilogue>
    4036:	bf00      	nop
    4038:	4004c000 	.word	0x4004c000
    403c:	1ffff48c 	.word	0x1ffff48c
    4040:	1ffff480 	.word	0x1ffff480
    4044:	f3af 8000 	nop.w
    4048:	f3af 8000 	nop.w
    404c:	f3af 8000 	nop.w

00004050 <Vector13C>:
 * @brief   PORTE interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTE_IRQ_VECTOR) && KINETIS_EXT_PORTE_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
    4050:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
    4052:	f7fd fe05 	bl	1c60 <_stats_increase_irq>
    4056:	f7fd f843 	bl	10e0 <_dbg_check_enter_isr>
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    405a:	4b14      	ldr	r3, [pc, #80]	; (40ac <Vector13C+0x5c>)
    405c:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    4060:	f04f 32ff 	mov.w	r2, #4294967295
    4064:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
    4068:	07e2      	lsls	r2, r4, #31
    406a:	d407      	bmi.n	407c <Vector13C+0x2c>
    406c:	07a3      	lsls	r3, r4, #30
    406e:	d40f      	bmi.n	4090 <Vector13C+0x40>
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
    4070:	f7fd f84e 	bl	1110 <_dbg_check_leave_isr>
}
    4074:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
    4078:	f7fe bb4a 	b.w	2710 <_port_irq_epilogue>
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    407c:	4b0c      	ldr	r3, [pc, #48]	; (40b0 <Vector13C+0x60>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    407e:	480d      	ldr	r0, [pc, #52]	; (40b4 <Vector13C+0x64>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    4080:	7819      	ldrb	r1, [r3, #0]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    4082:	6843      	ldr	r3, [r0, #4]
    4084:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    4088:	685b      	ldr	r3, [r3, #4]
    408a:	4798      	blx	r3

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
    408c:	07a3      	lsls	r3, r4, #30
    408e:	d5ef      	bpl.n	4070 <Vector13C+0x20>
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    4090:	4808      	ldr	r0, [pc, #32]	; (40b4 <Vector13C+0x64>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    4092:	4b07      	ldr	r3, [pc, #28]	; (40b0 <Vector13C+0x60>)
    4094:	7859      	ldrb	r1, [r3, #1]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    4096:	6843      	ldr	r3, [r0, #4]
    4098:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    409c:	685b      	ldr	r3, [r3, #4]
    409e:	4798      	blx	r3
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
    40a0:	f7fd f836 	bl	1110 <_dbg_check_leave_isr>
}
    40a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
    40a8:	f7fe bb32 	b.w	2710 <_port_irq_epilogue>
    40ac:	4004d000 	.word	0x4004d000
    40b0:	1ffff488 	.word	0x1ffff488
    40b4:	1ffff480 	.word	0x1ffff480
    40b8:	f3af 8000 	nop.w
    40bc:	f3af 8000 	nop.w

000040c0 <ext_lld_init>:
 * @notapi
 */
void ext_lld_init(void) {

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
    40c0:	4801      	ldr	r0, [pc, #4]	; (40c8 <ext_lld_init+0x8>)
    40c2:	f7fe bdbd 	b.w	2c40 <extObjectInit>
    40c6:	bf00      	nop
    40c8:	1ffff480 	.word	0x1ffff480
    40cc:	f3af 8000 	nop.w

000040d0 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
    40d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    40d2:	f7fd fdc5 	bl	1c60 <_stats_increase_irq>
    40d6:	f7fd f803 	bl	10e0 <_dbg_check_enter_isr>
    40da:	2320      	movs	r3, #32
    40dc:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    40e0:	f7fd fdf6 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    40e4:	f7fc ffcc 	bl	1080 <_dbg_check_lock_from_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    40e8:	f7fc ff52 	bl	f90 <chSysTimerHandlerI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    40ec:	f7fc ffe0 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    40f0:	f7fd fdf6 	bl	1ce0 <_stats_stop_measure_crit_isr>
    40f4:	2300      	movs	r3, #0
    40f6:	f383 8811 	msr	BASEPRI, r3

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    40fa:	f7fd f809 	bl	1110 <_dbg_check_leave_isr>
}
    40fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    4102:	f7fe bb05 	b.w	2710 <_port_irq_epilogue>
    4106:	bf00      	nop
    4108:	f3af 8000 	nop.w
    410c:	f3af 8000 	nop.w

00004110 <st_lld_init>:
 */
void st_lld_init(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
    4110:	4b05      	ldr	r3, [pc, #20]	; (4128 <st_lld_init+0x18>)
    4112:	4a06      	ldr	r2, [pc, #24]	; (412c <st_lld_init+0x1c>)
    4114:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
    4116:	2100      	movs	r1, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
    4118:	2207      	movs	r2, #7
void st_lld_init(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
    411a:	6099      	str	r1, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, KINETIS_ST_IRQ_PRIORITY);
    411c:	200b      	movs	r0, #11
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
    411e:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, KINETIS_ST_IRQ_PRIORITY);
    4120:	2108      	movs	r1, #8
    4122:	f7ff b815 	b.w	3150 <nvicSetSystemHandlerPriority>
    4126:	bf00      	nop
    4128:	e000e010 	.word	0xe000e010
    412c:	000176e8 	.word	0x000176e8

00004130 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    4130:	b508      	push	{r3, lr}

  k22x_clock_init();
    4132:	f7ff f82d 	bl	3190 <k22x_clock_init>
  SystemCoreClockUpdate();
}
    4136:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 *          and before any other initialization.
 */
void __early_init(void) {

  k22x_clock_init();
  SystemCoreClockUpdate();
    413a:	f7ff b8f9 	b.w	3330 <SystemCoreClockUpdate>
    413e:	bf00      	nop

00004140 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
    4140:	4770      	bx	lr
    4142:	bf00      	nop
    4144:	f3af 8000 	nop.w
    4148:	f3af 8000 	nop.w
    414c:	f3af 8000 	nop.w

00004150 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
    4150:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
    4152:	f100 070b 	add.w	r7, r0, #11
  int i;
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
    4156:	2b00      	cmp	r3, #0
    4158:	bf08      	it	eq
    415a:	460b      	moveq	r3, r1
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
    415c:	463d      	mov	r5, r7
  do {
    i = (int)(l % radix);
    415e:	fbb1 f6f2 	udiv	r6, r1, r2
    4162:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
    4166:	f101 0430 	add.w	r4, r1, #48	; 0x30
    if (i > '9')
    416a:	2c39      	cmp	r4, #57	; 0x39
      i += 'A' - '0' - 10;
    416c:	bfc8      	it	gt
    416e:	f101 0437 	addgt.w	r4, r1, #55	; 0x37
    *--q = i;
    4172:	b2e4      	uxtb	r4, r4
    4174:	f805 4d01 	strb.w	r4, [r5, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
    4178:	fbb3 f3f2 	udiv	r3, r3, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
    417c:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
    417e:	2b00      	cmp	r3, #0
    4180:	d1ed      	bne.n	415e <long_to_string_with_divisor+0xe>

  i = (int)(p + MAX_FILLER - q);
    4182:	1b7b      	subs	r3, r7, r5
    4184:	4403      	add	r3, r0
    4186:	e001      	b.n	418c <long_to_string_with_divisor+0x3c>
    4188:	f815 4f01 	ldrb.w	r4, [r5, #1]!
  do
    *p++ = *q++;
    418c:	f800 4b01 	strb.w	r4, [r0], #1
  while (--i);
    4190:	4298      	cmp	r0, r3
    4192:	d1f9      	bne.n	4188 <long_to_string_with_divisor+0x38>

  return p;
}
    4194:	bcf0      	pop	{r4, r5, r6, r7}
    4196:	4770      	bx	lr
    4198:	f3af 8000 	nop.w
    419c:	f3af 8000 	nop.w

000041a0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
    41a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    41a4:	ed2d 8b02 	vpush	{d8}
    41a8:	4b99      	ldr	r3, [pc, #612]	; (4410 <chvprintf+0x270>)
    41aa:	b08f      	sub	sp, #60	; 0x3c
    41ac:	681b      	ldr	r3, [r3, #0]
    41ae:	930d      	str	r3, [sp, #52]	; 0x34
    41b0:	4617      	mov	r7, r2
    41b2:	f10d 031d 	add.w	r3, sp, #29
    41b6:	aa07      	add	r2, sp, #28
    41b8:	1a9b      	subs	r3, r3, r2
    41ba:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
    41bc:	2300      	movs	r3, #0
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
    41be:	4606      	mov	r6, r0
    41c0:	460d      	mov	r5, r1
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
    41c2:	9300      	str	r3, [sp, #0]
    41c4:	4682      	mov	sl, r0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    41c6:	7829      	ldrb	r1, [r5, #0]
    41c8:	1c6b      	adds	r3, r5, #1
    if (c == 0)
    41ca:	b171      	cbz	r1, 41ea <chvprintf+0x4a>
      return n;
    if (c != '%') {
    41cc:	2925      	cmp	r1, #37	; 0x25
    41ce:	d018      	beq.n	4202 <chvprintf+0x62>
      streamPut(chp, (uint8_t)c);
      n++;
    41d0:	9c00      	ldr	r4, [sp, #0]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
    41d2:	f8da 2000 	ldr.w	r2, [sl]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    41d6:	461d      	mov	r5, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
    41d8:	6892      	ldr	r2, [r2, #8]
    41da:	4650      	mov	r0, sl
      n++;
    41dc:	3401      	adds	r4, #1
    41de:	9400      	str	r4, [sp, #0]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
    41e0:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    41e2:	7829      	ldrb	r1, [r5, #0]
    41e4:	1c6b      	adds	r3, r5, #1
    if (c == 0)
    41e6:	2900      	cmp	r1, #0
    41e8:	d1f0      	bne.n	41cc <chvprintf+0x2c>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
    41ea:	4b89      	ldr	r3, [pc, #548]	; (4410 <chvprintf+0x270>)
    41ec:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    41ee:	681b      	ldr	r3, [r3, #0]
    41f0:	9800      	ldr	r0, [sp, #0]
    41f2:	429a      	cmp	r2, r3
    41f4:	f040 81e0 	bne.w	45b8 <chvprintf+0x418>
    41f8:	b00f      	add	sp, #60	; 0x3c
    41fa:	ecbd 8b02 	vpop	{d8}
    41fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
    4202:	786a      	ldrb	r2, [r5, #1]
    4204:	2a2d      	cmp	r2, #45	; 0x2d
    4206:	bf03      	ittte	eq
    4208:	78aa      	ldrbeq	r2, [r5, #2]
      fmt++;
    420a:	1cab      	addeq	r3, r5, #2
      left_align = TRUE;
    420c:	2601      	moveq	r6, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    420e:	2600      	movne	r6, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
    4210:	2a30      	cmp	r2, #48	; 0x30
    4212:	bf03      	ittte	eq
    4214:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
    4216:	3301      	addeq	r3, #1
      filler = '0';
    4218:	f04f 0930 	moveq.w	r9, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    421c:	f04f 0920 	movne.w	r9, #32
    4220:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
    4222:	f04f 0800 	mov.w	r8, #0
    4226:	e007      	b.n	4238 <chvprintf+0x98>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
    4228:	783b      	ldrb	r3, [r7, #0]
    422a:	3704      	adds	r7, #4
      else
        break;
      width = width * 10 + c;
    422c:	eb08 0888 	add.w	r8, r8, r8, lsl #2
    4230:	782a      	ldrb	r2, [r5, #0]
    4232:	eb03 0848 	add.w	r8, r3, r8, lsl #1
    4236:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
    4238:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    423c:	b2db      	uxtb	r3, r3
    423e:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
    4240:	460d      	mov	r5, r1
      if (c >= '0' && c <= '9')
    4242:	d9f3      	bls.n	422c <chvprintf+0x8c>
        c -= '0';
      else if (c == '*')
    4244:	2a2a      	cmp	r2, #42	; 0x2a
    4246:	d0ef      	beq.n	4228 <chvprintf+0x88>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
    4248:	2a2e      	cmp	r2, #46	; 0x2e
    424a:	f04f 0b00 	mov.w	fp, #0
    424e:	d045      	beq.n	42dc <chvprintf+0x13c>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
    4250:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    4254:	2b4c      	cmp	r3, #76	; 0x4c
    4256:	d04e      	beq.n	42f6 <chvprintf+0x156>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    4258:	f1a2 0144 	sub.w	r1, r2, #68	; 0x44
    425c:	2934      	cmp	r1, #52	; 0x34
    425e:	f200 816f 	bhi.w	4540 <chvprintf+0x3a0>
    4262:	e8df f011 	tbh	[pc, r1, lsl #1]
    4266:	0154      	.short	0x0154
    4268:	016d016d 	.word	0x016d016d
    426c:	016d016d 	.word	0x016d016d
    4270:	016d0154 	.word	0x016d0154
    4274:	016d016d 	.word	0x016d016d
    4278:	016d016d 	.word	0x016d016d
    427c:	016d0127 	.word	0x016d0127
    4280:	016d016d 	.word	0x016d016d
    4284:	016d016d 	.word	0x016d016d
    4288:	016d015c 	.word	0x016d015c
    428c:	016a016d 	.word	0x016a016d
    4290:	016d016d 	.word	0x016d016d
    4294:	016d016d 	.word	0x016d016d
    4298:	016d016d 	.word	0x016d016d
    429c:	016d016d 	.word	0x016d016d
    42a0:	016d016d 	.word	0x016d016d
    42a4:	0154015e 	.word	0x0154015e
    42a8:	00d9016d 	.word	0x00d9016d
    42ac:	016d016d 	.word	0x016d016d
    42b0:	016d0154 	.word	0x016d0154
    42b4:	016d016d 	.word	0x016d016d
    42b8:	016d016d 	.word	0x016d016d
    42bc:	016d0127 	.word	0x016d0127
    42c0:	016d016d 	.word	0x016d016d
    42c4:	016d0089 	.word	0x016d0089
    42c8:	016d015c 	.word	0x016d015c
    42cc:	016a016d 	.word	0x016a016d
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
    42d0:	783b      	ldrb	r3, [r7, #0]
    42d2:	3704      	adds	r7, #4
        else
          break;
        precision *= 10;
    42d4:	eb0b 0b8b 	add.w	fp, fp, fp, lsl #2
        precision += c;
    42d8:	eb03 0b4b 	add.w	fp, r3, fp, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
    42dc:	f815 2b01 	ldrb.w	r2, [r5], #1
        if (c >= '0' && c <= '9')
    42e0:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    42e4:	b2db      	uxtb	r3, r3
    42e6:	2b09      	cmp	r3, #9
    42e8:	d9f4      	bls.n	42d4 <chvprintf+0x134>
          c -= '0';
        else if (c == '*')
    42ea:	2a2a      	cmp	r2, #42	; 0x2a
    42ec:	d0f0      	beq.n	42d0 <chvprintf+0x130>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
    42ee:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    42f2:	2b4c      	cmp	r3, #76	; 0x4c
    42f4:	d1b0      	bne.n	4258 <chvprintf+0xb8>
      is_long = TRUE;
      if (*fmt)
    42f6:	782b      	ldrb	r3, [r5, #0]
    42f8:	2b00      	cmp	r3, #0
    42fa:	f000 8121 	beq.w	4540 <chvprintf+0x3a0>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    42fe:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
    4302:	3501      	adds	r5, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    4304:	2a34      	cmp	r2, #52	; 0x34
    4306:	f200 811a 	bhi.w	453e <chvprintf+0x39e>
    430a:	e8df f012 	tbh	[pc, r2, lsl #1]
    430e:	0100      	.short	0x0100
    4310:	01180118 	.word	0x01180118
    4314:	01180118 	.word	0x01180118
    4318:	01180100 	.word	0x01180100
    431c:	01180118 	.word	0x01180118
    4320:	01180118 	.word	0x01180118
    4324:	011800d3 	.word	0x011800d3
    4328:	01180118 	.word	0x01180118
    432c:	01180118 	.word	0x01180118
    4330:	01180108 	.word	0x01180108
    4334:	01160118 	.word	0x01160118
    4338:	01180118 	.word	0x01180118
    433c:	01180118 	.word	0x01180118
    4340:	01180118 	.word	0x01180118
    4344:	01180118 	.word	0x01180118
    4348:	01180118 	.word	0x01180118
    434c:	0100010a 	.word	0x0100010a
    4350:	00850118 	.word	0x00850118
    4354:	01180118 	.word	0x01180118
    4358:	01180100 	.word	0x01180100
    435c:	01180118 	.word	0x01180118
    4360:	01180118 	.word	0x01180118
    4364:	011800d3 	.word	0x011800d3
    4368:	01180118 	.word	0x01180118
    436c:	01180035 	.word	0x01180035
    4370:	01180108 	.word	0x01180108
    4374:	01160118 	.word	0x01160118
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
    4378:	683c      	ldr	r4, [r7, #0]
        s = "(null)";
    437a:	4b26      	ldr	r3, [pc, #152]	; (4414 <chvprintf+0x274>)
    437c:	2c00      	cmp	r4, #0
    437e:	bf08      	it	eq
    4380:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
    4382:	3704      	adds	r7, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    4384:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
    4386:	f1bb 0f00 	cmp.w	fp, #0
    438a:	f000 80f6 	beq.w	457a <chvprintf+0x3da>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    438e:	2b00      	cmp	r3, #0
    4390:	f000 80f8 	beq.w	4584 <chvprintf+0x3e4>
    4394:	f10b 3bff 	add.w	fp, fp, #4294967295
    4398:	4620      	mov	r0, r4
    439a:	e002      	b.n	43a2 <chvprintf+0x202>
    439c:	f1bb 0b01 	subs.w	fp, fp, #1
    43a0:	d403      	bmi.n	43aa <chvprintf+0x20a>
    43a2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    43a6:	2b00      	cmp	r3, #0
    43a8:	d1f8      	bne.n	439c <chvprintf+0x1fc>
    43aa:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    43ac:	ebc0 0808 	rsb	r8, r0, r8
    43b0:	f100 3bff 	add.w	fp, r0, #4294967295
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
    43b4:	f04f 0920 	mov.w	r9, #32
    43b8:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
    43bc:	2e00      	cmp	r6, #0
    43be:	f000 808c 	beq.w	44da <chvprintf+0x33a>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    43c2:	f1bb 0f00 	cmp.w	fp, #0
    43c6:	db11      	blt.n	43ec <chvprintf+0x24c>
    43c8:	465e      	mov	r6, fp
      streamPut(chp, (uint8_t)*s++);
    43ca:	f8da 3000 	ldr.w	r3, [sl]
    43ce:	f814 1b01 	ldrb.w	r1, [r4], #1
    43d2:	689b      	ldr	r3, [r3, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    43d4:	3e01      	subs	r6, #1
      streamPut(chp, (uint8_t)*s++);
    43d6:	4650      	mov	r0, sl
    43d8:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    43da:	1c73      	adds	r3, r6, #1
    43dc:	d1f5      	bne.n	43ca <chvprintf+0x22a>
    43de:	9b00      	ldr	r3, [sp, #0]
    43e0:	3301      	adds	r3, #1
    43e2:	f1bb 0f00 	cmp.w	fp, #0
    43e6:	bfa8      	it	ge
    43e8:	445b      	addge	r3, fp
    43ea:	9300      	str	r3, [sp, #0]
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
    43ec:	f1b8 0f00 	cmp.w	r8, #0
    43f0:	f43f aee9 	beq.w	41c6 <chvprintf+0x26>
    43f4:	4644      	mov	r4, r8
      streamPut(chp, (uint8_t)filler);
    43f6:	f8da 3000 	ldr.w	r3, [sl]
    43fa:	4650      	mov	r0, sl
    43fc:	689b      	ldr	r3, [r3, #8]
    43fe:	4649      	mov	r1, r9
    4400:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
    4402:	3c01      	subs	r4, #1
    4404:	d1f7      	bne.n	43f6 <chvprintf+0x256>
    4406:	9b00      	ldr	r3, [sp, #0]
    4408:	4443      	add	r3, r8
    440a:	9300      	str	r3, [sp, #0]
    440c:	e6db      	b.n	41c6 <chvprintf+0x26>
    440e:	bf00      	nop
    4410:	1ffff034 	.word	0x1ffff034
    4414:	00007100 	.word	0x00007100
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
    4418:	3707      	adds	r7, #7
    441a:	f027 0707 	bic.w	r7, r7, #7
    441e:	e9d7 0100 	ldrd	r0, r1, [r7]
    4422:	f7fc fca5 	bl	d70 <__aeabi_d2f>
    4426:	ee08 0a10 	vmov	s16, r0
      if (f < 0) {
    442a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
    442e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
    4432:	f107 0708 	add.w	r7, r7, #8
      if (f < 0) {
    4436:	f100 80ad 	bmi.w	4594 <chvprintf+0x3f4>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    443a:	a807      	add	r0, sp, #28
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    443c:	f10b 3bff 	add.w	fp, fp, #4294967295
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
    4440:	eefd 7ac8 	vcvt.s32.f32	s15, s16
    4444:	f1bb 0f08 	cmp.w	fp, #8
    4448:	bf28      	it	cs
    444a:	f04f 0b08 	movcs.w	fp, #8
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
    444e:	4c5b      	ldr	r4, [pc, #364]	; (45bc <chvprintf+0x41c>)

  l = (long)num;
    4450:	edcd 7a02 	vstr	s15, [sp, #8]
  p = long_to_string_with_divisor(p, l, 10, 0);
    4454:	ee17 1a90 	vmov	r1, s15
    4458:	220a      	movs	r2, #10
    445a:	2300      	movs	r3, #0
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
    445c:	f854 402b 	ldr.w	r4, [r4, fp, lsl #2]

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
    4460:	f7ff fe76 	bl	4150 <long_to_string_with_divisor>
  *p++ = '.';
    4464:	4683      	mov	fp, r0
    4466:	232e      	movs	r3, #46	; 0x2e
    4468:	f80b 3b01 	strb.w	r3, [fp], #1
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
    446c:	ee18 0a10 	vmov	r0, s16
    4470:	f7fc f9ea 	bl	848 <__aeabi_f2d>
    4474:	e9cd 0104 	strd	r0, r1, [sp, #16]
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
    4478:	9802      	ldr	r0, [sp, #8]
    447a:	f7fc f9d3 	bl	824 <__aeabi_i2d>
    447e:	4602      	mov	r2, r0
    4480:	460b      	mov	r3, r1
    4482:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    4486:	f7fc f87f 	bl	588 <__aeabi_dsub>
    448a:	e9cd 0102 	strd	r0, r1, [sp, #8]
    448e:	4620      	mov	r0, r4
    4490:	f7fc f9b8 	bl	804 <__aeabi_ui2d>
    4494:	4602      	mov	r2, r0
    4496:	460b      	mov	r3, r1
    4498:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    449c:	f7fc fa28 	bl	8f0 <__aeabi_dmul>
    44a0:	f7fc fc3e 	bl	d20 <__aeabi_d2iz>
  return long_to_string_with_divisor(p, l, 10, precision / 10);
    44a4:	4b46      	ldr	r3, [pc, #280]	; (45c0 <chvprintf+0x420>)
    44a6:	fba3 2304 	umull	r2, r3, r3, r4
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
    44aa:	4601      	mov	r1, r0
  return long_to_string_with_divisor(p, l, 10, precision / 10);
    44ac:	08db      	lsrs	r3, r3, #3
    44ae:	4658      	mov	r0, fp
    44b0:	220a      	movs	r2, #10
    44b2:	e004      	b.n	44be <chvprintf+0x31e>
    44b4:	2208      	movs	r2, #8
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
    44b6:	6839      	ldr	r1, [r7, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    44b8:	a807      	add	r0, sp, #28
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
    44ba:	3704      	adds	r7, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    44bc:	2300      	movs	r3, #0
    44be:	f7ff fe47 	bl	4150 <long_to_string_with_divisor>
    44c2:	ab07      	add	r3, sp, #28
    44c4:	1ac0      	subs	r0, r0, r3
    44c6:	f100 3bff 	add.w	fp, r0, #4294967295
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    44ca:	461c      	mov	r4, r3
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    44cc:	ebc0 0808 	rsb	r8, r0, r8
    44d0:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
      width = 0;
    if (left_align == FALSE)
    44d4:	2e00      	cmp	r6, #0
    44d6:	f47f af74 	bne.w	43c2 <chvprintf+0x222>
      width = -width;
    44da:	f1c8 0600 	rsb	r6, r8, #0
    if (width < 0) {
    44de:	2e00      	cmp	r6, #0
    44e0:	d036      	beq.n	4550 <chvprintf+0x3b0>
      if (*s == '-' && filler == '0') {
    44e2:	7821      	ldrb	r1, [r4, #0]
    44e4:	292d      	cmp	r1, #45	; 0x2d
    44e6:	d039      	beq.n	455c <chvprintf+0x3bc>
        streamPut(chp, (uint8_t)*s++);
        n++;
    44e8:	46b0      	mov	r8, r6
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
    44ea:	f8da 3000 	ldr.w	r3, [sl]
    44ee:	4650      	mov	r0, sl
    44f0:	689b      	ldr	r3, [r3, #8]
    44f2:	4649      	mov	r1, r9
    44f4:	4798      	blx	r3
        n++;
      } while (++width != 0);
    44f6:	f118 0801 	adds.w	r8, r8, #1
    44fa:	d1f6      	bne.n	44ea <chvprintf+0x34a>
    44fc:	9b00      	ldr	r3, [sp, #0]
    }
    while (--i >= 0) {
    44fe:	f1bb 0f00 	cmp.w	fp, #0
    4502:	eba3 0306 	sub.w	r3, r3, r6
    4506:	9300      	str	r3, [sp, #0]
    4508:	f6bf af5e 	bge.w	43c8 <chvprintf+0x228>
    450c:	e65b      	b.n	41c6 <chvprintf+0x26>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    450e:	6839      	ldr	r1, [r7, #0]
      if (l < 0) {
    4510:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    4512:	f107 0704 	add.w	r7, r7, #4
      if (l < 0) {
    4516:	db45      	blt.n	45a4 <chvprintf+0x404>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    4518:	a807      	add	r0, sp, #28
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    451a:	220a      	movs	r2, #10
    451c:	e7ce      	b.n	44bc <chvprintf+0x31c>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
    451e:	220a      	movs	r2, #10
    4520:	e7c9      	b.n	44b6 <chvprintf+0x316>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
    4522:	683b      	ldr	r3, [r7, #0]
    4524:	f88d 301c 	strb.w	r3, [sp, #28]
    4528:	9b01      	ldr	r3, [sp, #4]
    452a:	3704      	adds	r7, #4
    452c:	4618      	mov	r0, r3
    452e:	f103 3bff 	add.w	fp, r3, #4294967295
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
    4532:	f04f 0920 	mov.w	r9, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    4536:	ac07      	add	r4, sp, #28
    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    4538:	e7c8      	b.n	44cc <chvprintf+0x32c>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    453a:	2210      	movs	r2, #16
    453c:	e7bb      	b.n	44b6 <chvprintf+0x316>
    453e:	461a      	mov	r2, r3
    4540:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
    4542:	f88d 201c 	strb.w	r2, [sp, #28]
    4546:	4618      	mov	r0, r3
    4548:	f103 3bff 	add.w	fp, r3, #4294967295
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    454c:	ac07      	add	r4, sp, #28
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
    454e:	e7bd      	b.n	44cc <chvprintf+0x32c>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    4550:	f1bb 0f00 	cmp.w	fp, #0
    4554:	46b0      	mov	r8, r6
    4556:	f6bf af37 	bge.w	43c8 <chvprintf+0x228>
    455a:	e634      	b.n	41c6 <chvprintf+0x26>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
    455c:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
    4560:	d1c2      	bne.n	44e8 <chvprintf+0x348>
        streamPut(chp, (uint8_t)*s++);
    4562:	f8da 3000 	ldr.w	r3, [sl]
    4566:	4650      	mov	r0, sl
    4568:	689b      	ldr	r3, [r3, #8]
    456a:	4798      	blx	r3
        n++;
    456c:	9b00      	ldr	r3, [sp, #0]
    456e:	3301      	adds	r3, #1
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
    4570:	3401      	adds	r4, #1
        n++;
    4572:	9300      	str	r3, [sp, #0]
    4574:	f10b 3bff 	add.w	fp, fp, #4294967295
    4578:	e7b6      	b.n	44e8 <chvprintf+0x348>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    457a:	f647 7bfe 	movw	fp, #32766	; 0x7ffe
    457e:	2b00      	cmp	r3, #0
    4580:	f47f af0a 	bne.w	4398 <chvprintf+0x1f8>
    4584:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
    4588:	b99e      	cbnz	r6, 45b2 <chvprintf+0x412>
    458a:	f04f 3bff 	mov.w	fp, #4294967295
    458e:	f04f 0920 	mov.w	r9, #32
    4592:	e7a2      	b.n	44da <chvprintf+0x33a>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
    4594:	232d      	movs	r3, #45	; 0x2d
        f = -f;
    4596:	eeb1 8a48 	vneg.f32	s16, s16
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
    459a:	f88d 301c 	strb.w	r3, [sp, #28]
    459e:	f10d 001d 	add.w	r0, sp, #29
    45a2:	e74b      	b.n	443c <chvprintf+0x29c>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
    45a4:	232d      	movs	r3, #45	; 0x2d
        l = -l;
    45a6:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
    45a8:	f88d 301c 	strb.w	r3, [sp, #28]
    45ac:	f10d 001d 	add.w	r0, sp, #29
    45b0:	e7b3      	b.n	451a <chvprintf+0x37a>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
    45b2:	f04f 0920 	mov.w	r9, #32
    45b6:	e719      	b.n	43ec <chvprintf+0x24c>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
    45b8:	f000 fe12 	bl	51e0 <__stack_chk_fail>
    45bc:	00007110 	.word	0x00007110
    45c0:	cccccccd 	.word	0xcccccccd
    45c4:	f3af 8000 	nop.w
    45c8:	f3af 8000 	nop.w
    45cc:	f3af 8000 	nop.w

000045d0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    45d0:	b40e      	push	{r1, r2, r3}
    45d2:	b500      	push	{lr}
    45d4:	b082      	sub	sp, #8
    45d6:	aa03      	add	r2, sp, #12
    45d8:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
    45dc:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
    45de:	f7ff fddf 	bl	41a0 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
    45e2:	b002      	add	sp, #8
    45e4:	f85d eb04 	ldr.w	lr, [sp], #4
    45e8:	b003      	add	sp, #12
    45ea:	4770      	bx	lr
    45ec:	f3af 8000 	nop.w

000045f0 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
    45f0:	b538      	push	{r3, r4, r5, lr}
    45f2:	460d      	mov	r5, r1
  char *p;

  if (str != NULL)
    45f4:	b320      	cbz	r0, 4640 <parse_arguments+0x50>
    *saveptr = str;
    45f6:	6008      	str	r0, [r1, #0]
    45f8:	4602      	mov	r2, r0
__STRING_INLINE size_t
__strspn_c2 (const char *__s, int __accept1, int __accept2)
{
  size_t __result = 0;
  /* Please note that __accept1 and __accept2 never can be '\0'.  */
  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    45fa:	7811      	ldrb	r1, [r2, #0]
    45fc:	2920      	cmp	r1, #32
    45fe:	4614      	mov	r4, r2
    4600:	f102 0201 	add.w	r2, r2, #1
    4604:	d0f9      	beq.n	45fa <parse_arguments+0xa>
    4606:	2909      	cmp	r1, #9
    4608:	d0f7      	beq.n	45fa <parse_arguments+0xa>
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");

  if (*p == '"') {
    460a:	2922      	cmp	r1, #34	; 0x22
    460c:	d020      	beq.n	4650 <parse_arguments+0x60>
				    int __accept2);
__STRING_INLINE char *
__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
{
  /* Please note that __accept1 and __accept2 never can be '\0'.  */
  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    460e:	b329      	cbz	r1, 465c <parse_arguments+0x6c>
    4610:	2920      	cmp	r1, #32
__STRING_INLINE size_t
__strspn_c2 (const char *__s, int __accept1, int __accept2)
{
  size_t __result = 0;
  /* Please note that __accept1 and __accept2 never can be '\0'.  */
  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    4612:	4623      	mov	r3, r4
				    int __accept2);
__STRING_INLINE char *
__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
{
  /* Please note that __accept1 and __accept2 never can be '\0'.  */
  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    4614:	d019      	beq.n	464a <parse_arguments+0x5a>
    4616:	2909      	cmp	r1, #9
    4618:	d104      	bne.n	4624 <parse_arguments+0x34>
    461a:	e016      	b.n	464a <parse_arguments+0x5a>
    461c:	2820      	cmp	r0, #32
    461e:	d014      	beq.n	464a <parse_arguments+0x5a>
    4620:	2809      	cmp	r0, #9
    4622:	d012      	beq.n	464a <parse_arguments+0x5a>
    4624:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    4628:	2800      	cmp	r0, #0
    462a:	d1f7      	bne.n	461c <parse_arguments+0x2c>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
    462c:	6028      	str	r0, [r5, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
    462e:	b118      	cbz	r0, 4638 <parse_arguments+0x48>
    *(*saveptr)++ = '\0';
    4630:	1c41      	adds	r1, r0, #1
    4632:	2200      	movs	r2, #0
    4634:	6029      	str	r1, [r5, #0]
    4636:	7002      	strb	r2, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
    4638:	7823      	ldrb	r3, [r4, #0]
    463a:	b123      	cbz	r3, 4646 <parse_arguments+0x56>
    463c:	4620      	mov	r0, r4
    463e:	bd38      	pop	{r3, r4, r5, pc}
  char *p;

  if (str != NULL)
    *saveptr = str;

  p = *saveptr;
    4640:	6808      	ldr	r0, [r1, #0]
  if (!p) {
    4642:	2800      	cmp	r0, #0
    4644:	d1d8      	bne.n	45f8 <parse_arguments+0x8>
    return NULL;
    4646:	2000      	movs	r0, #0
    4648:	bd38      	pop	{r3, r4, r5, pc}
    ++__s;
  return *__s == '\0' ? NULL : (char *) (size_t) __s;
    464a:	4618      	mov	r0, r3
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
    464c:	6028      	str	r0, [r5, #0]
    464e:	e7ee      	b.n	462e <parse_arguments+0x3e>

  if (*p == '"') {
    /* If an argument starts with a double quote then its delimiter is another
       quote.*/
    p++;
    *saveptr = strpbrk(p, "\"");
    4650:	4610      	mov	r0, r2
  p += strspn(p, " \t");

  if (*p == '"') {
    /* If an argument starts with a double quote then its delimiter is another
       quote.*/
    p++;
    4652:	4614      	mov	r4, r2
    *saveptr = strpbrk(p, "\"");
    4654:	f002 f834 	bl	66c0 <strchr>
    4658:	6028      	str	r0, [r5, #0]
    465a:	e7e8      	b.n	462e <parse_arguments+0x3e>
    465c:	4608      	mov	r0, r1
    465e:	e7e5      	b.n	462c <parse_arguments+0x3c>

00004660 <get_history>:
}

static int get_history(ShellHistory *shp, char *line, int dir) {
  int count=0;

  if (shp == NULL)
    4660:	2800      	cmp	r0, #0
    4662:	f000 8085 	beq.w	4770 <get_history+0x110>
    shp->sh_end -= shp->sh_size;
  *(shp->sh_buffer + shp->sh_end) = 0;
  shp->sh_cur = 0;
}

static int get_history(ShellHistory *shp, char *line, int dir) {
    4666:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
    466a:	6884      	ldr	r4, [r0, #8]
  while (idx != shp->sh_end) {
    466c:	68c7      	ldr	r7, [r0, #12]
    466e:	42bc      	cmp	r4, r7
    4670:	d071      	beq.n	4756 <get_history+0xf6>
    4672:	e890 5000 	ldmia.w	r0, {ip, lr}
    4676:	4623      	mov	r3, r4
    4678:	2600      	movs	r6, #0
    idx += *(shp->sh_buffer + idx) + 1;
    467a:	f81c 5003 	ldrb.w	r5, [ip, r3]
    467e:	3501      	adds	r5, #1
    4680:	442b      	add	r3, r5
    if (idx >= shp->sh_size)
    4682:	4573      	cmp	r3, lr
      idx -= shp->sh_size;
    4684:	bfa8      	it	ge
    4686:	ebce 0303 	rsbge	r3, lr, r3
  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
  while (idx != shp->sh_end) {
    468a:	42bb      	cmp	r3, r7
    idx += *(shp->sh_buffer + idx) + 1;
    if (idx >= shp->sh_size)
      idx -= shp->sh_size;
    count++;
    468c:	f106 0601 	add.w	r6, r6, #1
  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
  while (idx != shp->sh_end) {
    4690:	d1f3      	bne.n	467a <get_history+0x1a>
    if (idx >= shp->sh_size)
      idx -= shp->sh_size;
    count++;
  }

  if (dir == SHELL_HIST_DIR_FW) {
    4692:	2a01      	cmp	r2, #1
    4694:	d045      	beq.n	4722 <get_history+0xc2>
    4696:	f8d0 e010 	ldr.w	lr, [r0, #16]
      shp->sh_cur -= 2;
    else
      return 0;
  }

  if (count >= shp->sh_cur) {
    469a:	4576      	cmp	r6, lr
    469c:	db5d      	blt.n	475a <get_history+0xfa>
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
    469e:	42bc      	cmp	r4, r7
    46a0:	d060      	beq.n	4764 <get_history+0x104>
    46a2:	1e73      	subs	r3, r6, #1
    46a4:	459e      	cmp	lr, r3
    46a6:	d05c      	beq.n	4762 <get_history+0x102>
    46a8:	e890 1100 	ldmia.w	r0, {r8, ip}
    46ac:	2500      	movs	r5, #0
    46ae:	e001      	b.n	46b4 <get_history+0x54>
    46b0:	4573      	cmp	r3, lr
    46b2:	d030      	beq.n	4716 <get_history+0xb6>
      idx += *(shp->sh_buffer + idx) + 1;
    46b4:	f818 3004 	ldrb.w	r3, [r8, r4]
    46b8:	3301      	adds	r3, #1
    46ba:	441c      	add	r4, r3
      if (idx >= shp->sh_size)
    46bc:	4564      	cmp	r4, ip
        idx -= shp->sh_size;
      i++;
    46be:	f105 0501 	add.w	r5, r5, #1
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
      idx += *(shp->sh_buffer + idx) + 1;
      if (idx >= shp->sh_size)
        idx -= shp->sh_size;
    46c2:	bfa8      	it	ge
    46c4:	ebcc 0404 	rsbge	r4, ip, r4
    46c8:	43eb      	mvns	r3, r5
  }

  if (count >= shp->sh_cur) {
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
    46ca:	42bc      	cmp	r4, r7
    46cc:	4433      	add	r3, r6
    46ce:	d1ef      	bne.n	46b0 <get_history+0x50>
      if (idx >= shp->sh_size)
        idx -= shp->sh_size;
      i++;
    }

    int length = *(shp->sh_buffer + idx);
    46d0:	f818 4007 	ldrb.w	r4, [r8, r7]

    if (length > 0) {
    46d4:	b1bc      	cbz	r4, 4706 <get_history+0xa6>
      shp->sh_cur++;
    46d6:	f10e 0301 	add.w	r3, lr, #1
    46da:	4606      	mov	r6, r0
    46dc:	6103      	str	r3, [r0, #16]

      memset(line, 0, SHELL_MAX_LINE_LENGTH);
    46de:	2240      	movs	r2, #64	; 0x40
    46e0:	4608      	mov	r0, r1
    46e2:	4688      	mov	r8, r1
    46e4:	2100      	movs	r1, #0
    46e6:	f001 ffc3 	bl	6670 <memset>
      if ((idx + length) < shp->sh_size) {
    46ea:	6873      	ldr	r3, [r6, #4]
    46ec:	193a      	adds	r2, r7, r4
    46ee:	429a      	cmp	r2, r3
    46f0:	da1f      	bge.n	4732 <get_history+0xd2>
        memcpy(line, (shp->sh_buffer + idx + 1), length);
    46f2:	6831      	ldr	r1, [r6, #0]
    46f4:	3701      	adds	r7, #1
    46f6:	4439      	add	r1, r7
    46f8:	4640      	mov	r0, r8
    46fa:	4622      	mov	r2, r4
    46fc:	f001 ffa8 	bl	6650 <memcpy>
    4700:	4620      	mov	r0, r4
    4702:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
      }
      return length;
    }
    else if (dir == SHELL_HIST_DIR_FW) {
    4706:	2a01      	cmp	r2, #1
    4708:	d127      	bne.n	475a <get_history+0xfa>
      shp->sh_cur++;
    470a:	f10e 0301 	add.w	r3, lr, #1
    470e:	6103      	str	r3, [r0, #16]
      return 0;
    4710:	4620      	mov	r0, r4
    4712:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4716:	4627      	mov	r7, r4
      if (idx >= shp->sh_size)
        idx -= shp->sh_size;
      i++;
    }

    int length = *(shp->sh_buffer + idx);
    4718:	f818 4007 	ldrb.w	r4, [r8, r7]

    if (length > 0) {
    471c:	2c00      	cmp	r4, #0
    471e:	d1da      	bne.n	46d6 <get_history+0x76>
    4720:	e7f1      	b.n	4706 <get_history+0xa6>
      idx -= shp->sh_size;
    count++;
  }

  if (dir == SHELL_HIST_DIR_FW) {
    if (shp->sh_cur > 0)
    4722:	6903      	ldr	r3, [r0, #16]
    4724:	2b00      	cmp	r3, #0
    4726:	dd20      	ble.n	476a <get_history+0x10a>
      shp->sh_cur -= 2;
    4728:	f1a3 0e02 	sub.w	lr, r3, #2
    472c:	f8c0 e010 	str.w	lr, [r0, #16]
    4730:	e7b3      	b.n	469a <get_history+0x3a>
      else {
        /*
         * Since the saved line was split at the end of the buffer,
         * get the line in two parts.
         */
        int part_len = shp->sh_size - idx - 1;
    4732:	1bdb      	subs	r3, r3, r7
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
    4734:	6831      	ldr	r1, [r6, #0]
      else {
        /*
         * Since the saved line was split at the end of the buffer,
         * get the line in two parts.
         */
        int part_len = shp->sh_size - idx - 1;
    4736:	1e5d      	subs	r5, r3, #1
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
    4738:	3701      	adds	r7, #1
    473a:	4439      	add	r1, r7
    473c:	462a      	mov	r2, r5
    473e:	4640      	mov	r0, r8
    4740:	f001 ff86 	bl	6650 <memcpy>
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
    4744:	eb08 0005 	add.w	r0, r8, r5
    4748:	1b62      	subs	r2, r4, r5
    474a:	6831      	ldr	r1, [r6, #0]
    474c:	f001 ff80 	bl	6650 <memcpy>
    4750:	4620      	mov	r0, r4
    4752:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  *(shp->sh_buffer + shp->sh_end) = 0;
  shp->sh_cur = 0;
}

static int get_history(ShellHistory *shp, char *line, int dir) {
  int count=0;
    4756:	2600      	movs	r6, #0
    4758:	e79b      	b.n	4692 <get_history+0x32>

  if (shp == NULL)
    return -1;
    475a:	f04f 30ff 	mov.w	r0, #4294967295
    475e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }

  if (count >= shp->sh_cur) {
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
    4762:	4627      	mov	r7, r4
    4764:	f8d0 8000 	ldr.w	r8, [r0]
    4768:	e7b2      	b.n	46d0 <get_history+0x70>

  if (dir == SHELL_HIST_DIR_FW) {
    if (shp->sh_cur > 0)
      shp->sh_cur -= 2;
    else
      return 0;
    476a:	2000      	movs	r0, #0
      shp->sh_cur++;
      return 0;
    }
  }
  return -1;
}
    476c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

static int get_history(ShellHistory *shp, char *line, int dir) {
  int count=0;

  if (shp == NULL)
    return -1;
    4770:	f04f 30ff 	mov.w	r0, #4294967295
      shp->sh_cur++;
      return 0;
    }
  }
  return -1;
}
    4774:	4770      	bx	lr
    4776:	bf00      	nop
    4778:	f3af 8000 	nop.w
    477c:	f3af 8000 	nop.w

00004780 <shellInit>:
    4780:	4b01      	ldr	r3, [pc, #4]	; (4788 <shellInit+0x8>)
    4782:	601b      	str	r3, [r3, #0]
    4784:	4770      	bx	lr
    4786:	bf00      	nop
    4788:	1ffff4c8 	.word	0x1ffff4c8
    478c:	f3af 8000 	nop.w

00004790 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
    4790:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
    4794:	3a01      	subs	r2, #1
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
    4796:	4689      	mov	r9, r1
    4798:	b08b      	sub	sp, #44	; 0x2c
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
    479a:	444a      	add	r2, r9
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
    479c:	e88d 000c 	stmia.w	sp, {r2, r3}
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
    47a0:	6804      	ldr	r4, [r0, #0]
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
    47a2:	9002      	str	r0, [sp, #8]
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
#if SHELL_USE_ESC_SEQ == TRUE
  bool escape = false;
  bool bracket = false;
    47a4:	f04f 0a00 	mov.w	sl, #0
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
    47a8:	46cb      	mov	fp, r9
#if SHELL_USE_ESC_SEQ == TRUE
  bool escape = false;
    47aa:	46d0      	mov	r8, sl
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
    47ac:	6823      	ldr	r3, [r4, #0]
    47ae:	4620      	mov	r0, r4
    47b0:	685b      	ldr	r3, [r3, #4]
    47b2:	f10d 011f 	add.w	r1, sp, #31
    47b6:	2201      	movs	r2, #1
    47b8:	4798      	blx	r3
    47ba:	2800      	cmp	r0, #0
    47bc:	f000 80d1 	beq.w	4962 <shellGetLine+0x1d2>
      return true;
#if SHELL_USE_ESC_SEQ == TRUE
    if (c == 27) {
    47c0:	f89d 101f 	ldrb.w	r1, [sp, #31]
    47c4:	291b      	cmp	r1, #27
    47c6:	d030      	beq.n	482a <shellGetLine+0x9a>
      escape = true;
      continue;
    }
    if (escape) {
    47c8:	f1b8 0f00 	cmp.w	r8, #0
    47cc:	d00e      	beq.n	47ec <shellGetLine+0x5c>
      escape = false;
      if (c == '[') {
    47ce:	295b      	cmp	r1, #91	; 0x5b
    47d0:	d042      	beq.n	4858 <shellGetLine+0xc8>
        escape = true;
        bracket = true;
        continue;
      }
      if (bracket) {
    47d2:	f1ba 0f00 	cmp.w	sl, #0
    47d6:	d0e8      	beq.n	47aa <shellGetLine+0x1a>
        bracket = false;
#if SHELL_USE_HISTORY == TRUE
        if (c == 'A') {
    47d8:	2941      	cmp	r1, #65	; 0x41
    47da:	f000 80c6 	beq.w	496a <shellGetLine+0x1da>
            chprintf(chp, "%s", line);
            p = line + len;
          }
          continue;
        }
        if (c == 'B') {
    47de:	2942      	cmp	r1, #66	; 0x42
    47e0:	f000 80fb 	beq.w	49da <shellGetLine+0x24a>
        escape = true;
        bracket = true;
        continue;
      }
      if (bracket) {
        bracket = false;
    47e4:	f04f 0a00 	mov.w	sl, #0
    if (c == 27) {
      escape = true;
      continue;
    }
    if (escape) {
      escape = false;
    47e8:	46d0      	mov	r8, sl
    47ea:	e7df      	b.n	47ac <shellGetLine+0x1c>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
    47ec:	2908      	cmp	r1, #8
    47ee:	d01f      	beq.n	4830 <shellGetLine+0xa0>
    47f0:	297f      	cmp	r1, #127	; 0x7f
    47f2:	d01d      	beq.n	4830 <shellGetLine+0xa0>
        streamPut(chp, c);
        p--;
      }
      continue;
    }
    if (c == '\r') {
    47f4:	290d      	cmp	r1, #13
    47f6:	f000 8108 	beq.w	4a0a <shellGetLine+0x27a>
#endif
      *p = 0;
      return false;
    }
#if SHELL_USE_COMPLETION == TRUE
    if (c == '\t') {
    47fa:	2909      	cmp	r1, #9
    47fc:	d02f      	beq.n	485e <shellGetLine+0xce>
      }
      continue;
    }
#endif
#if SHELL_USE_HISTORY == TRUE
    if (c == 14) {
    47fe:	290e      	cmp	r1, #14
    4800:	f000 80d0 	beq.w	49a4 <shellGetLine+0x214>
        chprintf(chp, "%s", line);
        p = line + len;
      }
      continue;
    }
    if (c == 16) {
    4804:	2910      	cmp	r1, #16
    4806:	f000 80f2 	beq.w	49ee <shellGetLine+0x25e>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
    480a:	291f      	cmp	r1, #31
    480c:	d9ce      	bls.n	47ac <shellGetLine+0x1c>
      continue;
    if (p < line + size - 1) {
    480e:	9b00      	ldr	r3, [sp, #0]
    4810:	459b      	cmp	fp, r3
    4812:	d2cb      	bcs.n	47ac <shellGetLine+0x1c>
      streamPut(chp, c);
    4814:	6823      	ldr	r3, [r4, #0]
    4816:	4620      	mov	r0, r4
    4818:	689b      	ldr	r3, [r3, #8]
    481a:	4798      	blx	r3
      *p++ = (char)c;
    481c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4820:	f88b 3000 	strb.w	r3, [fp]
    4824:	f10b 0b01 	add.w	fp, fp, #1
    4828:	e7c0      	b.n	47ac <shellGetLine+0x1c>

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
#if SHELL_USE_ESC_SEQ == TRUE
    if (c == 27) {
      escape = true;
    482a:	f04f 0801 	mov.w	r8, #1
    482e:	e7bd      	b.n	47ac <shellGetLine+0x1c>
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
      if (p != line) {
    4830:	45cb      	cmp	fp, r9
    4832:	d0bb      	beq.n	47ac <shellGetLine+0x1c>
        streamPut(chp, c);
    4834:	6823      	ldr	r3, [r4, #0]
    4836:	4620      	mov	r0, r4
    4838:	689b      	ldr	r3, [r3, #8]
    483a:	4798      	blx	r3
        streamPut(chp, 0x20);
    483c:	6823      	ldr	r3, [r4, #0]
    483e:	4620      	mov	r0, r4
    4840:	689b      	ldr	r3, [r3, #8]
    4842:	2120      	movs	r1, #32
    4844:	4798      	blx	r3
        streamPut(chp, c);
    4846:	6823      	ldr	r3, [r4, #0]
    4848:	f89d 101f 	ldrb.w	r1, [sp, #31]
    484c:	689b      	ldr	r3, [r3, #8]
    484e:	4620      	mov	r0, r4
        p--;
    4850:	f10b 3bff 	add.w	fp, fp, #4294967295
#endif
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        streamPut(chp, c);
        streamPut(chp, 0x20);
        streamPut(chp, c);
    4854:	4798      	blx	r3
    4856:	e7a9      	b.n	47ac <shellGetLine+0x1c>
    }
    if (escape) {
      escape = false;
      if (c == '[') {
        escape = true;
        bracket = true;
    4858:	f04f 0a01 	mov.w	sl, #1
    485c:	e7a6      	b.n	47ac <shellGetLine+0x1c>
      *p = 0;
      return false;
    }
#if SHELL_USE_COMPLETION == TRUE
    if (c == '\t') {
      if (p < line + size - 1) {
    485e:	9b00      	ldr	r3, [sp, #0]
    4860:	459b      	cmp	fp, r3
    4862:	d2a3      	bcs.n	47ac <shellGetLine+0x1c>
#if (SHELL_USE_COMPLETION == TRUE) || defined(__DOXYGEN__)
static void get_completions(ShellConfig *scfg, char *line) {
  ShellCommand *lcp = shell_local_commands;
  const ShellCommand *scp = scfg->sc_commands;
  char **scmp = scfg->sc_completion;
  char help_cmp[] = "help";
    4864:	4bb5      	ldr	r3, [pc, #724]	; (4b3c <shellGetLine+0x3ac>)
      return false;
    }
#if SHELL_USE_COMPLETION == TRUE
    if (c == '\t') {
      if (p < line + size - 1) {
        *p = 0;
    4866:	f88b 8000 	strb.w	r8, [fp]
#if (SHELL_USE_COMPLETION == TRUE) || defined(__DOXYGEN__)
static void get_completions(ShellConfig *scfg, char *line) {
  ShellCommand *lcp = shell_local_commands;
  const ShellCommand *scp = scfg->sc_commands;
  char **scmp = scfg->sc_completion;
  char help_cmp[] = "help";
    486a:	e893 0003 	ldmia.w	r3, {r0, r1}

  if (strstr(help_cmp, line) == help_cmp) {
    486e:	ad08      	add	r5, sp, #32
#if (SHELL_USE_COMPLETION == TRUE) || defined(__DOXYGEN__)
static void get_completions(ShellConfig *scfg, char *line) {
  ShellCommand *lcp = shell_local_commands;
  const ShellCommand *scp = scfg->sc_commands;
  char **scmp = scfg->sc_completion;
  char help_cmp[] = "help";
    4870:	9008      	str	r0, [sp, #32]
    4872:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24

  if (strstr(help_cmp, line) == help_cmp) {
    4876:	4628      	mov	r0, r5
    4878:	4649      	mov	r1, r9
    487a:	f001 ff39 	bl	66f0 <strstr>
    487e:	9a02      	ldr	r2, [sp, #8]
    4880:	6853      	ldr	r3, [r2, #4]
    4882:	6917      	ldr	r7, [r2, #16]
    4884:	9303      	str	r3, [sp, #12]
    4886:	42a8      	cmp	r0, r5
    *scmp++ = help_cmp;
  }
  while (lcp->sc_name != NULL) {
    4888:	4bad      	ldr	r3, [pc, #692]	; (4b40 <shellGetLine+0x3b0>)
  const ShellCommand *scp = scfg->sc_commands;
  char **scmp = scfg->sc_completion;
  char help_cmp[] = "help";

  if (strstr(help_cmp, line) == help_cmp) {
    *scmp++ = help_cmp;
    488a:	bf08      	it	eq
    488c:	6038      	streq	r0, [r7, #0]
  }
  while (lcp->sc_name != NULL) {
    488e:	681d      	ldr	r5, [r3, #0]
  const ShellCommand *scp = scfg->sc_commands;
  char **scmp = scfg->sc_completion;
  char help_cmp[] = "help";

  if (strstr(help_cmp, line) == help_cmp) {
    *scmp++ = help_cmp;
    4890:	bf08      	it	eq
    4892:	3704      	addeq	r7, #4
  }
  while (lcp->sc_name != NULL) {
    4894:	b16d      	cbz	r5, 48b2 <shellGetLine+0x122>
    4896:	461e      	mov	r6, r3
    if (strstr(lcp->sc_name, line) == lcp->sc_name) {
    4898:	4628      	mov	r0, r5
    489a:	4649      	mov	r1, r9
    489c:	f001 ff28 	bl	66f0 <strstr>
    48a0:	4285      	cmp	r5, r0
      *scmp++ = (char *)lcp->sc_name;
    48a2:	bf08      	it	eq
    48a4:	603d      	streq	r5, [r7, #0]
  char help_cmp[] = "help";

  if (strstr(help_cmp, line) == help_cmp) {
    *scmp++ = help_cmp;
  }
  while (lcp->sc_name != NULL) {
    48a6:	f856 5f08 	ldr.w	r5, [r6, #8]!
    if (strstr(lcp->sc_name, line) == lcp->sc_name) {
      *scmp++ = (char *)lcp->sc_name;
    48aa:	bf08      	it	eq
    48ac:	3704      	addeq	r7, #4
  char help_cmp[] = "help";

  if (strstr(help_cmp, line) == help_cmp) {
    *scmp++ = help_cmp;
  }
  while (lcp->sc_name != NULL) {
    48ae:	2d00      	cmp	r5, #0
    48b0:	d1f2      	bne.n	4898 <shellGetLine+0x108>
    if (strstr(lcp->sc_name, line) == lcp->sc_name) {
      *scmp++ = (char *)lcp->sc_name;
    }
    lcp++;
  }
  if (scp != NULL) {
    48b2:	9b03      	ldr	r3, [sp, #12]
    48b4:	b17b      	cbz	r3, 48d6 <shellGetLine+0x146>
    while (scp->sc_name != NULL) {
    48b6:	681d      	ldr	r5, [r3, #0]
    48b8:	b16d      	cbz	r5, 48d6 <shellGetLine+0x146>
    48ba:	461e      	mov	r6, r3
      if (strstr(scp->sc_name, line) == scp->sc_name) {
    48bc:	4628      	mov	r0, r5
    48be:	4649      	mov	r1, r9
    48c0:	f001 ff16 	bl	66f0 <strstr>
    48c4:	4285      	cmp	r5, r0
        *scmp++ = (char *)scp->sc_name;
    48c6:	bf08      	it	eq
    48c8:	603d      	streq	r5, [r7, #0]
      *scmp++ = (char *)lcp->sc_name;
    }
    lcp++;
  }
  if (scp != NULL) {
    while (scp->sc_name != NULL) {
    48ca:	f856 5f08 	ldr.w	r5, [r6, #8]!
      if (strstr(scp->sc_name, line) == scp->sc_name) {
        *scmp++ = (char *)scp->sc_name;
    48ce:	bf08      	it	eq
    48d0:	3704      	addeq	r7, #4
      *scmp++ = (char *)lcp->sc_name;
    }
    lcp++;
  }
  if (scp != NULL) {
    while (scp->sc_name != NULL) {
    48d2:	2d00      	cmp	r5, #0
    48d4:	d1f2      	bne.n	48bc <shellGetLine+0x12c>
    48d6:	9b02      	ldr	r3, [sp, #8]
      }
      scp++;
    }
  }

  *scmp = NULL;
    48d8:	2200      	movs	r2, #0
    48da:	603a      	str	r2, [r7, #0]
    48dc:	691f      	ldr	r7, [r3, #16]
  char **scmp = scfg->sc_completion;
  char **cmp = scmp + 1;
  char *c = line + length;
  int clen = 0;

  if (*scmp != NULL) {
    48de:	f8d7 c000 	ldr.w	ip, [r7]
    if (c == '\t') {
      if (p < line + size - 1) {
        *p = 0;

        get_completions(scfg, line);
        int len = process_completions(scfg, line, p - line, size);
    48e2:	ebc9 030b 	rsb	r3, r9, fp
    48e6:	4619      	mov	r1, r3
    48e8:	9303      	str	r3, [sp, #12]
  char **scmp = scfg->sc_completion;
  char **cmp = scmp + 1;
  char *c = line + length;
  int clen = 0;

  if (*scmp != NULL) {
    48ea:	4665      	mov	r5, ip
    48ec:	f1bc 0f00 	cmp.w	ip, #0
    48f0:	f43f af5c 	beq.w	47ac <shellGetLine+0x1c>
    if (*cmp == NULL) {
    48f4:	687b      	ldr	r3, [r7, #4]
    48f6:	2b00      	cmp	r3, #0
    48f8:	f000 813e 	beq.w	4b78 <shellGetLine+0x3e8>
        *c = ' ';
        clen++;
      }
    }
    else {
      while (*(*scmp + clen) != 0) {
    48fc:	f89c 6000 	ldrb.w	r6, [ip]
    4900:	2e00      	cmp	r6, #0
    4902:	f000 8118 	beq.w	4b36 <shellGetLine+0x3a6>
  *scmp = NULL;
}

static int process_completions(ShellConfig *scfg, char *line, int length, unsigned size) {
  char **scmp = scfg->sc_completion;
  char **cmp = scmp + 1;
    4906:	1d38      	adds	r0, r7, #4
    4908:	f8cd 8010 	str.w	r8, [sp, #16]
    490c:	f8dd 8000 	ldr.w	r8, [sp]
    4910:	f8cd b00c 	str.w	fp, [sp, #12]
    4914:	46de      	mov	lr, fp
    4916:	9405      	str	r4, [sp, #20]
    4918:	46bc      	mov	ip, r7
    491a:	460c      	mov	r4, r1
    491c:	4683      	mov	fp, r0
    491e:	462f      	mov	r7, r5
        clen++;
      }
    }
    else {
      while (*(*scmp + clen) != 0) {
        while ((*(*scmp + clen) == *(*cmp + clen)) &&
    4920:	5c9d      	ldrb	r5, [r3, r2]
    4922:	42b5      	cmp	r5, r6
    4924:	d108      	bne.n	4938 <shellGetLine+0x1a8>
               (*(*cmp + clen) != 0) && (*cmp != NULL)) {
    4926:	4659      	mov	r1, fp
    4928:	b90b      	cbnz	r3, 492e <shellGetLine+0x19e>
    492a:	e008      	b.n	493e <shellGetLine+0x1ae>
    492c:	b13b      	cbz	r3, 493e <shellGetLine+0x1ae>
        clen++;
      }
    }
    else {
      while (*(*scmp + clen) != 0) {
        while ((*(*scmp + clen) == *(*cmp + clen)) &&
    492e:	f851 3f04 	ldr.w	r3, [r1, #4]!
    4932:	5c98      	ldrb	r0, [r3, r2]
    4934:	42a8      	cmp	r0, r5
    4936:	d0f9      	beq.n	492c <shellGetLine+0x19c>
               (*(*cmp + clen) != 0) && (*cmp != NULL)) {
          cmp++;
        }
        if (*cmp == NULL) {
    4938:	2b00      	cmp	r3, #0
    493a:	f040 80c1 	bne.w	4ac0 <shellGetLine+0x330>
          if ((c < line + size - 1) && (clen >= length))
    493e:	45f0      	cmp	r8, lr
    4940:	d907      	bls.n	4952 <shellGetLine+0x1c2>
    4942:	4294      	cmp	r4, r2
    4944:	dc05      	bgt.n	4952 <shellGetLine+0x1c2>
            *c++ = *(*scmp + clen);
    4946:	f88e 6000 	strb.w	r6, [lr]
    494a:	f8dc 7000 	ldr.w	r7, [ip]
    494e:	f10e 0e01 	add.w	lr, lr, #1
          cmp = scmp + 1;
          clen++;
    4952:	3201      	adds	r2, #1
        *c = ' ';
        clen++;
      }
    }
    else {
      while (*(*scmp + clen) != 0) {
    4954:	5cbe      	ldrb	r6, [r7, r2]
    4956:	2e00      	cmp	r6, #0
    4958:	f000 80c1 	beq.w	4ade <shellGetLine+0x34e>
    495c:	f8dc 3004 	ldr.w	r3, [ip, #4]
    4960:	e7de      	b.n	4920 <shellGetLine+0x190>

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
    4962:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      streamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
    4964:	b00b      	add	sp, #44	; 0x2c
    4966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      if (bracket) {
        bracket = false;
#if SHELL_USE_HISTORY == TRUE
        if (c == 'A') {
          int len = get_history(shp, line, SHELL_HIST_DIR_BK);
    496a:	9801      	ldr	r0, [sp, #4]
    496c:	4649      	mov	r1, r9
    496e:	2200      	movs	r2, #0
    4970:	f7ff fe76 	bl	4660 <get_history>

          if (len > 0) {
    4974:	1e05      	subs	r5, r0, #0
    4976:	f77f af35 	ble.w	47e4 <shellGetLine+0x54>

          if (len == 0)
            *line = 0;

          if (len >= 0) {
            _shell_reset_cur(chp);
    497a:	2246      	movs	r2, #70	; 0x46
    497c:	2304      	movs	r3, #4
    497e:	4971      	ldr	r1, [pc, #452]	; (4b44 <shellGetLine+0x3b4>)
    4980:	4620      	mov	r0, r4
    4982:	f7ff fe25 	bl	45d0 <chprintf>
            _shell_clr_line(chp);
    4986:	4970      	ldr	r1, [pc, #448]	; (4b48 <shellGetLine+0x3b8>)
    4988:	4620      	mov	r0, r4
    498a:	f7ff fe21 	bl	45d0 <chprintf>
        escape = true;
        bracket = true;
        continue;
      }
      if (bracket) {
        bracket = false;
    498e:	f04f 0a00 	mov.w	sl, #0
            *line = 0;

          if (len >= 0) {
            _shell_reset_cur(chp);
            _shell_clr_line(chp);
            chprintf(chp, "%s", line);
    4992:	4620      	mov	r0, r4
    4994:	496d      	ldr	r1, [pc, #436]	; (4b4c <shellGetLine+0x3bc>)
    4996:	464a      	mov	r2, r9
            p = line + len;
    4998:	eb09 0b05 	add.w	fp, r9, r5
            *line = 0;

          if (len >= 0) {
            _shell_reset_cur(chp);
            _shell_clr_line(chp);
            chprintf(chp, "%s", line);
    499c:	f7ff fe18 	bl	45d0 <chprintf>
    if (c == 27) {
      escape = true;
      continue;
    }
    if (escape) {
      escape = false;
    49a0:	46d0      	mov	r8, sl
    49a2:	e703      	b.n	47ac <shellGetLine+0x1c>
      continue;
    }
#endif
#if SHELL_USE_HISTORY == TRUE
    if (c == 14) {
      int len = get_history(shp, line, SHELL_HIST_DIR_FW);
    49a4:	9801      	ldr	r0, [sp, #4]
    49a6:	4649      	mov	r1, r9
    49a8:	2201      	movs	r2, #1
    49aa:	f7ff fe59 	bl	4660 <get_history>

      if (len == 0)
    49ae:	1e05      	subs	r5, r0, #0
    49b0:	d125      	bne.n	49fe <shellGetLine+0x26e>
        *line = 0;
    49b2:	f889 8000 	strb.w	r8, [r9]
    }
    if (c == 16) {
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);

      if (len > 0) {
        _shell_reset_cur(chp);
    49b6:	2246      	movs	r2, #70	; 0x46
    49b8:	2304      	movs	r3, #4
    49ba:	4620      	mov	r0, r4
    49bc:	4961      	ldr	r1, [pc, #388]	; (4b44 <shellGetLine+0x3b4>)
    49be:	f7ff fe07 	bl	45d0 <chprintf>
        _shell_clr_line(chp);
    49c2:	4620      	mov	r0, r4
    49c4:	4960      	ldr	r1, [pc, #384]	; (4b48 <shellGetLine+0x3b8>)
    49c6:	f7ff fe03 	bl	45d0 <chprintf>
        chprintf(chp, "%s", line);
    49ca:	4620      	mov	r0, r4
    49cc:	495f      	ldr	r1, [pc, #380]	; (4b4c <shellGetLine+0x3bc>)
    49ce:	464a      	mov	r2, r9
        p = line + len;
    49d0:	eb09 0b05 	add.w	fp, r9, r5
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);

      if (len > 0) {
        _shell_reset_cur(chp);
        _shell_clr_line(chp);
        chprintf(chp, "%s", line);
    49d4:	f7ff fdfc 	bl	45d0 <chprintf>
    49d8:	e6e8      	b.n	47ac <shellGetLine+0x1c>
            p = line + len;
          }
          continue;
        }
        if (c == 'B') {
          int len = get_history(shp, line, SHELL_HIST_DIR_FW);
    49da:	9801      	ldr	r0, [sp, #4]
    49dc:	4649      	mov	r1, r9
    49de:	2201      	movs	r2, #1
    49e0:	f7ff fe3e 	bl	4660 <get_history>

          if (len == 0)
    49e4:	1e05      	subs	r5, r0, #0
    49e6:	d10d      	bne.n	4a04 <shellGetLine+0x274>
            *line = 0;
    49e8:	f889 5000 	strb.w	r5, [r9]
    49ec:	e7c5      	b.n	497a <shellGetLine+0x1ea>
        p = line + len;
      }
      continue;
    }
    if (c == 16) {
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);
    49ee:	9801      	ldr	r0, [sp, #4]
    49f0:	4649      	mov	r1, r9
    49f2:	4642      	mov	r2, r8
    49f4:	f7ff fe34 	bl	4660 <get_history>

      if (len > 0) {
    49f8:	1e05      	subs	r5, r0, #0
    49fa:	dcdc      	bgt.n	49b6 <shellGetLine+0x226>
    49fc:	e6d6      	b.n	47ac <shellGetLine+0x1c>
      int len = get_history(shp, line, SHELL_HIST_DIR_FW);

      if (len == 0)
        *line = 0;

      if (len >= 0) {
    49fe:	f6ff aed5 	blt.w	47ac <shellGetLine+0x1c>
    4a02:	e7d8      	b.n	49b6 <shellGetLine+0x226>
          int len = get_history(shp, line, SHELL_HIST_DIR_FW);

          if (len == 0)
            *line = 0;

          if (len >= 0) {
    4a04:	f6ff aeee 	blt.w	47e4 <shellGetLine+0x54>
    4a08:	e7b7      	b.n	497a <shellGetLine+0x1ea>
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
    4a0a:	4620      	mov	r0, r4
    4a0c:	4950      	ldr	r1, [pc, #320]	; (4b50 <shellGetLine+0x3c0>)
    4a0e:	f7ff fddf 	bl	45d0 <chprintf>
  return false;
}

static void save_history(ShellHistory *shp, char *line, int length) {

  if (shp == NULL)
    4a12:	9b01      	ldr	r3, [sp, #4]
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
    4a14:	ebc9 040b 	rsb	r4, r9, fp
  return false;
}

static void save_history(ShellHistory *shp, char *line, int length) {

  if (shp == NULL)
    4a18:	2b00      	cmp	r3, #0
    4a1a:	d04b      	beq.n	4ab4 <shellGetLine+0x324>
    return;

  if (length > shp->sh_size - 2)
    4a1c:	685a      	ldr	r2, [r3, #4]
    4a1e:	1e53      	subs	r3, r2, #1
    4a20:	429c      	cmp	r4, r3
    4a22:	da47      	bge.n	4ab4 <shellGetLine+0x324>
    return;

  while ((*(line + length -1) == ' ') && (length > 0))
    4a24:	1e63      	subs	r3, r4, #1
    4a26:	eb09 0103 	add.w	r1, r9, r3
    4a2a:	f819 0003 	ldrb.w	r0, [r9, r3]
    4a2e:	2820      	cmp	r0, #32
    4a30:	d10a      	bne.n	4a48 <shellGetLine+0x2b8>
    4a32:	2c00      	cmp	r4, #0
    4a34:	dc03      	bgt.n	4a3e <shellGetLine+0x2ae>
    4a36:	e03d      	b.n	4ab4 <shellGetLine+0x324>
    4a38:	2b00      	cmp	r3, #0
    4a3a:	d03b      	beq.n	4ab4 <shellGetLine+0x324>
    4a3c:	3b01      	subs	r3, #1
    4a3e:	f811 0d01 	ldrb.w	r0, [r1, #-1]!
    4a42:	2820      	cmp	r0, #32
    length--;
    4a44:	461c      	mov	r4, r3
    return;

  if (length > shp->sh_size - 2)
    return;

  while ((*(line + length -1) == ' ') && (length > 0))
    4a46:	d0f7      	beq.n	4a38 <shellGetLine+0x2a8>
    length--;

  if (length <= 0)
    4a48:	2c00      	cmp	r4, #0
    4a4a:	dd33      	ble.n	4ab4 <shellGetLine+0x324>
    4a4c:	9e01      	ldr	r6, [sp, #4]
    4a4e:	6830      	ldr	r0, [r6, #0]
    4a50:	68b3      	ldr	r3, [r6, #8]
    4a52:	68f5      	ldr	r5, [r6, #12]
    4a54:	e008      	b.n	4a68 <shellGetLine+0x2d8>
}

static bool is_histbuff_space(ShellHistory *shp, int length) {

  if (shp->sh_end >= shp->sh_beg) {
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
    4a56:	428c      	cmp	r4, r1
    4a58:	db10      	blt.n	4a7c <shellGetLine+0x2ec>
  return true;
}

#if (SHELL_USE_HISTORY == TRUE) || defined(__DOXYGEN__)
static void del_histbuff_entry(ShellHistory *shp) {
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
    4a5a:	5cc1      	ldrb	r1, [r0, r3]
    4a5c:	440b      	add	r3, r1
    4a5e:	3301      	adds	r3, #1

  if (pos >= shp->sh_size)
    4a60:	429a      	cmp	r2, r3
    4a62:	dc00      	bgt.n	4a66 <shellGetLine+0x2d6>
    pos -= shp->sh_size;
    4a64:	1a9b      	subs	r3, r3, r2

  shp->sh_beg = pos;
    4a66:	60b3      	str	r3, [r6, #8]
}

static bool is_histbuff_space(ShellHistory *shp, int length) {

  if (shp->sh_end >= shp->sh_beg) {
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
    4a68:	1ae9      	subs	r1, r5, r3
      return true;
  }
  else {
    if (length < (shp->sh_beg - shp->sh_end - 1))
    4a6a:	1b5f      	subs	r7, r3, r5
}

static bool is_histbuff_space(ShellHistory *shp, int length) {

  if (shp->sh_end >= shp->sh_beg) {
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
    4a6c:	43c9      	mvns	r1, r1
  shp->sh_beg = pos;
}

static bool is_histbuff_space(ShellHistory *shp, int length) {

  if (shp->sh_end >= shp->sh_beg) {
    4a6e:	42ab      	cmp	r3, r5
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
    4a70:	4411      	add	r1, r2
      return true;
  }
  else {
    if (length < (shp->sh_beg - shp->sh_end - 1))
    4a72:	f107 37ff 	add.w	r7, r7, #4294967295
  shp->sh_beg = pos;
}

static bool is_histbuff_space(ShellHistory *shp, int length) {

  if (shp->sh_end >= shp->sh_beg) {
    4a76:	ddee      	ble.n	4a56 <shellGetLine+0x2c6>
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
      return true;
  }
  else {
    if (length < (shp->sh_beg - shp->sh_end - 1))
    4a78:	42bc      	cmp	r4, r7
    4a7a:	daee      	bge.n	4a5a <shellGetLine+0x2ca>
    return;

  while (!is_histbuff_space(shp, length))
    del_histbuff_entry(shp);

  if (length < shp->sh_size - shp->sh_end - 1)
    4a7c:	1b52      	subs	r2, r2, r5
    4a7e:	1e56      	subs	r6, r2, #1
    4a80:	42b4      	cmp	r4, r6
    4a82:	da6b      	bge.n	4b5c <shellGetLine+0x3cc>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
    4a84:	3501      	adds	r5, #1
    4a86:	4428      	add	r0, r5
    4a88:	4649      	mov	r1, r9
    4a8a:	4622      	mov	r2, r4
    4a8c:	f001 fde0 	bl	6650 <memcpy>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, part_len);
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
  }

  /* Save the length of the current line and move the buffer end pointer */
  *(shp->sh_buffer + shp->sh_end) = (char)length;
    4a90:	9901      	ldr	r1, [sp, #4]
    4a92:	68cb      	ldr	r3, [r1, #12]
    4a94:	680a      	ldr	r2, [r1, #0]
    4a96:	54d4      	strb	r4, [r2, r3]
  shp->sh_end += length + 1;
    4a98:	68cb      	ldr	r3, [r1, #12]
  if (shp->sh_end >= shp->sh_size)
    4a9a:	684a      	ldr	r2, [r1, #4]
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
  }

  /* Save the length of the current line and move the buffer end pointer */
  *(shp->sh_buffer + shp->sh_end) = (char)length;
  shp->sh_end += length + 1;
    4a9c:	3401      	adds	r4, #1
    4a9e:	4423      	add	r3, r4
  if (shp->sh_end >= shp->sh_size)
    4aa0:	4293      	cmp	r3, r2
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
  }

  /* Save the length of the current line and move the buffer end pointer */
  *(shp->sh_buffer + shp->sh_end) = (char)length;
  shp->sh_end += length + 1;
    4aa2:	60cb      	str	r3, [r1, #12]
  if (shp->sh_end >= shp->sh_size)
    4aa4:	db01      	blt.n	4aaa <shellGetLine+0x31a>
    shp->sh_end -= shp->sh_size;
    4aa6:	1a9b      	subs	r3, r3, r2
    4aa8:	60cb      	str	r3, [r1, #12]
  *(shp->sh_buffer + shp->sh_end) = 0;
    4aaa:	9801      	ldr	r0, [sp, #4]
    4aac:	6801      	ldr	r1, [r0, #0]
    4aae:	2200      	movs	r2, #0
    4ab0:	54ca      	strb	r2, [r1, r3]
  shp->sh_cur = 0;
    4ab2:	6102      	str	r2, [r0, #16]
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
#endif
      *p = 0;
    4ab4:	2000      	movs	r0, #0
    4ab6:	f88b 0000 	strb.w	r0, [fp]
    if (p < line + size - 1) {
      streamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
    4aba:	b00b      	add	sp, #44	; 0x2c
    4abc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4ac0:	f8dd b00c 	ldr.w	fp, [sp, #12]
    4ac4:	f8dd 8010 	ldr.w	r8, [sp, #16]
    4ac8:	9c05      	ldr	r4, [sp, #20]
    4aca:	4610      	mov	r0, r2
          break;
        }
      }
    }

    *(line + clen) = 0;
    4acc:	2300      	movs	r3, #0
      if (p < line + size - 1) {
        *p = 0;

        get_completions(scfg, line);
        int len = process_completions(scfg, line, p - line, size);
        if (len > 0) {
    4ace:	429a      	cmp	r2, r3
          break;
        }
      }
    }

    *(line + clen) = 0;
    4ad0:	f809 3000 	strb.w	r3, [r9, r0]
    4ad4:	4448      	add	r0, r9
      if (p < line + size - 1) {
        *p = 0;

        get_completions(scfg, line);
        int len = process_completions(scfg, line, p - line, size);
        if (len > 0) {
    4ad6:	f77f ae69 	ble.w	47ac <shellGetLine+0x1c>
          break;
        }
      }
    }

    *(line + clen) = 0;
    4ada:	4606      	mov	r6, r0
    4adc:	e008      	b.n	4af0 <shellGetLine+0x360>
    4ade:	f8dd b00c 	ldr.w	fp, [sp, #12]
    4ae2:	f8dd 8010 	ldr.w	r8, [sp, #16]
    4ae6:	9c05      	ldr	r4, [sp, #20]
    4ae8:	f809 6002 	strb.w	r6, [r9, r2]
    4aec:	eb09 0602 	add.w	r6, r9, r2
    4af0:	9a02      	ldr	r2, [sp, #8]
    4af2:	6917      	ldr	r7, [r2, #16]
    4af4:	6815      	ldr	r5, [r2, #0]

static void write_completions(ShellConfig *scfg, char *line, int pos) {
  BaseSequentialStream *chp = scfg->sc_channel;
  char **scmp = scfg->sc_completion;

  if (*(scmp + 1) != NULL) {
    4af6:	687b      	ldr	r3, [r7, #4]
    chprintf(chp, SHELL_NEWLINE_STR);
    4af8:	4628      	mov	r0, r5

static void write_completions(ShellConfig *scfg, char *line, int pos) {
  BaseSequentialStream *chp = scfg->sc_channel;
  char **scmp = scfg->sc_completion;

  if (*(scmp + 1) != NULL) {
    4afa:	2b00      	cmp	r3, #0
    4afc:	d061      	beq.n	4bc2 <shellGetLine+0x432>
    chprintf(chp, SHELL_NEWLINE_STR);
    4afe:	4914      	ldr	r1, [pc, #80]	; (4b50 <shellGetLine+0x3c0>)
    4b00:	f7ff fd66 	bl	45d0 <chprintf>
    while (*scmp != NULL)
    4b04:	683a      	ldr	r2, [r7, #0]
    4b06:	b13a      	cbz	r2, 4b18 <shellGetLine+0x388>
      chprintf(chp, " %s", *scmp++);
    4b08:	4628      	mov	r0, r5
    4b0a:	4912      	ldr	r1, [pc, #72]	; (4b54 <shellGetLine+0x3c4>)
    4b0c:	f7ff fd60 	bl	45d0 <chprintf>
  BaseSequentialStream *chp = scfg->sc_channel;
  char **scmp = scfg->sc_completion;

  if (*(scmp + 1) != NULL) {
    chprintf(chp, SHELL_NEWLINE_STR);
    while (*scmp != NULL)
    4b10:	f857 2f04 	ldr.w	r2, [r7, #4]!
    4b14:	2a00      	cmp	r2, #0
    4b16:	d1f7      	bne.n	4b08 <shellGetLine+0x378>
      chprintf(chp, " %s", *scmp++);
    chprintf(chp, SHELL_NEWLINE_STR);
    4b18:	490d      	ldr	r1, [pc, #52]	; (4b50 <shellGetLine+0x3c0>)
    4b1a:	4628      	mov	r0, r5
    4b1c:	f7ff fd58 	bl	45d0 <chprintf>

    chprintf(chp, SHELL_PROMPT_STR);
    4b20:	490d      	ldr	r1, [pc, #52]	; (4b58 <shellGetLine+0x3c8>)
    4b22:	4628      	mov	r0, r5
    4b24:	f7ff fd54 	bl	45d0 <chprintf>
    chprintf(chp, "%s", line);
    4b28:	4628      	mov	r0, r5
    4b2a:	4908      	ldr	r1, [pc, #32]	; (4b4c <shellGetLine+0x3bc>)
    4b2c:	464a      	mov	r2, r9
    4b2e:	f7ff fd4f 	bl	45d0 <chprintf>
    if (c == 27) {
      escape = true;
      continue;
    }
    if (escape) {
      escape = false;
    4b32:	46b3      	mov	fp, r6
    4b34:	e63a      	b.n	47ac <shellGetLine+0x1c>
          break;
        }
      }
    }

    *(line + clen) = 0;
    4b36:	f889 6000 	strb.w	r6, [r9]
    4b3a:	e637      	b.n	47ac <shellGetLine+0x1c>
    4b3c:	00007160 	.word	0x00007160
    4b40:	1ffff004 	.word	0x1ffff004
    4b44:	00007140 	.word	0x00007140
    4b48:	0000714c 	.word	0x0000714c
    4b4c:	00007150 	.word	0x00007150
    4b50:	000077a0 	.word	0x000077a0
    4b54:	0000715c 	.word	0x0000715c
    4b58:	00007154 	.word	0x00007154
     * Since there isn't enough room left at the end of the buffer,
     * split the line to save up to the end of the buffer and then
     * wrap back to the beginning of the buffer.
     */
    int part_len = shp->sh_size - shp->sh_end - 1;
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, part_len);
    4b5c:	3501      	adds	r5, #1
    4b5e:	4649      	mov	r1, r9
    4b60:	4632      	mov	r2, r6
    4b62:	4428      	add	r0, r5
    4b64:	f001 fd74 	bl	6650 <memcpy>
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
    4b68:	9b01      	ldr	r3, [sp, #4]
    4b6a:	eb09 0106 	add.w	r1, r9, r6
    4b6e:	1ba2      	subs	r2, r4, r6
    4b70:	6818      	ldr	r0, [r3, #0]
    4b72:	f001 fd6d 	bl	6650 <memcpy>
    4b76:	e78b      	b.n	4a90 <shellGetLine+0x300>
  char *c = line + length;
  int clen = 0;

  if (*scmp != NULL) {
    if (*cmp == NULL) {
      clen = strlen(*scmp);
    4b78:	4660      	mov	r0, ip
    4b7a:	f001 fdb1 	bl	66e0 <strlen>
      int i = length;
      while ((c < line + clen) && (c < line + size - 1))
    4b7e:	eb09 0600 	add.w	r6, r9, r0
    4b82:	45b3      	cmp	fp, r6
    4b84:	d225      	bcs.n	4bd2 <shellGetLine+0x442>
    4b86:	4629      	mov	r1, r5
    4b88:	465b      	mov	r3, fp
    4b8a:	ea6f 0e0b 	mvn.w	lr, fp
    4b8e:	f8dd c00c 	ldr.w	ip, [sp, #12]
    4b92:	9a00      	ldr	r2, [sp, #0]
    4b94:	4605      	mov	r5, r0
    4b96:	e002      	b.n	4b9e <shellGetLine+0x40e>
    4b98:	4293      	cmp	r3, r2
    4b9a:	d018      	beq.n	4bce <shellGetLine+0x43e>
    4b9c:	6839      	ldr	r1, [r7, #0]
        *c++ = *(*scmp + i++);
    4b9e:	3301      	adds	r3, #1
    4ba0:	4419      	add	r1, r3
    4ba2:	4461      	add	r1, ip

  if (*scmp != NULL) {
    if (*cmp == NULL) {
      clen = strlen(*scmp);
      int i = length;
      while ((c < line + clen) && (c < line + size - 1))
    4ba4:	42b3      	cmp	r3, r6
        *c++ = *(*scmp + i++);
    4ba6:	f811 100e 	ldrb.w	r1, [r1, lr]
    4baa:	f803 1c01 	strb.w	r1, [r3, #-1]

  if (*scmp != NULL) {
    if (*cmp == NULL) {
      clen = strlen(*scmp);
      int i = length;
      while ((c < line + clen) && (c < line + size - 1))
    4bae:	d1f3      	bne.n	4b98 <shellGetLine+0x408>
        *c++ = *(*scmp + i++);
      if (c < line + size -1) {
    4bb0:	9900      	ldr	r1, [sp, #0]
    4bb2:	428b      	cmp	r3, r1
    4bb4:	462a      	mov	r2, r5
    4bb6:	d289      	bcs.n	4acc <shellGetLine+0x33c>
        *c = ' ';
        clen++;
    4bb8:	1c42      	adds	r2, r0, #1
      clen = strlen(*scmp);
      int i = length;
      while ((c < line + clen) && (c < line + size - 1))
        *c++ = *(*scmp + i++);
      if (c < line + size -1) {
        *c = ' ';
    4bba:	2320      	movs	r3, #32
    4bbc:	4610      	mov	r0, r2
    4bbe:	7033      	strb	r3, [r6, #0]
    4bc0:	e784      	b.n	4acc <shellGetLine+0x33c>

    chprintf(chp, SHELL_PROMPT_STR);
    chprintf(chp, "%s", line);
  }
  else {
    chprintf(chp, "%s", line + pos);
    4bc2:	465a      	mov	r2, fp
    4bc4:	4904      	ldr	r1, [pc, #16]	; (4bd8 <shellGetLine+0x448>)
    4bc6:	f7ff fd03 	bl	45d0 <chprintf>
    if (c == 27) {
      escape = true;
      continue;
    }
    if (escape) {
      escape = false;
    4bca:	46b3      	mov	fp, r6
    4bcc:	e5ee      	b.n	47ac <shellGetLine+0x1c>
    4bce:	462a      	mov	r2, r5
    4bd0:	e77c      	b.n	4acc <shellGetLine+0x33c>

  if (*scmp != NULL) {
    if (*cmp == NULL) {
      clen = strlen(*scmp);
      int i = length;
      while ((c < line + clen) && (c < line + size - 1))
    4bd2:	465e      	mov	r6, fp
    4bd4:	e7f0      	b.n	4bb8 <shellGetLine+0x428>
    4bd6:	bf00      	nop
    4bd8:	00007150 	.word	0x00007150
    4bdc:	f3af 8000 	nop.w

00004be0 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
    4be0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4be4:	4b56      	ldr	r3, [pc, #344]	; (4d40 <shellThread+0x160>)
  const ShellCommand *scp = scfg->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

#if SHELL_USE_HISTORY == TRUE
  *(scfg->sc_histbuf) = 0;
    4be6:	6882      	ldr	r2, [r0, #8]
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
    4be8:	681b      	ldr	r3, [r3, #0]
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
    4bea:	4956      	ldr	r1, [pc, #344]	; (4d44 <shellThread+0x164>)
    4bec:	f8df a16c 	ldr.w	sl, [pc, #364]	; 4d5c <shellThread+0x17c>
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
    4bf0:	b09c      	sub	sp, #112	; 0x70
  int n;
  ShellConfig *scfg = p;
  BaseSequentialStream *chp = scfg->sc_channel;
  const ShellCommand *scp = scfg->sc_commands;
    4bf2:	e890 0240 	ldmia.w	r0, {r6, r9}
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
    4bf6:	931b      	str	r3, [sp, #108]	; 0x6c
  const ShellCommand *scp = scfg->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

#if SHELL_USE_HISTORY == TRUE
  *(scfg->sc_histbuf) = 0;
    4bf8:	2300      	movs	r3, #0
    4bfa:	7013      	strb	r3, [r2, #0]
  ShellHistory hist = {
    4bfc:	6884      	ldr	r4, [r0, #8]
    4bfe:	68c2      	ldr	r2, [r0, #12]
    4c00:	9308      	str	r3, [sp, #32]
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
    4c02:	4680      	mov	r8, r0
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
    4c04:	4630      	mov	r0, r6
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

#if SHELL_USE_HISTORY == TRUE
  *(scfg->sc_histbuf) = 0;
  ShellHistory hist = {
    4c06:	9309      	str	r3, [sp, #36]	; 0x24
    4c08:	930a      	str	r3, [sp, #40]	; 0x28
    4c0a:	9406      	str	r4, [sp, #24]
    4c0c:	9207      	str	r2, [sp, #28]
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
    4c0e:	f7ff fcdf 	bl	45d0 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell"SHELL_NEWLINE_STR);
    4c12:	4630      	mov	r0, r6
    4c14:	494c      	ldr	r1, [pc, #304]	; (4d48 <shellThread+0x168>)
    4c16:	f7ff fcdb 	bl	45d0 <chprintf>
  while (true) {
    chprintf(chp, SHELL_PROMPT_STR);
    4c1a:	494c      	ldr	r1, [pc, #304]	; (4d4c <shellThread+0x16c>)
    4c1c:	4630      	mov	r0, r6
    4c1e:	f7ff fcd7 	bl	45d0 <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
    4c22:	4640      	mov	r0, r8
    4c24:	a90b      	add	r1, sp, #44	; 0x2c
    4c26:	2240      	movs	r2, #64	; 0x40
    4c28:	ab06      	add	r3, sp, #24
    4c2a:	f7ff fdb1 	bl	4790 <shellGetLine>
    4c2e:	bb80      	cbnz	r0, 4c92 <shellThread+0xb2>
      /* Putting a delay in order to avoid an endless loop trying to read
         an unavailable stream.*/
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
    4c30:	4669      	mov	r1, sp
    4c32:	a80b      	add	r0, sp, #44	; 0x2c
    4c34:	f7ff fcdc 	bl	45f0 <parse_arguments>
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
    4c38:	4669      	mov	r1, sp
      /* Putting a delay in order to avoid an endless loop trying to read
         an unavailable stream.*/
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
    4c3a:	4607      	mov	r7, r0
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
    4c3c:	2000      	movs	r0, #0
    4c3e:	ad01      	add	r5, sp, #4
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    4c40:	2400      	movs	r4, #0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
    4c42:	f7ff fcd5 	bl	45f0 <parse_arguments>
    4c46:	b150      	cbz	r0, 4c5e <shellThread+0x7e>
      if (n >= SHELL_MAX_ARGUMENTS) {
    4c48:	2c04      	cmp	r4, #4
    4c4a:	d01b      	beq.n	4c84 <shellThread+0xa4>
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    4c4c:	f845 0b04 	str.w	r0, [r5], #4
#endif
    }
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
    4c50:	4669      	mov	r1, sp
    4c52:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    4c54:	3401      	adds	r4, #1
#endif
    }
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
    4c56:	f7ff fccb 	bl	45f0 <parse_arguments>
    4c5a:	2800      	cmp	r0, #0
    4c5c:	d1f4      	bne.n	4c48 <shellThread+0x68>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
    4c5e:	ab1c      	add	r3, sp, #112	; 0x70
    4c60:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    4c64:	f843 0c6c 	str.w	r0, [r3, #-108]
    if (cmd != NULL) {
    4c68:	2f00      	cmp	r7, #0
    4c6a:	d0d6      	beq.n	4c1a <shellThread+0x3a>
      if (strcmp(cmd, "help") == 0) {
    4c6c:	4638      	mov	r0, r7
    4c6e:	4938      	ldr	r1, [pc, #224]	; (4d50 <shellThread+0x170>)
    4c70:	f7fc f8ce 	bl	e10 <strcmp>
    4c74:	b988      	cbnz	r0, 4c9a <shellThread+0xba>
        if (n > 0) {
          shellUsage(chp, "help");
    4c76:	4630      	mov	r0, r6
      args[n++] = lp;
    }
    args[n] = NULL;
    if (cmd != NULL) {
      if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
    4c78:	b31c      	cbz	r4, 4cc2 <shellThread+0xe2>
          shellUsage(chp, "help");
    4c7a:	4936      	ldr	r1, [pc, #216]	; (4d54 <shellThread+0x174>)
    4c7c:	4a34      	ldr	r2, [pc, #208]	; (4d50 <shellThread+0x170>)
    4c7e:	f7ff fca7 	bl	45d0 <chprintf>
          continue;
    4c82:	e7ca      	b.n	4c1a <shellThread+0x3a>
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
    4c84:	4630      	mov	r0, r6
    4c86:	4934      	ldr	r1, [pc, #208]	; (4d58 <shellThread+0x178>)
    4c88:	f7ff fca2 	bl	45d0 <chprintf>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
    4c8c:	2300      	movs	r3, #0
    4c8e:	9305      	str	r3, [sp, #20]
    4c90:	e7c3      	b.n	4c1a <shellThread+0x3a>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
    4c92:	2064      	movs	r0, #100	; 0x64
    4c94:	f7fc feb4 	bl	1a00 <chThdSleep>
    4c98:	e7ca      	b.n	4c30 <shellThread+0x50>
}

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
    4c9a:	f8da 0000 	ldr.w	r0, [sl]
    4c9e:	2800      	cmp	r0, #0
    4ca0:	d032      	beq.n	4d08 <shellThread+0x128>
    4ca2:	4d2e      	ldr	r5, [pc, #184]	; (4d5c <shellThread+0x17c>)
    4ca4:	e002      	b.n	4cac <shellThread+0xcc>
    4ca6:	f855 0f08 	ldr.w	r0, [r5, #8]!
    4caa:	b368      	cbz	r0, 4d08 <shellThread+0x128>
    if (strcmp(scp->sc_name, name) == 0) {
    4cac:	4639      	mov	r1, r7
    4cae:	f7fc f8af 	bl	e10 <strcmp>
    4cb2:	2800      	cmp	r0, #0
    4cb4:	d1f7      	bne.n	4ca6 <shellThread+0xc6>
      scp->sc_function(chp, argc, argv);
    4cb6:	686b      	ldr	r3, [r5, #4]
    4cb8:	4621      	mov	r1, r4
    4cba:	4630      	mov	r0, r6
    4cbc:	aa01      	add	r2, sp, #4
    4cbe:	4798      	blx	r3
    4cc0:	e7ab      	b.n	4c1a <shellThread+0x3a>
      if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
          shellUsage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help ");
    4cc2:	4927      	ldr	r1, [pc, #156]	; (4d60 <shellThread+0x180>)
    4cc4:	f7ff fc84 	bl	45d0 <chprintf>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
    4cc8:	f8da 2000 	ldr.w	r2, [sl]
    4ccc:	b142      	cbz	r2, 4ce0 <shellThread+0x100>
    4cce:	4c23      	ldr	r4, [pc, #140]	; (4d5c <shellThread+0x17c>)
    chprintf(chp, "%s ", scp->sc_name);
    4cd0:	4924      	ldr	r1, [pc, #144]	; (4d64 <shellThread+0x184>)
    4cd2:	4630      	mov	r0, r6
    4cd4:	f7ff fc7c 	bl	45d0 <chprintf>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
    4cd8:	f854 2f08 	ldr.w	r2, [r4, #8]!
    4cdc:	2a00      	cmp	r2, #0
    4cde:	d1f7      	bne.n	4cd0 <shellThread+0xf0>
          shellUsage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help ");
        list_commands(chp, shell_local_commands);
        if (scp != NULL)
    4ce0:	f1b9 0f00 	cmp.w	r9, #0
    4ce4:	d00b      	beq.n	4cfe <shellThread+0x11e>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
    4ce6:	f8d9 2000 	ldr.w	r2, [r9]
    4cea:	b142      	cbz	r2, 4cfe <shellThread+0x11e>
    4cec:	464c      	mov	r4, r9
    chprintf(chp, "%s ", scp->sc_name);
    4cee:	4630      	mov	r0, r6
    4cf0:	491c      	ldr	r1, [pc, #112]	; (4d64 <shellThread+0x184>)
    4cf2:	f7ff fc6d 	bl	45d0 <chprintf>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
    4cf6:	f854 2f08 	ldr.w	r2, [r4, #8]!
    4cfa:	2a00      	cmp	r2, #0
    4cfc:	d1f7      	bne.n	4cee <shellThread+0x10e>
        }
        chprintf(chp, "Commands: help ");
        list_commands(chp, shell_local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, SHELL_NEWLINE_STR);
    4cfe:	4630      	mov	r0, r6
    4d00:	4910      	ldr	r1, [pc, #64]	; (4d44 <shellThread+0x164>)
    4d02:	f7ff fc65 	bl	45d0 <chprintf>
    4d06:	e788      	b.n	4c1a <shellThread+0x3a>
      }
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
    4d08:	f1b9 0f00 	cmp.w	r9, #0
    4d0c:	d00d      	beq.n	4d2a <shellThread+0x14a>
}

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
    4d0e:	f8d9 0000 	ldr.w	r0, [r9]
    4d12:	b150      	cbz	r0, 4d2a <shellThread+0x14a>
    4d14:	464d      	mov	r5, r9
    4d16:	e002      	b.n	4d1e <shellThread+0x13e>
    4d18:	f855 0f08 	ldr.w	r0, [r5, #8]!
    4d1c:	b128      	cbz	r0, 4d2a <shellThread+0x14a>
    if (strcmp(scp->sc_name, name) == 0) {
    4d1e:	4639      	mov	r1, r7
    4d20:	f7fc f876 	bl	e10 <strcmp>
    4d24:	2800      	cmp	r0, #0
    4d26:	d1f7      	bne.n	4d18 <shellThread+0x138>
    4d28:	e7c5      	b.n	4cb6 <shellThread+0xd6>
          list_commands(chp, scp);
        chprintf(chp, SHELL_NEWLINE_STR);
      }
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
    4d2a:	463a      	mov	r2, r7
    4d2c:	4630      	mov	r0, r6
    4d2e:	490e      	ldr	r1, [pc, #56]	; (4d68 <shellThread+0x188>)
    4d30:	f7ff fc4e 	bl	45d0 <chprintf>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
    4d34:	4630      	mov	r0, r6
    4d36:	490d      	ldr	r1, [pc, #52]	; (4d6c <shellThread+0x18c>)
    4d38:	f7ff fc4a 	bl	45d0 <chprintf>
    4d3c:	e76d      	b.n	4c1a <shellThread+0x3a>
    4d3e:	bf00      	nop
    4d40:	1ffff034 	.word	0x1ffff034
    4d44:	000077a0 	.word	0x000077a0
    4d48:	00007168 	.word	0x00007168
    4d4c:	00007154 	.word	0x00007154
    4d50:	00007160 	.word	0x00007160
    4d54:	00007194 	.word	0x00007194
    4d58:	0000717c 	.word	0x0000717c
    4d5c:	1ffff004 	.word	0x1ffff004
    4d60:	000071a0 	.word	0x000071a0
    4d64:	000071b0 	.word	0x000071b0
    4d68:	00007150 	.word	0x00007150
    4d6c:	000071b4 	.word	0x000071b4

00004d70 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc != 1) {
    4d70:	2901      	cmp	r1, #1
    4d72:	d003      	beq.n	4d7c <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
    4d74:	4903      	ldr	r1, [pc, #12]	; (4d84 <cmd_echo+0x14>)
    4d76:	4a04      	ldr	r2, [pc, #16]	; (4d88 <cmd_echo+0x18>)
    4d78:	f7ff bc2a 	b.w	45d0 <chprintf>
    return;
  }
  chprintf(chp, "%s"SHELL_NEWLINE_STR, argv[0]);
    4d7c:	6812      	ldr	r2, [r2, #0]
    4d7e:	4903      	ldr	r1, [pc, #12]	; (4d8c <cmd_echo+0x1c>)
    4d80:	f7ff bc26 	b.w	45d0 <chprintf>
    4d84:	00007194 	.word	0x00007194
    4d88:	00007200 	.word	0x00007200
    4d8c:	00007210 	.word	0x00007210

00004d90 <cmd_info>:

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
    4d90:	2900      	cmp	r1, #0
    4d92:	dd03      	ble.n	4d9c <cmd_info+0xc>
    shellUsage(chp, "info");
    4d94:	4919      	ldr	r1, [pc, #100]	; (4dfc <cmd_info+0x6c>)
    4d96:	4a1a      	ldr	r2, [pc, #104]	; (4e00 <cmd_info+0x70>)
    4d98:	f7ff bc1a 	b.w	45d0 <chprintf>
  shellExit(MSG_OK);
}
#endif

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
    4d9c:	b510      	push	{r4, lr}
  if (argc > 0) {
    shellUsage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
    4d9e:	4919      	ldr	r1, [pc, #100]	; (4e04 <cmd_info+0x74>)
    4da0:	4a19      	ldr	r2, [pc, #100]	; (4e08 <cmd_info+0x78>)
  shellExit(MSG_OK);
}
#endif

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
    4da2:	b082      	sub	sp, #8
    4da4:	4604      	mov	r4, r0
  if (argc > 0) {
    shellUsage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
    4da6:	f7ff fc13 	bl	45d0 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s"SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
    4daa:	4620      	mov	r0, r4
    4dac:	4917      	ldr	r1, [pc, #92]	; (4e0c <cmd_info+0x7c>)
    4dae:	4a18      	ldr	r2, [pc, #96]	; (4e10 <cmd_info+0x80>)
    4db0:	f7ff fc0e 	bl	45d0 <chprintf>
#endif
  chprintf(chp, "Architecture: %s"SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
    4db4:	4620      	mov	r0, r4
    4db6:	4917      	ldr	r1, [pc, #92]	; (4e14 <cmd_info+0x84>)
    4db8:	4a17      	ldr	r2, [pc, #92]	; (4e18 <cmd_info+0x88>)
    4dba:	f7ff fc09 	bl	45d0 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s"SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
    4dbe:	4620      	mov	r0, r4
    4dc0:	4916      	ldr	r1, [pc, #88]	; (4e1c <cmd_info+0x8c>)
    4dc2:	4a17      	ldr	r2, [pc, #92]	; (4e20 <cmd_info+0x90>)
    4dc4:	f7ff fc04 	bl	45d0 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s"SHELL_NEWLINE_STR, PORT_INFO);
    4dc8:	4620      	mov	r0, r4
    4dca:	4916      	ldr	r1, [pc, #88]	; (4e24 <cmd_info+0x94>)
    4dcc:	4a16      	ldr	r2, [pc, #88]	; (4e28 <cmd_info+0x98>)
    4dce:	f7ff fbff 	bl	45d0 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s"SHELL_NEWLINE_STR, PLATFORM_NAME);
    4dd2:	4620      	mov	r0, r4
    4dd4:	4915      	ldr	r1, [pc, #84]	; (4e2c <cmd_info+0x9c>)
    4dd6:	4a16      	ldr	r2, [pc, #88]	; (4e30 <cmd_info+0xa0>)
    4dd8:	f7ff fbfa 	bl	45d0 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s"SHELL_NEWLINE_STR, BOARD_NAME);
    4ddc:	4620      	mov	r0, r4
    4dde:	4915      	ldr	r1, [pc, #84]	; (4e34 <cmd_info+0xa4>)
    4de0:	4a15      	ldr	r2, [pc, #84]	; (4e38 <cmd_info+0xa8>)
    4de2:	f7ff fbf5 	bl	45d0 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s"SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
    4de6:	4b15      	ldr	r3, [pc, #84]	; (4e3c <cmd_info+0xac>)
    4de8:	9300      	str	r3, [sp, #0]
    4dea:	4620      	mov	r0, r4
    4dec:	4914      	ldr	r1, [pc, #80]	; (4e40 <cmd_info+0xb0>)
    4dee:	4a15      	ldr	r2, [pc, #84]	; (4e44 <cmd_info+0xb4>)
    4df0:	4b15      	ldr	r3, [pc, #84]	; (4e48 <cmd_info+0xb8>)
    4df2:	f7ff fbed 	bl	45d0 <chprintf>
#endif
#endif
}
    4df6:	b002      	add	sp, #8
    4df8:	bd10      	pop	{r4, pc}
    4dfa:	bf00      	nop
    4dfc:	00007194 	.word	0x00007194
    4e00:	00007218 	.word	0x00007218
    4e04:	00007220 	.word	0x00007220
    4e08:	00007234 	.word	0x00007234
    4e0c:	0000723c 	.word	0x0000723c
    4e10:	00007250 	.word	0x00007250
    4e14:	0000725c 	.word	0x0000725c
    4e18:	00007270 	.word	0x00007270
    4e1c:	0000727c 	.word	0x0000727c
    4e20:	00007290 	.word	0x00007290
    4e24:	0000729c 	.word	0x0000729c
    4e28:	000072b0 	.word	0x000072b0
    4e2c:	000072c8 	.word	0x000072c8
    4e30:	000072dc 	.word	0x000072dc
    4e34:	000072e4 	.word	0x000072e4
    4e38:	000072f8 	.word	0x000072f8
    4e3c:	00007338 	.word	0x00007338
    4e40:	00007310 	.word	0x00007310
    4e44:	00007328 	.word	0x00007328
    4e48:	00007334 	.word	0x00007334
    4e4c:	f3af 8000 	nop.w

00004e50 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
    4e50:	2900      	cmp	r1, #0
    4e52:	dd03      	ble.n	4e5c <cmd_threads+0xc>
    shellUsage(chp, "threads");
    4e54:	4918      	ldr	r1, [pc, #96]	; (4eb8 <cmd_threads+0x68>)
    4e56:	4a19      	ldr	r2, [pc, #100]	; (4ebc <cmd_threads+0x6c>)
    4e58:	f7ff bbba 	b.w	45d0 <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
#endif

#if (SHELL_CMD_THREADS_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
    4e5c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "threads");
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
    4e60:	4917      	ldr	r1, [pc, #92]	; (4ec0 <cmd_threads+0x70>)
    4e62:	f8df 9064 	ldr.w	r9, [pc, #100]	; 4ec8 <cmd_threads+0x78>
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
    4e66:	f8df 8064 	ldr.w	r8, [pc, #100]	; 4ecc <cmd_threads+0x7c>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
#endif

#if (SHELL_CMD_THREADS_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
    4e6a:	b087      	sub	sp, #28
    4e6c:	4607      	mov	r7, r0
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "threads");
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
    4e6e:	f7ff fbaf 	bl	45d0 <chprintf>
  tp = chRegFirstThread();
    4e72:	f7fc ff3d 	bl	1cf0 <chRegFirstThread>
    4e76:	4604      	mov	r4, r0
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
    4e78:	f894 0020 	ldrb.w	r0, [r4, #32]
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
    4e7c:	f894 5022 	ldrb.w	r5, [r4, #34]	; 0x22
             tp->name == NULL ? "" : tp->name);
    4e80:	69a1      	ldr	r1, [r4, #24]
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
    4e82:	f859 6020 	ldr.w	r6, [r9, r0, lsl #2]
    4e86:	68a0      	ldr	r0, [r4, #8]
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
  tp = chRegFirstThread();
  do {
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
    4e88:	69e2      	ldr	r2, [r4, #28]
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
    4e8a:	68e3      	ldr	r3, [r4, #12]
    4e8c:	9002      	str	r0, [sp, #8]
    4e8e:	2900      	cmp	r1, #0
    4e90:	bf08      	it	eq
    4e92:	4641      	moveq	r1, r8
    4e94:	3d01      	subs	r5, #1
    4e96:	9104      	str	r1, [sp, #16]
    4e98:	9400      	str	r4, [sp, #0]
    4e9a:	490a      	ldr	r1, [pc, #40]	; (4ec4 <cmd_threads+0x74>)
    4e9c:	9501      	str	r5, [sp, #4]
    4e9e:	9603      	str	r6, [sp, #12]
    4ea0:	4638      	mov	r0, r7
    4ea2:	f7ff fb95 	bl	45d0 <chprintf>
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
    4ea6:	4620      	mov	r0, r4
    4ea8:	f7fc ff4a 	bl	1d40 <chRegNextThread>
  } while (tp != NULL);
    4eac:	4604      	mov	r4, r0
    4eae:	2800      	cmp	r0, #0
    4eb0:	d1e2      	bne.n	4e78 <cmd_threads+0x28>
}
    4eb2:	b007      	add	sp, #28
    4eb4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4eb8:	00007194 	.word	0x00007194
    4ebc:	00007344 	.word	0x00007344
    4ec0:	0000734c 	.word	0x0000734c
    4ec4:	0000738c 	.word	0x0000738c
    4ec8:	000071c0 	.word	0x000071c0
    4ecc:	0000752c 	.word	0x0000752c

00004ed0 <cmd_mem>:
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
#endif

#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
    4ed0:	b530      	push	{r4, r5, lr}
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
    4ed2:	2900      	cmp	r1, #0
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
#endif

#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
    4ed4:	b083      	sub	sp, #12
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
    4ed6:	dd05      	ble.n	4ee4 <cmd_mem+0x14>
    shellUsage(chp, "mem");
    4ed8:	4912      	ldr	r1, [pc, #72]	; (4f24 <cmd_mem+0x54>)
    4eda:	4a13      	ldr	r2, [pc, #76]	; (4f28 <cmd_mem+0x58>)
    4edc:	f7ff fb78 	bl	45d0 <chprintf>
  n = chHeapStatus(NULL, &total, &largest);
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
    4ee0:	b003      	add	sp, #12
    4ee2:	bd30      	pop	{r4, r5, pc}
    4ee4:	4604      	mov	r4, r0
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "mem");
    return;
  }
  n = chHeapStatus(NULL, &total, &largest);
    4ee6:	4669      	mov	r1, sp
    4ee8:	aa01      	add	r2, sp, #4
    4eea:	2000      	movs	r0, #0
    4eec:	f7fd fb88 	bl	2600 <chHeapStatus>
    4ef0:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
    4ef2:	f7fd fa65 	bl	23c0 <chCoreGetStatusX>
    4ef6:	490d      	ldr	r1, [pc, #52]	; (4f2c <cmd_mem+0x5c>)
    4ef8:	4602      	mov	r2, r0
    4efa:	4620      	mov	r0, r4
    4efc:	f7ff fb68 	bl	45d0 <chprintf>
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
    4f00:	462a      	mov	r2, r5
    4f02:	4620      	mov	r0, r4
    4f04:	490a      	ldr	r1, [pc, #40]	; (4f30 <cmd_mem+0x60>)
    4f06:	f7ff fb63 	bl	45d0 <chprintf>
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
    4f0a:	9a00      	ldr	r2, [sp, #0]
    4f0c:	4909      	ldr	r1, [pc, #36]	; (4f34 <cmd_mem+0x64>)
    4f0e:	4620      	mov	r0, r4
    4f10:	f7ff fb5e 	bl	45d0 <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
    4f14:	4620      	mov	r0, r4
    4f16:	4908      	ldr	r1, [pc, #32]	; (4f38 <cmd_mem+0x68>)
    4f18:	9a01      	ldr	r2, [sp, #4]
    4f1a:	f7ff fb59 	bl	45d0 <chprintf>
}
    4f1e:	b003      	add	sp, #12
    4f20:	bd30      	pop	{r4, r5, pc}
    4f22:	bf00      	nop
    4f24:	00007194 	.word	0x00007194
    4f28:	000073b4 	.word	0x000073b4
    4f2c:	000073b8 	.word	0x000073b8
    4f30:	000073d8 	.word	0x000073d8
    4f34:	000073f0 	.word	0x000073f0
    4f38:	00007410 	.word	0x00007410
    4f3c:	f3af 8000 	nop.w

00004f40 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
    4f40:	2900      	cmp	r1, #0
    4f42:	dd03      	ble.n	4f4c <cmd_systime+0xc>
    shellUsage(chp, "systime");
    4f44:	4913      	ldr	r1, [pc, #76]	; (4f94 <cmd_systime+0x54>)
    4f46:	4a14      	ldr	r2, [pc, #80]	; (4f98 <cmd_systime+0x58>)
    4f48:	f7ff bb42 	b.w	45d0 <chprintf>
  chprintf(chp, "%s"SHELL_NEWLINE_STR, argv[0]);
}
#endif

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
    4f4c:	b570      	push	{r4, r5, r6, lr}
    4f4e:	2320      	movs	r3, #32
    4f50:	4605      	mov	r5, r0
    4f52:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
    4f56:	4c11      	ldr	r4, [pc, #68]	; (4f9c <cmd_systime+0x5c>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    4f58:	f7fc feaa 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    4f5c:	f7fc f868 	bl	1030 <_dbg_check_lock>
    4f60:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    4f62:	f7fc f875 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    4f66:	f7fc feab 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    4f6a:	6823      	ldr	r3, [r4, #0]
    4f6c:	42a3      	cmp	r3, r4
    4f6e:	d007      	beq.n	4f80 <cmd_systime+0x40>
    4f70:	69a2      	ldr	r2, [r4, #24]
    4f72:	689b      	ldr	r3, [r3, #8]
    4f74:	6892      	ldr	r2, [r2, #8]
    4f76:	429a      	cmp	r2, r3
    4f78:	d202      	bcs.n	4f80 <cmd_systime+0x40>
    4f7a:	4809      	ldr	r0, [pc, #36]	; (4fa0 <cmd_systime+0x60>)
    4f7c:	f7fc f800 	bl	f80 <chSysHalt>
    4f80:	2300      	movs	r3, #0
    4f82:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
    4f86:	4907      	ldr	r1, [pc, #28]	; (4fa4 <cmd_systime+0x64>)
    4f88:	4628      	mov	r0, r5
    4f8a:	4632      	mov	r2, r6
}
    4f8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
    4f90:	f7ff bb1e 	b.w	45d0 <chprintf>
    4f94:	00007194 	.word	0x00007194
    4f98:	00007430 	.word	0x00007430
    4f9c:	1ffff228 	.word	0x1ffff228
    4fa0:	000074e0 	.word	0x000074e0
    4fa4:	00007438 	.word	0x00007438
    4fa8:	f3af 8000 	nop.w
    4fac:	f3af 8000 	nop.w

00004fb0 <orchard_event_thread>:
extern event_source_t chg_keepalive_event;
void chg_keepalive_handler(eventid_t id);

static thread_t *eventThr = NULL;
static THD_WORKING_AREA(waOrchardEventThread, 0x900);
static THD_FUNCTION(orchard_event_thread, arg) {
    4fb0:	b570      	push	{r4, r5, r6, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
    4fb2:	4d1a      	ldr	r5, [pc, #104]	; (501c <orchard_event_thread+0x6c>)
    4fb4:	4a1a      	ldr	r2, [pc, #104]	; (5020 <orchard_event_thread+0x70>)
    4fb6:	69ab      	ldr	r3, [r5, #24]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
    4fb8:	481a      	ldr	r0, [pc, #104]	; (5024 <orchard_event_thread+0x74>)
    4fba:	619a      	str	r2, [r3, #24]
    4fbc:	491a      	ldr	r1, [pc, #104]	; (5028 <orchard_event_thread+0x78>)
  struct evt_table orchard_events;

  chRegSetThreadName("Orchard Event Threads");

  evtTableInit(orchard_events, 32);
  evtTableHook(orchard_events, chg_keepalive_event, chg_keepalive_handler);
    4fbe:	4e1b      	ldr	r6, [pc, #108]	; (502c <orchard_event_thread+0x7c>)
    4fc0:	2201      	movs	r2, #1
    4fc2:	f04f 33ff 	mov.w	r3, #4294967295
    4fc6:	f7fd f833 	bl	2030 <chEvtRegisterMaskWithFlags>
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
    4fca:	69ab      	ldr	r3, [r5, #24]
    4fcc:	4a18      	ldr	r2, [pc, #96]	; (5030 <orchard_event_thread+0x80>)
    4fce:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    4fd2:	6016      	str	r6, [r2, #0]

  while (!chThdShouldTerminateX())
    4fd4:	075a      	lsls	r2, r3, #29
    4fd6:	d41c      	bmi.n	5012 <orchard_event_thread+0x62>
    chEvtDispatch(evtHandlers(orchard_events), chEvtWaitOne(ALL_EVENTS));
    4fd8:	f04f 30ff 	mov.w	r0, #4294967295
    4fdc:	f7fd f910 	bl	2200 <chEvtWaitOne>
    4fe0:	4c13      	ldr	r4, [pc, #76]	; (5030 <orchard_event_thread+0x80>)
    4fe2:	4601      	mov	r1, r0
    4fe4:	4620      	mov	r0, r4
    4fe6:	f7fd f8db 	bl	21a0 <chEvtDispatch>
    4fea:	69ab      	ldr	r3, [r5, #24]
    4fec:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  chRegSetThreadName("Orchard Event Threads");

  evtTableInit(orchard_events, 32);
  evtTableHook(orchard_events, chg_keepalive_event, chg_keepalive_handler);

  while (!chThdShouldTerminateX())
    4ff0:	075b      	lsls	r3, r3, #29
    4ff2:	d5f1      	bpl.n	4fd8 <orchard_event_thread+0x28>
    chEvtDispatch(evtHandlers(orchard_events), chEvtWaitOne(ALL_EVENTS));

  evtTableUnhook(orchard_events, chg_keepalive_event, chg_keepalive_handler);
    4ff4:	6823      	ldr	r3, [r4, #0]
    4ff6:	42b3      	cmp	r3, r6
    4ff8:	d00b      	beq.n	5012 <orchard_event_thread+0x62>
    4ffa:	2320      	movs	r3, #32
    4ffc:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    5000:	f7fc fe56 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    5004:	f7fc f814 	bl	1030 <_dbg_check_lock>

  chSysLock();
  chThdExitS(MSG_OK);
    5008:	2000      	movs	r0, #0
}
    500a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chEvtDispatch(evtHandlers(orchard_events), chEvtWaitOne(ALL_EVENTS));

  evtTableUnhook(orchard_events, chg_keepalive_event, chg_keepalive_handler);

  chSysLock();
  chThdExitS(MSG_OK);
    500e:	f7fc bc6f 	b.w	18f0 <chThdExitS>
  evtTableHook(orchard_events, chg_keepalive_event, chg_keepalive_handler);

  while (!chThdShouldTerminateX())
    chEvtDispatch(evtHandlers(orchard_events), chEvtWaitOne(ALL_EVENTS));

  evtTableUnhook(orchard_events, chg_keepalive_event, chg_keepalive_handler);
    5012:	4804      	ldr	r0, [pc, #16]	; (5024 <orchard_event_thread+0x74>)
    5014:	4904      	ldr	r1, [pc, #16]	; (5028 <orchard_event_thread+0x78>)
    5016:	f7fd f843 	bl	20a0 <chEvtUnregister>
    501a:	e7ee      	b.n	4ffa <orchard_event_thread+0x4a>
    501c:	1ffff228 	.word	0x1ffff228
    5020:	00007510 	.word	0x00007510
    5024:	2000056c 	.word	0x2000056c
    5028:	1ffff4cc 	.word	0x1ffff4cc
    502c:	00005d01 	.word	0x00005d01
    5030:	200001c0 	.word	0x200001c0
    5034:	f3af 8000 	nop.w
    5038:	f3af 8000 	nop.w
    503c:	f3af 8000 	nop.w

00005040 <main>:
void ggOn(void);
void spiRuntSetup(SPIDriver *spip);
/*
 * Application entry point.
 */
int main(void) {
    5040:	b5f0      	push	{r4, r5, r6, r7, lr}
    5042:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    5044:	f7fd fb94 	bl	2770 <halInit>
  // K22 has a separate setting for open-drain that has to be explicitly set for I2C
  // this breaks the chibiOS abstractions, which were not made to anticipate this oddity.
  PORT_PCR_REG(PORTB,2) |= PORTx_PCRn_ODE;
    5048:	4a37      	ldr	r2, [pc, #220]	; (5128 <main+0xe8>)
  PORT_PCR_REG(PORTB,3) |= PORTx_PCRn_ODE;
  
  PORT_PCR_REG(PORTC,10) |= PORTx_PCRn_ODE;
    504a:	4b38      	ldr	r3, [pc, #224]	; (512c <main+0xec>)
   *   RTOS is active.
   */
  halInit();
  // K22 has a separate setting for open-drain that has to be explicitly set for I2C
  // this breaks the chibiOS abstractions, which were not made to anticipate this oddity.
  PORT_PCR_REG(PORTB,2) |= PORTx_PCRn_ODE;
    504c:	6891      	ldr	r1, [r2, #8]
  PORT_PCR_REG(PORTC,11) |= PORTx_PCRn_ODE;

  chSysInit();

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palSetPad(IOPORT2, 1); // set shipmode_n to 1 (disable shipmode)
    504e:	4e38      	ldr	r6, [pc, #224]	; (5130 <main+0xf0>)
    5050:	4d38      	ldr	r5, [pc, #224]	; (5134 <main+0xf4>)
    5052:	4c39      	ldr	r4, [pc, #228]	; (5138 <main+0xf8>)
   *   RTOS is active.
   */
  halInit();
  // K22 has a separate setting for open-drain that has to be explicitly set for I2C
  // this breaks the chibiOS abstractions, which were not made to anticipate this oddity.
  PORT_PCR_REG(PORTB,2) |= PORTx_PCRn_ODE;
    5054:	f041 0120 	orr.w	r1, r1, #32
    5058:	6091      	str	r1, [r2, #8]
  PORT_PCR_REG(PORTB,3) |= PORTx_PCRn_ODE;
    505a:	68d1      	ldr	r1, [r2, #12]
    505c:	f041 0120 	orr.w	r1, r1, #32
    5060:	60d1      	str	r1, [r2, #12]
  
  PORT_PCR_REG(PORTC,10) |= PORTx_PCRn_ODE;
    5062:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    5064:	f042 0220 	orr.w	r2, r2, #32
    5068:	629a      	str	r2, [r3, #40]	; 0x28
  PORT_PCR_REG(PORTC,11) |= PORTx_PCRn_ODE;
    506a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    506c:	f042 0220 	orr.w	r2, r2, #32
    5070:	62da      	str	r2, [r3, #44]	; 0x2c

  chSysInit();
    5072:	f7fb ff2d 	bl	ed0 <chSysInit>

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palSetPad(IOPORT2, 1); // set shipmode_n to 1 (disable shipmode)
  palSetPad(IOPORT3, 8); // set BATT_SRST
    5076:	4b31      	ldr	r3, [pc, #196]	; (513c <main+0xfc>)

  /*
   * Activates the EXT driver 1.
   */
  //  extStart(&EXTD1, &extcfg);
  sdStart(&SD4, &serialConfig);
    5078:	4931      	ldr	r1, [pc, #196]	; (5140 <main+0x100>)
    507a:	4832      	ldr	r0, [pc, #200]	; (5144 <main+0x104>)

  chSysInit();

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palSetPad(IOPORT2, 1); // set shipmode_n to 1 (disable shipmode)
  palSetPad(IOPORT3, 8); // set BATT_SRST
    507c:	f44f 7280 	mov.w	r2, #256	; 0x100
  PORT_PCR_REG(PORTC,11) |= PORTx_PCRn_ODE;

  chSysInit();

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palSetPad(IOPORT2, 1); // set shipmode_n to 1 (disable shipmode)
    5080:	2702      	movs	r7, #2
    5082:	6077      	str	r7, [r6, #4]
  palSetPad(IOPORT3, 8); // set BATT_SRST
    5084:	605a      	str	r2, [r3, #4]

  /*
   * Activates the EXT driver 1.
   */
  //  extStart(&EXTD1, &extcfg);
  sdStart(&SD4, &serialConfig);
    5086:	f7fd ff3b 	bl	2f00 <sdStart>
  
  i2cObjectInit(&I2CD1);
    508a:	482f      	ldr	r0, [pc, #188]	; (5148 <main+0x108>)
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
    508c:	4f2f      	ldr	r7, [pc, #188]	; (514c <main+0x10c>)
    508e:	f7fd fde7 	bl	2c60 <i2cObjectInit>
  i2cStart(&I2CD1, &i2c_config);
    5092:	482d      	ldr	r0, [pc, #180]	; (5148 <main+0x108>)
    5094:	492e      	ldr	r1, [pc, #184]	; (5150 <main+0x110>)
    5096:	f7fd fdeb 	bl	2c70 <i2cStart>
  chgSetSafety(); // has to be first thing written to the battery controller
    509a:	f000 fe51 	bl	5d40 <chgSetSafety>

  spiStart(&SPID2, &spi_config);
    509e:	492d      	ldr	r1, [pc, #180]	; (5154 <main+0x114>)
    50a0:	482d      	ldr	r0, [pc, #180]	; (5158 <main+0x118>)
    50a2:	f7fd ff75 	bl	2f90 <spiStart>
  spiRuntSetup(&SPID2);  // setup our custom runt driver for the fifo-less SPI1 interface
    50a6:	482c      	ldr	r0, [pc, #176]	; (5158 <main+0x118>)
    50a8:	f000 fa62 	bl	5570 <spiRuntSetup>
  
  spiUnselect(&SPID2);
    50ac:	482a      	ldr	r0, [pc, #168]	; (5158 <main+0x118>)
    50ae:	f7fd ffdf 	bl	3070 <spiUnselect>

  shellInit();
    50b2:	f7ff fb65 	bl	4780 <shellInit>

  chprintf(stream, SHELL_NEWLINE_STR SHELL_NEWLINE_STR);
    50b6:	4929      	ldr	r1, [pc, #164]	; (515c <main+0x11c>)
    50b8:	4822      	ldr	r0, [pc, #136]	; (5144 <main+0x104>)
    50ba:	f7ff fa89 	bl	45d0 <chprintf>
  chprintf(stream, "XZ bootloader.  Based on build %s"SHELL_NEWLINE_STR,
    50be:	4b28      	ldr	r3, [pc, #160]	; (5160 <main+0x120>)
    50c0:	4928      	ldr	r1, [pc, #160]	; (5164 <main+0x124>)
    50c2:	681a      	ldr	r2, [r3, #0]
    50c4:	481f      	ldr	r0, [pc, #124]	; (5144 <main+0x104>)
    50c6:	f7ff fa83 	bl	45d0 <chprintf>
	   gitversion);
  chprintf(stream, "Core free memory : %d bytes"SHELL_NEWLINE_STR,
    50ca:	f7fd f979 	bl	23c0 <chCoreGetStatusX>
    50ce:	4926      	ldr	r1, [pc, #152]	; (5168 <main+0x128>)
    50d0:	4602      	mov	r2, r0
    50d2:	481c      	ldr	r0, [pc, #112]	; (5144 <main+0x104>)
    50d4:	f7ff fa7c 	bl	45d0 <chprintf>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
    50d8:	4a24      	ldr	r2, [pc, #144]	; (516c <main+0x12c>)

  chVTObjectInit(&chg_vt); // initialize the charger keep-alive virtual timer

  
  chEvtObjectInit(&chg_keepalive_event);
  eventThr = chThdCreateStatic(waOrchardEventThread,
    50da:	4b25      	ldr	r3, [pc, #148]	; (5170 <main+0x130>)
    50dc:	6012      	str	r2, [r2, #0]
    50de:	2600      	movs	r6, #0
    50e0:	f44f 6127 	mov.w	r1, #2672	; 0xa70
    50e4:	2204      	movs	r2, #4
    50e6:	9600      	str	r6, [sp, #0]
    50e8:	4822      	ldr	r0, [pc, #136]	; (5174 <main+0x134>)
    50ea:	60fe      	str	r6, [r7, #12]
    50ec:	f7fc fb30 	bl	1750 <chThdCreateStatic>
    50f0:	4b21      	ldr	r3, [pc, #132]	; (5178 <main+0x138>)
    50f2:	6018      	str	r0, [r3, #0]
			       (LOWPRIO + 2),
			       orchard_event_thread,
			       NULL);
  

  ggOn(); // turn on the gas guage, do last to give time for supplies to stabilize
    50f4:	f000 fb8c 	bl	5810 <ggOn>


  i2cObjectInit(&I2CD2);
    50f8:	4820      	ldr	r0, [pc, #128]	; (517c <main+0x13c>)
    50fa:	f7fd fdb1 	bl	2c60 <i2cObjectInit>
  i2cStart(&I2CD2, &i2c2_config);
    50fe:	481f      	ldr	r0, [pc, #124]	; (517c <main+0x13c>)
    5100:	491f      	ldr	r1, [pc, #124]	; (5180 <main+0x140>)
    5102:	f7fd fdb5 	bl	2c70 <i2cStart>
  
  /*
   * Normal main() thread activity, spawning shells.
   */
  while (true) {
    thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
    5106:	f44f 6117 	mov.w	r1, #2416	; 0x970
    510a:	4a1e      	ldr	r2, [pc, #120]	; (5184 <main+0x144>)
    510c:	9500      	str	r5, [sp, #0]
    510e:	2381      	movs	r3, #129	; 0x81
    5110:	9401      	str	r4, [sp, #4]
    5112:	2000      	movs	r0, #0
    5114:	f7fd f8ac 	bl	2270 <chThdCreateFromHeap>
					    "shell", NORMALPRIO + 1,
					    shellThread, (void *)&shell_cfg);
    chThdWait(shelltp);               /* Waiting termination.             */
    5118:	f7fc fc2a 	bl	1970 <chThdWait>
    chThdSleepMilliseconds(1000);
    511c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    5120:	f7fc fc6e 	bl	1a00 <chThdSleep>
  }
    5124:	e7ef      	b.n	5106 <main+0xc6>
    5126:	bf00      	nop
    5128:	4004a000 	.word	0x4004a000
    512c:	4004b000 	.word	0x4004b000
    5130:	400ff040 	.word	0x400ff040
    5134:	00004be1 	.word	0x00004be1
    5138:	000075c0 	.word	0x000075c0
    513c:	400ff080 	.word	0x400ff080
    5140:	00007590 	.word	0x00007590
    5144:	1ffff328 	.word	0x1ffff328
    5148:	1ffff3f8 	.word	0x1ffff3f8
    514c:	20000570 	.word	0x20000570
    5150:	00007500 	.word	0x00007500
    5154:	00007580 	.word	0x00007580
    5158:	1ffff3c8 	.word	0x1ffff3c8
    515c:	00007528 	.word	0x00007528
    5160:	1ffff038 	.word	0x1ffff038
    5164:	00007530 	.word	0x00007530
    5168:	00007554 	.word	0x00007554
    516c:	2000056c 	.word	0x2000056c
    5170:	00004fb1 	.word	0x00004fb1
    5174:	1ffff750 	.word	0x1ffff750
    5178:	20000240 	.word	0x20000240
    517c:	1ffff43c 	.word	0x1ffff43c
    5180:	000074f0 	.word	0x000074f0
    5184:	00007574 	.word	0x00007574
    5188:	f3af 8000 	nop.w
    518c:	f3af 8000 	nop.w

00005190 <HardFault_Handler>:
register void *stack_pointer asm("sp");

void HardFault_Handler(void) {
/*lint -restore*/
  // Hijack the process stack pointer to make backtrace work
  asm("mrs %0, psp" : "=r"(HARDFAULT_PSP) : :);
    5190:	4b03      	ldr	r3, [pc, #12]	; (51a0 <HardFault_Handler+0x10>)
  stack_pointer = HARDFAULT_PSP;
    5192:	f3ef 8209 	mrs	r2, PSP
    5196:	4695      	mov	sp, r2
register void *stack_pointer asm("sp");

void HardFault_Handler(void) {
/*lint -restore*/
  // Hijack the process stack pointer to make backtrace work
  asm("mrs %0, psp" : "=r"(HARDFAULT_PSP) : :);
    5198:	601a      	str	r2, [r3, #0]
  stack_pointer = HARDFAULT_PSP;

  /* Break into the debugger */
  asm("bkpt #0");
    519a:	be00      	bkpt	0x0000

  while(1);
    519c:	e7fe      	b.n	519c <HardFault_Handler+0xc>
    519e:	bf00      	nop
    51a0:	20000244 	.word	0x20000244
    51a4:	f3af 8000 	nop.w
    51a8:	f3af 8000 	nop.w
    51ac:	f3af 8000 	nop.w

000051b0 <MemManage_Handler>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void MemManage_Handler(void) {
/*lint -restore*/

  while (true) {
  }
    51b0:	e7fe      	b.n	51b0 <MemManage_Handler>
    51b2:	bf00      	nop
    51b4:	f3af 8000 	nop.w
    51b8:	f3af 8000 	nop.w
    51bc:	f3af 8000 	nop.w

000051c0 <BusFault_Handler>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void BusFault_Handler(void) {
/*lint -restore*/

  while (true) {
  }
    51c0:	e7fe      	b.n	51c0 <BusFault_Handler>
    51c2:	bf00      	nop
    51c4:	f3af 8000 	nop.w
    51c8:	f3af 8000 	nop.w
    51cc:	f3af 8000 	nop.w

000051d0 <UsageFault_Handler>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void UsageFault_Handler(void) {
/*lint -restore*/

  while (true) {
  }
    51d0:	e7fe      	b.n	51d0 <UsageFault_Handler>
    51d2:	bf00      	nop
    51d4:	f3af 8000 	nop.w
    51d8:	f3af 8000 	nop.w
    51dc:	f3af 8000 	nop.w

000051e0 <__stack_chk_fail>:
}

uintptr_t __stack_chk_guard = 0x12345678;
__attribute__((noreturn))
void __stack_chk_fail(void) {
    51e0:	b508      	push	{r3, lr}
  chSysHalt("Stack check fail");
    51e2:	4802      	ldr	r0, [pc, #8]	; (51ec <__stack_chk_fail+0xc>)
    51e4:	f7fb fecc 	bl	f80 <chSysHalt>
  while(1);
    51e8:	e7fe      	b.n	51e8 <__stack_chk_fail+0x8>
    51ea:	bf00      	nop
    51ec:	000075a0 	.word	0x000075a0

000051f0 <xmodemSendByte>:
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
}

int xmodemSendByte(SerialDriver *chp, uint8_t byte, uint32_t timeout_ms)
{
    51f0:	b530      	push	{r4, r5, lr}
    51f2:	b083      	sub	sp, #12
    51f4:	ac02      	add	r4, sp, #8
  return chnWriteTimeout(chp, &byte, 1, timeout_ms);
    51f6:	6805      	ldr	r5, [r0, #0]
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
}

int xmodemSendByte(SerialDriver *chp, uint8_t byte, uint32_t timeout_ms)
{
    51f8:	f804 1d01 	strb.w	r1, [r4, #-1]!
    51fc:	4613      	mov	r3, r2
  return chnWriteTimeout(chp, &byte, 1, timeout_ms);
    51fe:	4621      	mov	r1, r4
    5200:	2201      	movs	r2, #1
    5202:	69ac      	ldr	r4, [r5, #24]
    5204:	47a0      	blx	r4
}
    5206:	b003      	add	sp, #12
    5208:	bd30      	pop	{r4, r5, pc}
    520a:	bf00      	nop
    520c:	f3af 8000 	nop.w

00005210 <xmodemReadBlock>:

int xmodemReadBlock(SerialDriver *chp, void *data, uint32_t max_data,
                    uint8_t *sequence_id)
{
    5210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    5214:	6802      	ldr	r2, [r0, #0]
  return chnWriteTimeout(chp, &byte, 1, timeout_ms);
}

int xmodemReadBlock(SerialDriver *chp, void *data, uint32_t max_data,
                    uint8_t *sequence_id)
{
    5216:	b082      	sub	sp, #8
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    5218:	69d5      	ldr	r5, [r2, #28]
  return chnWriteTimeout(chp, &byte, 1, timeout_ms);
}

int xmodemReadBlock(SerialDriver *chp, void *data, uint32_t max_data,
                    uint8_t *sequence_id)
{
    521a:	460c      	mov	r4, r1
    521c:	461e      	mov	r6, r3
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    521e:	f10d 0102 	add.w	r1, sp, #2
    5222:	2201      	movs	r2, #1
    5224:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  return chnWriteTimeout(chp, &byte, 1, timeout_ms);
}

int xmodemReadBlock(SerialDriver *chp, void *data, uint32_t max_data,
                    uint8_t *sequence_id)
{
    5228:	4607      	mov	r7, r0
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    522a:	47a8      	blx	r5
  int data_size;
  (void)max_data;

  /* Read block header */
  ret = xmodemReadData(chp, &header, 1, 1000);
  if (ret != 1)
    522c:	2801      	cmp	r0, #1
    522e:	d15e      	bne.n	52ee <xmodemReadBlock+0xde>
    return -1;

  switch(header) {
    5230:	f89d 2002 	ldrb.w	r2, [sp, #2]
    5234:	3a01      	subs	r2, #1
    5236:	2a17      	cmp	r2, #23
    5238:	d859      	bhi.n	52ee <xmodemReadBlock+0xde>
    523a:	e8df f002 	tbb	[pc, r2]
    523e:	1055      	.short	0x1055
    5240:	58580c58 	.word	0x58580c58
    5244:	58585858 	.word	0x58585858
    5248:	58585858 	.word	0x58585858
    524c:	58585858 	.word	0x58585858
    5250:	58585858 	.word	0x58585858
    5254:	0c58      	.short	0x0c58
  case XMODEM_SOH:
    data_size = 128;
    break;

  case YMODEM_EOT:
    return 0;
    5256:	2000      	movs	r0, #0

  if (checksum_calc != checksum_val)
    return -1;

  return data_size;
}
    5258:	b002      	add	sp, #8
    525a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (ret != 1)
    return -1;

  switch(header) {
  case XMODEM_STX:
    data_size = 1024;
    525e:	f44f 6880 	mov.w	r8, #1024	; 0x400
  default:
    return -1;
  }

  // Bytes 2 and 3 of the packet indicate the 8-bit sequence number.
  int8_t block_number[2] = {};
    5262:	a902      	add	r1, sp, #8
    5264:	2300      	movs	r3, #0
    5266:	f821 3d04 	strh.w	r3, [r1, #-4]!
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    526a:	683b      	ldr	r3, [r7, #0]
    526c:	4638      	mov	r0, r7
    526e:	69dd      	ldr	r5, [r3, #28]
    5270:	2202      	movs	r2, #2
    5272:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5276:	47a8      	blx	r5
  }

  // Bytes 2 and 3 of the packet indicate the 8-bit sequence number.
  int8_t block_number[2] = {};
  ret = xmodemReadData(chp, block_number, sizeof(block_number), 1000);
  if (ret != sizeof(block_number))
    5278:	2802      	cmp	r0, #2
    527a:	d138      	bne.n	52ee <xmodemReadBlock+0xde>
    return -1;

  if (sequence_id)
    *sequence_id = block_number[0];
    527c:	f89d 2004 	ldrb.w	r2, [sp, #4]
  int8_t block_number[2] = {};
  ret = xmodemReadData(chp, block_number, sizeof(block_number), 1000);
  if (ret != sizeof(block_number))
    return -1;

  if (sequence_id)
    5280:	b106      	cbz	r6, 5284 <xmodemReadBlock+0x74>
    *sequence_id = block_number[0];
    5282:	7032      	strb	r2, [r6, #0]

  if (block_number[1] != ~block_number[0])
    5284:	b252      	sxtb	r2, r2
    5286:	f99d 3005 	ldrsb.w	r3, [sp, #5]
    528a:	43d2      	mvns	r2, r2
    528c:	4293      	cmp	r3, r2
    528e:	d12e      	bne.n	52ee <xmodemReadBlock+0xde>
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    5290:	683b      	ldr	r3, [r7, #0]
    5292:	4638      	mov	r0, r7
    5294:	69dd      	ldr	r5, [r3, #28]
    5296:	4621      	mov	r1, r4
    5298:	4642      	mov	r2, r8
    529a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    529e:	47a8      	blx	r5
    52a0:	4606      	mov	r6, r0
  if (block_number[1] != ~block_number[0])
    return -1;

  /* Now actually receive the packet */
  ret = xmodemReadData(chp, data, data_size, 500);
  if (ret < 0)
    52a2:	2e00      	cmp	r6, #0
    52a4:	dbd8      	blt.n	5258 <xmodemReadBlock+0x48>
    return ret;

  /* Do a cheesy recalculation of the checksum */
  int i;
  uint8_t checksum_calc = 0;
  uint8_t checksum_val = 0;
    52a6:	f04f 0300 	mov.w	r3, #0
    52aa:	f88d 3003 	strb.w	r3, [sp, #3]

  for (i = 0; i < ret; i++)
    52ae:	d023      	beq.n	52f8 <xmodemReadBlock+0xe8>
    52b0:	4621      	mov	r1, r4
    52b2:	4426      	add	r6, r4
    52b4:	461d      	mov	r5, r3
    checksum_calc += ((uint8_t *)data)[i];
    52b6:	f811 4b01 	ldrb.w	r4, [r1], #1
    52ba:	192b      	adds	r3, r5, r4
  /* Do a cheesy recalculation of the checksum */
  int i;
  uint8_t checksum_calc = 0;
  uint8_t checksum_val = 0;

  for (i = 0; i < ret; i++)
    52bc:	42b1      	cmp	r1, r6
    checksum_calc += ((uint8_t *)data)[i];
    52be:	b2dd      	uxtb	r5, r3
  /* Do a cheesy recalculation of the checksum */
  int i;
  uint8_t checksum_calc = 0;
  uint8_t checksum_val = 0;

  for (i = 0; i < ret; i++)
    52c0:	d1f9      	bne.n	52b6 <xmodemReadBlock+0xa6>
#define XMODEM_C   0x43

int xmodemReadData(SerialDriver *chp, void *data,
                   uint32_t size, uint32_t timeout_ms)
{
  return chnReadTimeout(chp, data, size, MS2ST(timeout_ms));
    52c2:	683b      	ldr	r3, [r7, #0]
    52c4:	4638      	mov	r0, r7
    52c6:	69dc      	ldr	r4, [r3, #28]
    52c8:	f10d 0103 	add.w	r1, sp, #3
    52cc:	2201      	movs	r2, #1
    52ce:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    52d2:	47a0      	blx	r4

  for (i = 0; i < ret; i++)
    checksum_calc += ((uint8_t *)data)[i];

  ret = xmodemReadData(chp, &checksum_val, sizeof(checksum_val), 500);
  if (ret < 0)
    52d4:	2800      	cmp	r0, #0
    52d6:	dbbf      	blt.n	5258 <xmodemReadBlock+0x48>
    return ret;

  if (checksum_calc != checksum_val)
    52d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    52dc:	42ab      	cmp	r3, r5
    52de:	d106      	bne.n	52ee <xmodemReadBlock+0xde>
    return -1;

  return data_size;
    52e0:	4640      	mov	r0, r8
}
    52e2:	b002      	add	sp, #8
    52e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  case XMODEM_STX:
    data_size = 1024;
    break;

  case XMODEM_SOH:
    data_size = 128;
    52e8:	f04f 0880 	mov.w	r8, #128	; 0x80
    52ec:	e7b9      	b.n	5262 <xmodemReadBlock+0x52>
  case YMODEM_CAN:
    return 0;
    break;

  default:
    return -1;
    52ee:	f04f 30ff 	mov.w	r0, #4294967295

  if (checksum_calc != checksum_val)
    return -1;

  return data_size;
}
    52f2:	b002      	add	sp, #8
    52f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (ret < 0)
    return ret;

  /* Do a cheesy recalculation of the checksum */
  int i;
  uint8_t checksum_calc = 0;
    52f8:	4635      	mov	r5, r6
    52fa:	e7e2      	b.n	52c2 <xmodemReadBlock+0xb2>
    52fc:	f3af 8000 	nop.w

00005300 <gfxCommand>:
#define SSD1306_ADDR  0x3C

#define NL SHELL_NEWLINE_STR

void gfxCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5300:	b530      	push	{r4, r5, lr}
  (void)argv;
  uint8_t tx[2], rx[2];
  msg_t retval;
  int i;

  if (argc <= 0) {
    5302:	2900      	cmp	r1, #0
#define SSD1306_ADDR  0x3C

#define NL SHELL_NEWLINE_STR

void gfxCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5304:	b087      	sub	sp, #28
    5306:	4605      	mov	r5, r0
  (void)argv;
  uint8_t tx[2], rx[2];
  msg_t retval;
  int i;

  if (argc <= 0) {
    5308:	dd46      	ble.n	5398 <gfxCommand+0x98>
    chprintf(chp, "    id        SSD1306 ID"SHELL_NEWLINE_STR);
    chprintf(chp, "    reset     Reset display"SHELL_NEWLINE_STR);
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    530a:	6814      	ldr	r4, [r2, #0]
    530c:	4928      	ldr	r1, [pc, #160]	; (53b0 <gfxCommand+0xb0>)
    530e:	4620      	mov	r0, r4
    5310:	f001 f9b6 	bl	6680 <strcasecmp>
    5314:	4603      	mov	r3, r0
    5316:	b1a8      	cbz	r0, 5344 <gfxCommand+0x44>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "Value of 0x81 (should be 0x7F default): %02x"NL, rx[0]);
  }
  
  else if (!strcasecmp(argv[0], "reset")) {
    5318:	4620      	mov	r0, r4
    531a:	4926      	ldr	r1, [pc, #152]	; (53b4 <gfxCommand+0xb4>)
    531c:	f001 f9b0 	bl	6680 <strcasecmp>
    5320:	b130      	cbz	r0, 5330 <gfxCommand+0x30>
    chThdSleepMilliseconds(1);
    palSetPad(IOPORT1, 18);
  }
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
    5322:	4628      	mov	r0, r5
    5324:	4622      	mov	r2, r4
    5326:	4924      	ldr	r1, [pc, #144]	; (53b8 <gfxCommand+0xb8>)
    5328:	f7ff f952 	bl	45d0 <chprintf>
  }
}
    532c:	b007      	add	sp, #28
    532e:	bd30      	pop	{r4, r5, pc}
    }
    chprintf(chp, "Value of 0x81 (should be 0x7F default): %02x"NL, rx[0]);
  }
  
  else if (!strcasecmp(argv[0], "reset")) {
    palClearPad(IOPORT1, 18);
    5330:	4c22      	ldr	r4, [pc, #136]	; (53bc <gfxCommand+0xbc>)
    5332:	f44f 2580 	mov.w	r5, #262144	; 0x40000
    5336:	60a5      	str	r5, [r4, #8]
    chThdSleepMilliseconds(1);
    5338:	2001      	movs	r0, #1
    533a:	f7fc fb61 	bl	1a00 <chThdSleep>
    palSetPad(IOPORT1, 18);
    533e:	6065      	str	r5, [r4, #4]
  }
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
}
    5340:	b007      	add	sp, #28
    5342:	bd30      	pop	{r4, r5, pc}
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    tx[0] = 0;  // command, not continuation
    tx[1] = 0x81; // read contrast control
    5344:	2281      	movs	r2, #129	; 0x81
    i2cAcquireBus(&I2CD2);
    5346:	481e      	ldr	r0, [pc, #120]	; (53c0 <gfxCommand+0xc0>)
    chprintf(chp, "    reset     Reset display"SHELL_NEWLINE_STR);
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    tx[0] = 0;  // command, not continuation
    5348:	f88d 3010 	strb.w	r3, [sp, #16]
    tx[1] = 0x81; // read contrast control
    534c:	f88d 2011 	strb.w	r2, [sp, #17]
    i2cAcquireBus(&I2CD2);
    5350:	f7fd fd3e 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD2, SSD1306_ADDR, tx, 2, rx, 1, TIME_INFINITE);
    5354:	a905      	add	r1, sp, #20
    5356:	2201      	movs	r2, #1
    5358:	f04f 33ff 	mov.w	r3, #4294967295
    535c:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
    5360:	4817      	ldr	r0, [pc, #92]	; (53c0 <gfxCommand+0xc0>)
    5362:	213c      	movs	r1, #60	; 0x3c
    5364:	aa04      	add	r2, sp, #16
    5366:	2302      	movs	r3, #2
    5368:	f7fd fcd2 	bl	2d10 <i2cMasterTransmitTimeout>
    536c:	4604      	mov	r4, r0
    i2cReleaseBus(&I2CD2);
    536e:	4814      	ldr	r0, [pc, #80]	; (53c0 <gfxCommand+0xc0>)
    5370:	f7fd fd46 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5374:	b93c      	cbnz	r4, 5386 <gfxCommand+0x86>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "Value of 0x81 (should be 0x7F default): %02x"NL, rx[0]);
    5376:	4628      	mov	r0, r5
    5378:	4912      	ldr	r1, [pc, #72]	; (53c4 <gfxCommand+0xc4>)
    537a:	f89d 2014 	ldrb.w	r2, [sp, #20]
    537e:	f7ff f927 	bl	45d0 <chprintf>
  }
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
}
    5382:	b007      	add	sp, #28
    5384:	bd30      	pop	{r4, r5, pc}
    tx[1] = 0x81; // read contrast control
    i2cAcquireBus(&I2CD2);
    retval = i2cMasterTransmitTimeout(&I2CD2, SSD1306_ADDR, tx, 2, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD2);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    5386:	4810      	ldr	r0, [pc, #64]	; (53c8 <gfxCommand+0xc8>)
    5388:	f7fd fcb2 	bl	2cf0 <i2cGetErrors>
    538c:	490f      	ldr	r1, [pc, #60]	; (53cc <gfxCommand+0xcc>)
    538e:	4602      	mov	r2, r0
    5390:	4628      	mov	r0, r5
    5392:	f7ff f91d 	bl	45d0 <chprintf>
    5396:	e7ee      	b.n	5376 <gfxCommand+0x76>
  uint8_t tx[2], rx[2];
  msg_t retval;
  int i;

  if (argc <= 0) {
    chprintf(chp, "Usage: gfx [verb]:"SHELL_NEWLINE_STR);
    5398:	490d      	ldr	r1, [pc, #52]	; (53d0 <gfxCommand+0xd0>)
    539a:	f7ff f919 	bl	45d0 <chprintf>
    chprintf(chp, "    id        SSD1306 ID"SHELL_NEWLINE_STR);
    539e:	4628      	mov	r0, r5
    53a0:	490c      	ldr	r1, [pc, #48]	; (53d4 <gfxCommand+0xd4>)
    53a2:	f7ff f915 	bl	45d0 <chprintf>
    chprintf(chp, "    reset     Reset display"SHELL_NEWLINE_STR);
    53a6:	4628      	mov	r0, r5
    53a8:	490b      	ldr	r1, [pc, #44]	; (53d8 <gfxCommand+0xd8>)
    53aa:	f7ff f911 	bl	45d0 <chprintf>
    53ae:	e7bd      	b.n	532c <gfxCommand+0x2c>
    53b0:	000076e4 	.word	0x000076e4
    53b4:	00007738 	.word	0x00007738
    53b8:	00007740 	.word	0x00007740
    53bc:	400ff000 	.word	0x400ff000
    53c0:	1ffff43c 	.word	0x1ffff43c
    53c4:	00007708 	.word	0x00007708
    53c8:	1ffff3f8 	.word	0x1ffff3f8
    53cc:	000076e8 	.word	0x000076e8
    53d0:	00007690 	.word	0x00007690
    53d4:	000076a8 	.word	0x000076a8
    53d8:	000076c4 	.word	0x000076c4
    53dc:	f3af 8000 	nop.w

000053e0 <i2cCommand>:
#define STC3115_ADDR 0x70
#define FAN5421_ADDR 0x6A
#define LC709203_ADDR 0x0B

void i2cCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    53e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    53e2:	b08f      	sub	sp, #60	; 0x3c
  (void)argv;
  uint8_t tx[1], rx[32];
  msg_t retval;
  int i;

  tx[0] = 0;
    53e4:	ad0e      	add	r5, sp, #56	; 0x38
#define STC3115_ADDR 0x70
#define FAN5421_ADDR 0x6A
#define LC709203_ADDR 0x0B

void i2cCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    53e6:	4f1c      	ldr	r7, [pc, #112]	; (5458 <i2cCommand+0x78>)
  (void)argv;
  uint8_t tx[1], rx[32];
  msg_t retval;
  int i;

  tx[0] = 0;
    53e8:	2400      	movs	r4, #0
#define STC3115_ADDR 0x70
#define FAN5421_ADDR 0x6A
#define LC709203_ADDR 0x0B

void i2cCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    53ea:	683b      	ldr	r3, [r7, #0]
  (void)argv;
  uint8_t tx[1], rx[32];
  msg_t retval;
  int i;

  tx[0] = 0;
    53ec:	f805 4d28 	strb.w	r4, [r5, #-40]!
#define STC3115_ADDR 0x70
#define FAN5421_ADDR 0x6A
#define LC709203_ADDR 0x0B

void i2cCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    53f0:	4606      	mov	r6, r0
  uint8_t tx[1], rx[32];
  msg_t retval;
  int i;

  tx[0] = 0;
  i2cAcquireBus(&I2CD1);
    53f2:	481a      	ldr	r0, [pc, #104]	; (545c <i2cCommand+0x7c>)
#define STC3115_ADDR 0x70
#define FAN5421_ADDR 0x6A
#define LC709203_ADDR 0x0B

void i2cCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    53f4:	930d      	str	r3, [sp, #52]	; 0x34
  uint8_t tx[1], rx[32];
  msg_t retval;
  int i;

  tx[0] = 0;
  i2cAcquireBus(&I2CD1);
    53f6:	f7fd fceb 	bl	2dd0 <i2cAcquireBus>
  retval = i2cMasterTransmitTimeout(&I2CD1, CAP1208_ADDR, tx, 1, rx, 32, TIME_INFINITE);
    53fa:	a805      	add	r0, sp, #20
    53fc:	2120      	movs	r1, #32
    53fe:	f04f 33ff 	mov.w	r3, #4294967295
    5402:	e88d 000b 	stmia.w	sp, {r0, r1, r3}
    5406:	462a      	mov	r2, r5
    5408:	2128      	movs	r1, #40	; 0x28
    540a:	2301      	movs	r3, #1
    540c:	4813      	ldr	r0, [pc, #76]	; (545c <i2cCommand+0x7c>)
    540e:	f7fd fc7f 	bl	2d10 <i2cMasterTransmitTimeout>
  i2cReleaseBus(&I2CD1);
    5412:	4812      	ldr	r0, [pc, #72]	; (545c <i2cCommand+0x7c>)
    5414:	f7fd fcf4 	bl	2e00 <i2cReleaseBus>
    5418:	f10d 0513 	add.w	r5, sp, #19
    541c:	e008      	b.n	5430 <i2cCommand+0x50>

  for( i = 0; i < 32; i++ ) {
    541e:	3401      	adds	r4, #1
    if( (i % 8) == 0 )
      chprintf(chp, SHELL_NEWLINE_STR"%02x: ", i );
    
    chprintf(chp, "%02x ", rx[i]);
    5420:	4630      	mov	r0, r6
    5422:	490f      	ldr	r1, [pc, #60]	; (5460 <i2cCommand+0x80>)
    5424:	f815 2f01 	ldrb.w	r2, [r5, #1]!
    5428:	f7ff f8d2 	bl	45d0 <chprintf>
  tx[0] = 0;
  i2cAcquireBus(&I2CD1);
  retval = i2cMasterTransmitTimeout(&I2CD1, CAP1208_ADDR, tx, 1, rx, 32, TIME_INFINITE);
  i2cReleaseBus(&I2CD1);

  for( i = 0; i < 32; i++ ) {
    542c:	2c20      	cmp	r4, #32
    542e:	d007      	beq.n	5440 <i2cCommand+0x60>
    if( (i % 8) == 0 )
    5430:	0763      	lsls	r3, r4, #29
    5432:	d1f4      	bne.n	541e <i2cCommand+0x3e>
      chprintf(chp, SHELL_NEWLINE_STR"%02x: ", i );
    5434:	4630      	mov	r0, r6
    5436:	490b      	ldr	r1, [pc, #44]	; (5464 <i2cCommand+0x84>)
    5438:	4622      	mov	r2, r4
    543a:	f7ff f8c9 	bl	45d0 <chprintf>
    543e:	e7ee      	b.n	541e <i2cCommand+0x3e>
    
    chprintf(chp, "%02x ", rx[i]);
  }
  chprintf(chp, SHELL_NEWLINE_STR );
    5440:	4630      	mov	r0, r6
    5442:	4909      	ldr	r1, [pc, #36]	; (5468 <i2cCommand+0x88>)
    5444:	f7ff f8c4 	bl	45d0 <chprintf>
  return;
}
    5448:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    544a:	683b      	ldr	r3, [r7, #0]
    544c:	429a      	cmp	r2, r3
    544e:	d101      	bne.n	5454 <i2cCommand+0x74>
    5450:	b00f      	add	sp, #60	; 0x3c
    5452:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5454:	f7ff fec4 	bl	51e0 <__stack_chk_fail>
    5458:	1ffff034 	.word	0x1ffff034
    545c:	1ffff3f8 	.word	0x1ffff3f8
    5460:	0000776c 	.word	0x0000776c
    5464:	00007760 	.word	0x00007760
    5468:	000077a0 	.word	0x000077a0
    546c:	f3af 8000 	nop.w

00005470 <capWCommand>:

void capWCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5470:	b530      	push	{r4, r5, lr}
  (void)argc;
  (void)argv;
  uint8_t tx[2], rx[1];
  msg_t retval;

  if( argc != 2 ) {
    5472:	2902      	cmp	r1, #2
  chprintf(chp, SHELL_NEWLINE_STR );
  return;
}

void capWCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5474:	b087      	sub	sp, #28
    5476:	4614      	mov	r4, r2
    5478:	4605      	mov	r5, r0
  (void)argc;
  (void)argv;
  uint8_t tx[2], rx[1];
  msg_t retval;

  if( argc != 2 ) {
    547a:	d002      	beq.n	5482 <capWCommand+0x12>
    chprintf(chp, "Usage: c <addr> <data>"SHELL_NEWLINE_STR);
    547c:	4916      	ldr	r1, [pc, #88]	; (54d8 <capWCommand+0x68>)
    547e:	f7ff f8a7 	bl	45d0 <chprintf>
  }
  tx[0] = (uint8_t) (strtol(argv[0], NULL, 0) & 0xFF);
    5482:	2100      	movs	r1, #0
    5484:	460a      	mov	r2, r1
    5486:	6820      	ldr	r0, [r4, #0]
    5488:	f001 f9d2 	bl	6830 <strtol>
  tx[1] = (uint8_t) (strtol(argv[1], NULL, 0) & 0xFF);
    548c:	2100      	movs	r1, #0
    548e:	460a      	mov	r2, r1
  msg_t retval;

  if( argc != 2 ) {
    chprintf(chp, "Usage: c <addr> <data>"SHELL_NEWLINE_STR);
  }
  tx[0] = (uint8_t) (strtol(argv[0], NULL, 0) & 0xFF);
    5490:	f88d 0014 	strb.w	r0, [sp, #20]
  tx[1] = (uint8_t) (strtol(argv[1], NULL, 0) & 0xFF);
    5494:	6860      	ldr	r0, [r4, #4]
    5496:	f001 f9cb 	bl	6830 <strtol>
    549a:	f88d 0015 	strb.w	r0, [sp, #21]
  

  i2cAcquireBus(&I2CD1);
    549e:	480f      	ldr	r0, [pc, #60]	; (54dc <capWCommand+0x6c>)
    54a0:	f7fd fc96 	bl	2dd0 <i2cAcquireBus>
  retval = i2cMasterTransmitTimeout(&I2CD1, CAP1208_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    54a4:	a904      	add	r1, sp, #16
    54a6:	2200      	movs	r2, #0
    54a8:	f04f 33ff 	mov.w	r3, #4294967295
    54ac:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
    54b0:	480a      	ldr	r0, [pc, #40]	; (54dc <capWCommand+0x6c>)
    54b2:	aa05      	add	r2, sp, #20
    54b4:	2302      	movs	r3, #2
    54b6:	2128      	movs	r1, #40	; 0x28
    54b8:	f7fd fc2a 	bl	2d10 <i2cMasterTransmitTimeout>
    54bc:	4604      	mov	r4, r0
  i2cReleaseBus(&I2CD1);
    54be:	4807      	ldr	r0, [pc, #28]	; (54dc <capWCommand+0x6c>)
    54c0:	f7fd fc9e 	bl	2e00 <i2cReleaseBus>

  chprintf(chp, "retval: %d"SHELL_NEWLINE_STR, retval == MSG_OK ? 1 : 0);
    54c4:	fab4 f284 	clz	r2, r4
    54c8:	4628      	mov	r0, r5
    54ca:	4905      	ldr	r1, [pc, #20]	; (54e0 <capWCommand+0x70>)
    54cc:	0952      	lsrs	r2, r2, #5
    54ce:	f7ff f87f 	bl	45d0 <chprintf>
  return;
}
    54d2:	b007      	add	sp, #28
    54d4:	bd30      	pop	{r4, r5, pc}
    54d6:	bf00      	nop
    54d8:	00007774 	.word	0x00007774
    54dc:	1ffff3f8 	.word	0x1ffff3f8
    54e0:	000077b0 	.word	0x000077b0
    54e4:	f3af 8000 	nop.w
    54e8:	f3af 8000 	nop.w
    54ec:	f3af 8000 	nop.w

000054f0 <capRCommand>:

void capRCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    54f0:	b530      	push	{r4, r5, lr}
  (void)argc;
  (void)argv;
  uint8_t tx[1], rx[1];
  msg_t retval;

  if( argc != 1 ) {
    54f2:	2901      	cmp	r1, #1
  chprintf(chp, "retval: %d"SHELL_NEWLINE_STR, retval == MSG_OK ? 1 : 0);
  return;
}

void capRCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    54f4:	b087      	sub	sp, #28
    54f6:	4614      	mov	r4, r2
    54f8:	4605      	mov	r5, r0
  (void)argc;
  (void)argv;
  uint8_t tx[1], rx[1];
  msg_t retval;

  if( argc != 1 ) {
    54fa:	d002      	beq.n	5502 <capRCommand+0x12>
    chprintf(chp, "Usage: cr <addr>"SHELL_NEWLINE_STR);
    54fc:	4914      	ldr	r1, [pc, #80]	; (5550 <capRCommand+0x60>)
    54fe:	f7ff f867 	bl	45d0 <chprintf>
  }
  tx[0] = (uint8_t) (strtol(argv[0], NULL, 0) & 0xFF);
    5502:	2100      	movs	r1, #0
    5504:	460a      	mov	r2, r1
    5506:	6820      	ldr	r0, [r4, #0]
    5508:	f001 f992 	bl	6830 <strtol>
    550c:	ac06      	add	r4, sp, #24
    550e:	f804 0d08 	strb.w	r0, [r4, #-8]!
  

  i2cAcquireBus(&I2CD1);
    5512:	4810      	ldr	r0, [pc, #64]	; (5554 <capRCommand+0x64>)
    5514:	f7fd fc5c 	bl	2dd0 <i2cAcquireBus>
  retval = i2cMasterTransmitTimeout(&I2CD1, CAP1208_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5518:	2301      	movs	r3, #1
    551a:	a805      	add	r0, sp, #20
    551c:	f04f 31ff 	mov.w	r1, #4294967295
    5520:	e88d 0009 	stmia.w	sp, {r0, r3}
    5524:	4622      	mov	r2, r4
    5526:	9102      	str	r1, [sp, #8]
    5528:	480a      	ldr	r0, [pc, #40]	; (5554 <capRCommand+0x64>)
    552a:	2128      	movs	r1, #40	; 0x28
    552c:	f7fd fbf0 	bl	2d10 <i2cMasterTransmitTimeout>
    5530:	4604      	mov	r4, r0
  i2cReleaseBus(&I2CD1);
    5532:	4808      	ldr	r0, [pc, #32]	; (5554 <capRCommand+0x64>)
    5534:	f7fd fc64 	bl	2e00 <i2cReleaseBus>

  chprintf(chp, "read: %02x, retval: %d"SHELL_NEWLINE_STR, rx[0], retval == MSG_OK ? 1 : 0);
    5538:	fab4 f384 	clz	r3, r4
    553c:	4628      	mov	r0, r5
    553e:	4906      	ldr	r1, [pc, #24]	; (5558 <capRCommand+0x68>)
    5540:	f89d 2014 	ldrb.w	r2, [sp, #20]
    5544:	095b      	lsrs	r3, r3, #5
    5546:	f7ff f843 	bl	45d0 <chprintf>
  return;
}
    554a:	b007      	add	sp, #28
    554c:	bd30      	pop	{r4, r5, pc}
    554e:	bf00      	nop
    5550:	00007790 	.word	0x00007790
    5554:	1ffff3f8 	.word	0x1ffff3f8
    5558:	000077a4 	.word	0x000077a4
    555c:	f3af 8000 	nop.w

00005560 <testCommand>:
void testCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
  (void)argc;
  (void)argv;
  
  chprintf(chp, "test"SHELL_NEWLINE_STR);
    5560:	4901      	ldr	r1, [pc, #4]	; (5568 <testCommand+0x8>)
    5562:	f7ff b835 	b.w	45d0 <chprintf>
    5566:	bf00      	nop
    5568:	000077c0 	.word	0x000077c0
    556c:	f3af 8000 	nop.w

00005570 <spiRuntSetup>:
static uint32_t spi_data_count;

// spi1 interface is "runty" and has only a 4-deep FIFO, so not suitable for DMA
// returns bytes transferred

void spiRuntSetup(SPIDriver *spip) {
    5570:	b510      	push	{r4, lr}
    5572:	4604      	mov	r4, r0
  nvicDisableVector(DMA1_IRQn); // disable IRQs coz we're polling this one
    5574:	2001      	movs	r0, #1
    5576:	f7fd fdd3 	bl	3120 <nvicDisableVector>
  
  spip->spi->MCR = SPIx_MCR_MSTR | SPIx_MCR_CLR_TXF | SPIx_MCR_CLR_RXF;
    557a:	69e3      	ldr	r3, [r4, #28]
    557c:	4a02      	ldr	r2, [pc, #8]	; (5588 <spiRuntSetup+0x18>)
    557e:	601a      	str	r2, [r3, #0]
  spip->spi->CTAR[0] = KINETIS_SPI_TAR_BUSCLK_XZ(8);  // 8-bit frame size
    5580:	f04f 423e 	mov.w	r2, #3187671040	; 0xbe000000
    5584:	60da      	str	r2, [r3, #12]
    5586:	bd10      	pop	{r4, pc}
    5588:	80000c00 	.word	0x80000c00
    558c:	f3af 8000 	nop.w

00005590 <spiRuntSend>:
}

uint32_t spiRuntSend(SPIDriver *spip, uint32_t count, uint8_t *data) {
    5590:	b430      	push	{r4, r5}
    5592:	69c5      	ldr	r5, [r0, #28]
  uint32_t i = 0;
  uint32_t pushr;

  // poll loop to send data
  while( i < count ) {
    5594:	2400      	movs	r4, #0
    5596:	b1a1      	cbz	r1, 55c2 <spiRuntSend+0x32>
    while ( (spip->spi->SR & SPI_SR_TFFF_MASK) && (i < count) ) {
    5598:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    559a:	019b      	lsls	r3, r3, #6
    559c:	d50f      	bpl.n	55be <spiRuntSend+0x2e>
    559e:	428c      	cmp	r4, r1
    55a0:	d20f      	bcs.n	55c2 <spiRuntSend+0x32>
      if( i == 0 ) // mark first with clear transfer count
    55a2:	b9b4      	cbnz	r4, 55d2 <spiRuntSend+0x42>
	pushr = SPI_PUSHR_CONT_MASK | SPI_PUSHR_CTCNT_MASK | data[i];
    55a4:	7813      	ldrb	r3, [r2, #0]
    55a6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
      else
	pushr = SPI_PUSHR_CONT_MASK | data[i];
      
      spip->spi->PUSHR = pushr;
    55aa:	636b      	str	r3, [r5, #52]	; 0x34
    55ac:	69c5      	ldr	r5, [r0, #28]
      i++;
    55ae:	3401      	adds	r4, #1
      
      //      while( !(spip->spi->SR & SPI_SR_TCF_MASK) )
      //	; // wait for transfer to complete, because TFFF lies
      while( (spip->spi->TCR >> 16) != i )
    55b0:	68ab      	ldr	r3, [r5, #8]
    55b2:	ebb4 4f13 	cmp.w	r4, r3, lsr #16
    55b6:	d1fb      	bne.n	55b0 <spiRuntSend+0x20>
  uint32_t i = 0;
  uint32_t pushr;

  // poll loop to send data
  while( i < count ) {
    while ( (spip->spi->SR & SPI_SR_TFFF_MASK) && (i < count) ) {
    55b8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    55ba:	019b      	lsls	r3, r3, #6
    55bc:	d4ef      	bmi.n	559e <spiRuntSend+0xe>
uint32_t spiRuntSend(SPIDriver *spip, uint32_t count, uint8_t *data) {
  uint32_t i = 0;
  uint32_t pushr;

  // poll loop to send data
  while( i < count ) {
    55be:	42a1      	cmp	r1, r4
    55c0:	d8ea      	bhi.n	5598 <spiRuntSend+0x8>
  // note that checking TCF isn't good enough -- the CPU runs fast enough
  // that TCR doesn't update for a few cycles after TCF and you'll get
  // an out of date TCR that's short the last transfer
  // so we just wait until the TCR reflects the actual amount received
  
  while( (spip->spi->TCR >> 16) != count )
    55c2:	68ab      	ldr	r3, [r5, #8]
    55c4:	ebb1 4f13 	cmp.w	r1, r3, lsr #16
    55c8:	d1fb      	bne.n	55c2 <spiRuntSend+0x32>
    ; // wait for transfer to complete
  
  return (spip->spi->TCR >> 16);
    55ca:	68a8      	ldr	r0, [r5, #8]
}
    55cc:	bc30      	pop	{r4, r5}
    55ce:	0c00      	lsrs	r0, r0, #16
    55d0:	4770      	bx	lr
  while( i < count ) {
    while ( (spip->spi->SR & SPI_SR_TFFF_MASK) && (i < count) ) {
      if( i == 0 ) // mark first with clear transfer count
	pushr = SPI_PUSHR_CONT_MASK | SPI_PUSHR_CTCNT_MASK | data[i];
      else
	pushr = SPI_PUSHR_CONT_MASK | data[i];
    55d2:	5d13      	ldrb	r3, [r2, r4]
    55d4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    55d8:	e7e7      	b.n	55aa <spiRuntSend+0x1a>
    55da:	bf00      	nop
    55dc:	f3af 8000 	nop.w

000055e0 <fpgaProgramPage>:
    ; // wait for transfer to complete
  
  return (spip->spi->TCR >> 16);
}

void fpgaProgramPage(SPIDriver *spidev, uint32_t page, uint32_t spi_data_count, uint8_t *spi_data) {
    55e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    55e2:	4d14      	ldr	r5, [pc, #80]	; (5634 <fpgaProgramPage+0x54>)
    55e4:	b085      	sub	sp, #20
    55e6:	4604      	mov	r4, r0
    55e8:	4617      	mov	r7, r2
    55ea:	461e      	mov	r6, r3
    55ec:	682b      	ldr	r3, [r5, #0]
    55ee:	9303      	str	r3, [sp, #12]
  (void) page;
  uint32_t sent;
  uint8_t dummy[8];
  
  spiSelect(spidev);
    55f0:	f7fd fd06 	bl	3000 <spiSelect>
  sent = spiRuntSend(spidev, spi_data_count, spi_data);
    55f4:	4639      	mov	r1, r7
    55f6:	4632      	mov	r2, r6
    55f8:	4620      	mov	r0, r4
    55fa:	f7ff ffc9 	bl	5590 <spiRuntSend>
  chprintf((BaseSequentialStream *)&SD4, "uploaded %d bytes to FPGA"NL, sent);
    55fe:	490e      	ldr	r1, [pc, #56]	; (5638 <fpgaProgramPage+0x58>)
  (void) page;
  uint32_t sent;
  uint8_t dummy[8];
  
  spiSelect(spidev);
  sent = spiRuntSend(spidev, spi_data_count, spi_data);
    5600:	4602      	mov	r2, r0
  chprintf((BaseSequentialStream *)&SD4, "uploaded %d bytes to FPGA"NL, sent);
    5602:	480e      	ldr	r0, [pc, #56]	; (563c <fpgaProgramPage+0x5c>)
    5604:	f7fe ffe4 	bl	45d0 <chprintf>

  sent = spiRuntSend(spidev, 8, dummy);
    5608:	2108      	movs	r1, #8
    560a:	aa01      	add	r2, sp, #4
    560c:	4620      	mov	r0, r4
    560e:	f7ff ffbf 	bl	5590 <spiRuntSend>
  chprintf((BaseSequentialStream *)&SD4, "sent %d dummy bytes to activate IO"NL, sent);
    5612:	490b      	ldr	r1, [pc, #44]	; (5640 <fpgaProgramPage+0x60>)
  
  spiSelect(spidev);
  sent = spiRuntSend(spidev, spi_data_count, spi_data);
  chprintf((BaseSequentialStream *)&SD4, "uploaded %d bytes to FPGA"NL, sent);

  sent = spiRuntSend(spidev, 8, dummy);
    5614:	4602      	mov	r2, r0
  chprintf((BaseSequentialStream *)&SD4, "sent %d dummy bytes to activate IO"NL, sent);
    5616:	4809      	ldr	r0, [pc, #36]	; (563c <fpgaProgramPage+0x5c>)
    5618:	f7fe ffda 	bl	45d0 <chprintf>
  spiUnselect(spidev);
    561c:	4620      	mov	r0, r4
    561e:	f7fd fd27 	bl	3070 <spiUnselect>
}
    5622:	9a03      	ldr	r2, [sp, #12]
    5624:	682b      	ldr	r3, [r5, #0]
    5626:	429a      	cmp	r2, r3
    5628:	d101      	bne.n	562e <fpgaProgramPage+0x4e>
    562a:	b005      	add	sp, #20
    562c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    562e:	f7ff fdd7 	bl	51e0 <__stack_chk_fail>
    5632:	bf00      	nop
    5634:	1ffff034 	.word	0x1ffff034
    5638:	000077d0 	.word	0x000077d0
    563c:	1ffff328 	.word	0x1ffff328
    5640:	000077ec 	.word	0x000077ec
    5644:	f3af 8000 	nop.w
    5648:	f3af 8000 	nop.w
    564c:	f3af 8000 	nop.w

00005650 <uploadCommand>:

void uploadCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int retries = 0;
  int finished = 0;
  int page = 0;
  uint32_t bytes_written = 0;
  
  if (argc <= 0) {
    5654:	2900      	cmp	r1, #0
  chprintf((BaseSequentialStream *)&SD4, "sent %d dummy bytes to activate IO"NL, sent);
  spiUnselect(spidev);
}

void uploadCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5656:	b085      	sub	sp, #20
    5658:	4605      	mov	r5, r0
  int retries = 0;
  int finished = 0;
  int page = 0;
  uint32_t bytes_written = 0;
  
  if (argc <= 0) {
    565a:	dd7b      	ble.n	5754 <uploadCommand+0x104>
    chprintf(chp, "    go        Start upload"SHELL_NEWLINE_STR);
    chprintf(chp, "    test      send a test packet"SHELL_NEWLINE_STR);
    return;
  }

  if (!strcasecmp(argv[0], "go")) {
    565c:	6814      	ldr	r4, [r2, #0]
    565e:	4943      	ldr	r1, [pc, #268]	; (576c <uploadCommand+0x11c>)
    5660:	4620      	mov	r0, r4
    5662:	f001 f80d 	bl	6680 <strcasecmp>
    5666:	4606      	mov	r6, r0
    5668:	b1d0      	cbz	r0, 56a0 <uploadCommand+0x50>
	spi_data_count = 0;
      }
    }
  }

  else if (!strcasecmp(argv[0], "test")) {
    566a:	4620      	mov	r0, r4
    566c:	4940      	ldr	r1, [pc, #256]	; (5770 <uploadCommand+0x120>)
    566e:	f001 f807 	bl	6680 <strcasecmp>
    5672:	4606      	mov	r6, r0
    //    memcpy(spi_data, _binary_fpga_bin_start, 8);
    chprintf(chp, "FPGA config area size %d"NL, fpga_config_size);
    5674:	4628      	mov	r0, r5
	spi_data_count = 0;
      }
    }
  }

  else if (!strcasecmp(argv[0], "test")) {
    5676:	b136      	cbz	r6, 5686 <uploadCommand+0x36>
    chprintf(chp, "FPGA config area size %d"NL, fpga_config_size);
    fpgaProgramPage(SPIDEV, 0, fpga_config_size, (uint8_t *) fpga_config);
  }
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
    5678:	4622      	mov	r2, r4
    567a:	493e      	ldr	r1, [pc, #248]	; (5774 <uploadCommand+0x124>)
    567c:	f7fe ffa8 	bl	45d0 <chprintf>
  }
  
}
    5680:	b005      	add	sp, #20
    5682:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
  }

  else if (!strcasecmp(argv[0], "test")) {
    //    memcpy(spi_data, _binary_fpga_bin_start, 8);
    chprintf(chp, "FPGA config area size %d"NL, fpga_config_size);
    5686:	493c      	ldr	r1, [pc, #240]	; (5778 <uploadCommand+0x128>)
    5688:	4a3c      	ldr	r2, [pc, #240]	; (577c <uploadCommand+0x12c>)
    568a:	f7fe ffa1 	bl	45d0 <chprintf>
    fpgaProgramPage(SPIDEV, 0, fpga_config_size, (uint8_t *) fpga_config);
    568e:	4631      	mov	r1, r6
    5690:	483b      	ldr	r0, [pc, #236]	; (5780 <uploadCommand+0x130>)
    5692:	4a3a      	ldr	r2, [pc, #232]	; (577c <uploadCommand+0x12c>)
    5694:	4b3b      	ldr	r3, [pc, #236]	; (5784 <uploadCommand+0x134>)
    5696:	f7ff ffa3 	bl	55e0 <fpgaProgramPage>
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    569a:	b005      	add	sp, #20
    569c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    chprintf(chp, "    test      send a test packet"SHELL_NEWLINE_STR);
    return;
  }

  if (!strcasecmp(argv[0], "go")) {
    xmodemSendByte(driver, XMODEM_NAK, 200);
    56a0:	4839      	ldr	r0, [pc, #228]	; (5788 <uploadCommand+0x138>)
    56a2:	4d3a      	ldr	r5, [pc, #232]	; (578c <uploadCommand+0x13c>)
    56a4:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 5794 <uploadCommand+0x144>
    56a8:	2115      	movs	r1, #21
    56aa:	22c8      	movs	r2, #200	; 0xc8
    56ac:	f7ff fda0 	bl	51f0 <xmodemSendByte>
{
  (void)argc;
  (void)argv;
  
  uint8_t last_sequence_id = 0;
  int retries = 0;
    56b0:	4637      	mov	r7, r6
void uploadCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
  (void)argc;
  (void)argv;
  
  uint8_t last_sequence_id = 0;
    56b2:	46b0      	mov	r8, r6

    while (!finished) {
      uint8_t sequence_id;
      int ret;

      ret = xmodemReadBlock(driver, spi_data + spi_data_count, sizeof(spi_data), &sequence_id);
    56b4:	46aa      	mov	sl, r5
    56b6:	6829      	ldr	r1, [r5, #0]
    56b8:	4833      	ldr	r0, [pc, #204]	; (5788 <uploadCommand+0x138>)
    56ba:	4449      	add	r1, r9
    56bc:	f44f 7280 	mov.w	r2, #256	; 0x100
    56c0:	f10d 030f 	add.w	r3, sp, #15
    56c4:	f7ff fda4 	bl	5210 <xmodemReadBlock>
      
      if (ret < 0) {
    56c8:	f1b0 0b00 	subs.w	fp, r0, #0
	retries++;
	xmodemSendByte(driver, XMODEM_NAK, 200);
    56cc:	482e      	ldr	r0, [pc, #184]	; (5788 <uploadCommand+0x138>)
      uint8_t sequence_id;
      int ret;

      ret = xmodemReadBlock(driver, spi_data + spi_data_count, sizeof(spi_data), &sequence_id);
      
      if (ret < 0) {
    56ce:	db3b      	blt.n	5748 <uploadCommand+0xf8>
	retries++;
	xmodemSendByte(driver, XMODEM_NAK, 200);
	continue;
      }
      xmodemSendByte(driver, XMODEM_ACK, 200);
    56d0:	2106      	movs	r1, #6
    56d2:	22c8      	movs	r2, #200	; 0xc8
    56d4:	f7ff fd8c 	bl	51f0 <xmodemSendByte>
      
      /* Pad out the final packet with 0xff */
      if (ret == 0) {
    56d8:	f1bb 0f00 	cmp.w	fp, #0
    56dc:	d132      	bne.n	5744 <uploadCommand+0xf4>
	while (spi_data_count <= sizeof(spi_data))
    56de:	f8da 2000 	ldr.w	r2, [sl]
    56e2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    56e6:	d80c      	bhi.n	5702 <uploadCommand+0xb2>
    56e8:	4829      	ldr	r0, [pc, #164]	; (5790 <uploadCommand+0x140>)
    56ea:	3a01      	subs	r2, #1
    56ec:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
    56f0:	441a      	add	r2, r3
	  spi_data[spi_data_count++] = 0xff;
    56f2:	21ff      	movs	r1, #255	; 0xff
    56f4:	f802 1f01 	strb.w	r1, [r2, #1]!
      }
      xmodemSendByte(driver, XMODEM_ACK, 200);
      
      /* Pad out the final packet with 0xff */
      if (ret == 0) {
	while (spi_data_count <= sizeof(spi_data))
    56f8:	4282      	cmp	r2, r0
    56fa:	d1fb      	bne.n	56f4 <uploadCommand+0xa4>
    56fc:	f240 1201 	movw	r2, #257	; 0x101
    5700:	602a      	str	r2, [r5, #0]
	  spi_data[spi_data_count++] = 0xff;
	finished = 1;
    5702:	2401      	movs	r4, #1
      }
      
      if (retries >= 500)
	finished = 1;

      if (sequence_id == last_sequence_id) {
    5704:	f89d c00f 	ldrb.w	ip, [sp, #15]
	  spi_data[spi_data_count++] = 0xff;
	finished = 1;
      }
      
      if (retries >= 500)
	finished = 1;
    5708:	f5b7 7ffa 	cmp.w	r7, #500	; 0x1f4
    570c:	bfa8      	it	ge
    570e:	2401      	movge	r4, #1

      if (sequence_id == last_sequence_id) {
    5710:	45c4      	cmp	ip, r8
    5712:	d005      	beq.n	5720 <uploadCommand+0xd0>
	continue;
      }

      last_sequence_id = sequence_id;
      
      spi_data_count += ret;
    5714:	682a      	ldr	r2, [r5, #0]
    5716:	445a      	add	r2, fp
      if (spi_data_count >= sizeof(spi_data)) {
    5718:	2aff      	cmp	r2, #255	; 0xff
	continue;
      }

      last_sequence_id = sequence_id;
      
      spi_data_count += ret;
    571a:	602a      	str	r2, [r5, #0]
      if (spi_data_count >= sizeof(spi_data)) {
    571c:	d803      	bhi.n	5726 <uploadCommand+0xd6>
    571e:	46e0      	mov	r8, ip
  }

  if (!strcasecmp(argv[0], "go")) {
    xmodemSendByte(driver, XMODEM_NAK, 200);

    while (!finished) {
    5720:	2c00      	cmp	r4, #0
    5722:	d0c8      	beq.n	56b6 <uploadCommand+0x66>
    5724:	e7ac      	b.n	5680 <uploadCommand+0x30>

      last_sequence_id = sequence_id;
      
      spi_data_count += ret;
      if (spi_data_count >= sizeof(spi_data)) {
	fpgaProgramPage(SPIDEV, page++, spi_data_count, spi_data);
    5726:	4b1b      	ldr	r3, [pc, #108]	; (5794 <uploadCommand+0x144>)
    5728:	4815      	ldr	r0, [pc, #84]	; (5780 <uploadCommand+0x130>)
    572a:	f8cd c004 	str.w	ip, [sp, #4]
    572e:	4631      	mov	r1, r6
    5730:	f7ff ff56 	bl	55e0 <fpgaProgramPage>
	//	spinorProgramPage(SPIDEV, page++, spi_data_count, spi_data);
	bytes_written += spi_data_count;
	spi_data_count = 0;
    5734:	f8dd c004 	ldr.w	ip, [sp, #4]
    5738:	2300      	movs	r3, #0

      last_sequence_id = sequence_id;
      
      spi_data_count += ret;
      if (spi_data_count >= sizeof(spi_data)) {
	fpgaProgramPage(SPIDEV, page++, spi_data_count, spi_data);
    573a:	3601      	adds	r6, #1
	//	spinorProgramPage(SPIDEV, page++, spi_data_count, spi_data);
	bytes_written += spi_data_count;
	spi_data_count = 0;
    573c:	f8ca 3000 	str.w	r3, [sl]
    5740:	46e0      	mov	r8, ip
    5742:	e7ed      	b.n	5720 <uploadCommand+0xd0>
    5744:	2400      	movs	r4, #0
    5746:	e7dd      	b.n	5704 <uploadCommand+0xb4>

      ret = xmodemReadBlock(driver, spi_data + spi_data_count, sizeof(spi_data), &sequence_id);
      
      if (ret < 0) {
	retries++;
	xmodemSendByte(driver, XMODEM_NAK, 200);
    5748:	2115      	movs	r1, #21
    574a:	22c8      	movs	r2, #200	; 0xc8
      int ret;

      ret = xmodemReadBlock(driver, spi_data + spi_data_count, sizeof(spi_data), &sequence_id);
      
      if (ret < 0) {
	retries++;
    574c:	3701      	adds	r7, #1
	xmodemSendByte(driver, XMODEM_NAK, 200);
    574e:	f7ff fd4f 	bl	51f0 <xmodemSendByte>
	continue;
    5752:	e7b0      	b.n	56b6 <uploadCommand+0x66>
  int finished = 0;
  int page = 0;
  uint32_t bytes_written = 0;
  
  if (argc <= 0) {
    chprintf(chp, "Usage: upload [verb]:"SHELL_NEWLINE_STR);
    5754:	4910      	ldr	r1, [pc, #64]	; (5798 <uploadCommand+0x148>)
    5756:	f7fe ff3b 	bl	45d0 <chprintf>
    chprintf(chp, "    go        Start upload"SHELL_NEWLINE_STR);
    575a:	4628      	mov	r0, r5
    575c:	490f      	ldr	r1, [pc, #60]	; (579c <uploadCommand+0x14c>)
    575e:	f7fe ff37 	bl	45d0 <chprintf>
    chprintf(chp, "    test      send a test packet"SHELL_NEWLINE_STR);
    5762:	4628      	mov	r0, r5
    5764:	490e      	ldr	r1, [pc, #56]	; (57a0 <uploadCommand+0x150>)
    5766:	f7fe ff33 	bl	45d0 <chprintf>
    return;
    576a:	e789      	b.n	5680 <uploadCommand+0x30>
    576c:	00007870 	.word	0x00007870
    5770:	00007630 	.word	0x00007630
    5774:	00007740 	.word	0x00007740
    5778:	00007874 	.word	0x00007874
    577c:	00007ddc 	.word	0x00007ddc
    5780:	1ffff3c8 	.word	0x1ffff3c8
    5784:	00008040 	.word	0x00008040
    5788:	1ffff328 	.word	0x1ffff328
    578c:	20000468 	.word	0x20000468
    5790:	2000056c 	.word	0x2000056c
    5794:	2000046c 	.word	0x2000046c
    5798:	00007814 	.word	0x00007814
    579c:	0000782c 	.word	0x0000782c
    57a0:	0000784c 	.word	0x0000784c
    57a4:	f3af 8000 	nop.w
    57a8:	f3af 8000 	nop.w
    57ac:	f3af 8000 	nop.w

000057b0 <comp_crc8.constprop.0>:
  }
  
  return data;
}

static void comp_crc8(uint8_t *tx) {
    57b0:	b410      	push	{r4}
    57b2:	b083      	sub	sp, #12
  int i;
  uint8_t data[5]; // need to include the I2C address

  // pre-pend the I2C address to the tx buffer in a local copy
  data[0] = 0x16; // they use the left-shifted version for computations
    57b4:	2316      	movs	r3, #22
  // note for reads this changes to 0x17
  for( i = 1; i < 4; i++ ) {
    data[i] = tx[i-1];
    57b6:	7804      	ldrb	r4, [r0, #0]
    57b8:	7841      	ldrb	r1, [r0, #1]
    57ba:	7882      	ldrb	r2, [r0, #2]
    57bc:	f88d 4001 	strb.w	r4, [sp, #1]
    57c0:	f88d 1002 	strb.w	r1, [sp, #2]
    57c4:	f88d 2003 	strb.w	r2, [sp, #3]
static void comp_crc8(uint8_t *tx) {
  int i;
  uint8_t data[5]; // need to include the I2C address

  // pre-pend the I2C address to the tx buffer in a local copy
  data[0] = 0x16; // they use the left-shifted version for computations
    57c8:	f88d 3000 	strb.w	r3, [sp]
  // note for reads this changes to 0x17
  for( i = 1; i < 4; i++ ) {
    data[i] = tx[i-1];
    57cc:	461a      	mov	r2, r3
    57ce:	4669      	mov	r1, sp
    57d0:	f10d 0403 	add.w	r4, sp, #3
    57d4:	2300      	movs	r3, #0

static uint8_t crc_update(uint8_t incrc, uint8_t indata) {
  uint8_t i;
  uint8_t data;

  data = incrc ^ indata;
    57d6:	4053      	eors	r3, r2
    57d8:	b2db      	uxtb	r3, r3
    57da:	2208      	movs	r2, #8
  for( i = 0; i < 8; i++ ) {
    if(( data & 0x80) != 0) {
    57dc:	f013 0f80 	tst.w	r3, #128	; 0x80
      data <<= 1;
    57e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    57e4:	b2db      	uxtb	r3, r3
    57e6:	f102 32ff 	add.w	r2, r2, #4294967295
      data ^= 0x07;
    57ea:	bf18      	it	ne
    57ec:	f083 0307 	eorne.w	r3, r3, #7
static uint8_t crc_update(uint8_t incrc, uint8_t indata) {
  uint8_t i;
  uint8_t data;

  data = incrc ^ indata;
  for( i = 0; i < 8; i++ ) {
    57f0:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    57f4:	d1f2      	bne.n	57dc <comp_crc8.constprop.0+0x2c>
  for( i = 1; i < 4; i++ ) {
    data[i] = tx[i-1];
  }
  
  data[4] = 0x00;
  for( i = 0; i < 4; i++ ) {
    57f6:	42a1      	cmp	r1, r4
    data[4] = crc_update(data[4], data[i]);
    57f8:	f88d 3004 	strb.w	r3, [sp, #4]
  for( i = 1; i < 4; i++ ) {
    data[i] = tx[i-1];
  }
  
  data[4] = 0x00;
  for( i = 0; i < 4; i++ ) {
    57fc:	d002      	beq.n	5804 <comp_crc8.constprop.0+0x54>
    57fe:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    5802:	e7e8      	b.n	57d6 <comp_crc8.constprop.0+0x26>
    data[4] = crc_update(data[4], data[i]);
  }
  
  tx[3] = data[4];
    5804:	70c3      	strb	r3, [r0, #3]
}
    5806:	b003      	add	sp, #12
    5808:	f85d 4b04 	ldr.w	r4, [sp], #4
    580c:	4770      	bx	lr
    580e:	bf00      	nop

00005810 <ggOn>:

void ggOn(void) {
    5810:	b530      	push	{r4, r5, lr}
  uint8_t tx[4];
  
  tx[0] = 0x15; // power mode
  i2cAcquireBus(&I2CD1);
    5812:	4c10      	ldr	r4, [pc, #64]	; (5854 <ggOn+0x44>)
  }
  
  tx[3] = data[4];
}

void ggOn(void) {
    5814:	b087      	sub	sp, #28
  uint8_t tx[4];
  
  tx[0] = 0x15; // power mode
    5816:	2315      	movs	r3, #21
  i2cAcquireBus(&I2CD1);
    5818:	4620      	mov	r0, r4
  tx[1] = 0x1;
  tx[2] = 0x0;
    581a:	2500      	movs	r5, #0
}

void ggOn(void) {
  uint8_t tx[4];
  
  tx[0] = 0x15; // power mode
    581c:	f88d 3014 	strb.w	r3, [sp, #20]
  i2cAcquireBus(&I2CD1);
    5820:	f7fd fad6 	bl	2dd0 <i2cAcquireBus>
  tx[1] = 0x1;
  tx[2] = 0x0;
  comp_crc8(tx);
    5824:	a805      	add	r0, sp, #20
void ggOn(void) {
  uint8_t tx[4];
  
  tx[0] = 0x15; // power mode
  i2cAcquireBus(&I2CD1);
  tx[1] = 0x1;
    5826:	2301      	movs	r3, #1
    5828:	f88d 3015 	strb.w	r3, [sp, #21]
  tx[2] = 0x0;
    582c:	f88d 5016 	strb.w	r5, [sp, #22]
  comp_crc8(tx);
    5830:	f7ff ffbe 	bl	57b0 <comp_crc8.constprop.0>
  i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 4, NULL, 0, TIME_INFINITE);
    5834:	f04f 33ff 	mov.w	r3, #4294967295
    5838:	aa05      	add	r2, sp, #20
    583a:	9302      	str	r3, [sp, #8]
    583c:	210b      	movs	r1, #11
    583e:	2304      	movs	r3, #4
    5840:	9500      	str	r5, [sp, #0]
    5842:	9501      	str	r5, [sp, #4]
    5844:	4620      	mov	r0, r4
    5846:	f7fd fa63 	bl	2d10 <i2cMasterTransmitTimeout>
  i2cReleaseBus(&I2CD1);
    584a:	4620      	mov	r0, r4
    584c:	f7fd fad8 	bl	2e00 <i2cReleaseBus>
}
    5850:	b007      	add	sp, #28
    5852:	bd30      	pop	{r4, r5, pc}
    5854:	1ffff3f8 	.word	0x1ffff3f8
    5858:	f3af 8000 	nop.w
    585c:	f3af 8000 	nop.w

00005860 <ggCommand>:

void ggCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5860:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  (void)argc;
  (void)argv;
  uint8_t tx[4], rx[3];
  msg_t retval;
  
  if (argc <= 0) {
    5864:	2900      	cmp	r1, #0
  i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 4, NULL, 0, TIME_INFINITE);
  i2cReleaseBus(&I2CD1);
}

void ggCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5866:	b086      	sub	sp, #24
    5868:	4606      	mov	r6, r0
  (void)argc;
  (void)argv;
  uint8_t tx[4], rx[3];
  msg_t retval;
  
  if (argc <= 0) {
    586a:	f340 8120 	ble.w	5aae <ggCommand+0x24e>
    chprintf(chp, "    on        Set gg on"NL);
    chprintf(chp, "    stby      Set gg standby"NL);
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    586e:	6815      	ldr	r5, [r2, #0]
    5870:	49a7      	ldr	r1, [pc, #668]	; (5b10 <ggCommand+0x2b0>)
    5872:	4628      	mov	r0, r5
    5874:	f000 ff04 	bl	6680 <strcasecmp>
    5878:	2800      	cmp	r0, #0
    587a:	d046      	beq.n	590a <ggCommand+0xaa>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "ID code: %04x"NL, rx[0] | (rx[1] << 8));
  }

  else if (!strcasecmp(argv[0], "soc")) {
    587c:	4628      	mov	r0, r5
    587e:	49a5      	ldr	r1, [pc, #660]	; (5b14 <ggCommand+0x2b4>)
    5880:	f000 fefe 	bl	6680 <strcasecmp>
    5884:	2800      	cmp	r0, #0
    5886:	f000 80a6 	beq.w	59d6 <ggCommand+0x176>
    }
    chprintf(chp, "Voltage: %dmV"NL, (rx[0] | (rx[1] << 8)));
    
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    588a:	4628      	mov	r0, r5
    588c:	49a2      	ldr	r1, [pc, #648]	; (5b18 <ggCommand+0x2b8>)
    588e:	f000 fef7 	bl	6680 <strcasecmp>
    5892:	2800      	cmp	r0, #0
    5894:	d160      	bne.n	5958 <ggCommand+0xf8>
    5896:	4604      	mov	r4, r0
    5898:	af05      	add	r7, sp, #20
    589a:	f10d 0810 	add.w	r8, sp, #16
    589e:	e023      	b.n	58e8 <ggCommand+0x88>
    int i;
    for( i = 0; i <= 0x1A; i++ ) {
      if( i % 4 == 0 )
	chprintf(chp, NL"%02x: ", i);
      tx[0] = i;
      i2cAcquireBus(&I2CD1);
    58a0:	489e      	ldr	r0, [pc, #632]	; (5b1c <ggCommand+0x2bc>)
  else if (!strcasecmp(argv[0], "dump")) {
    int i;
    for( i = 0; i <= 0x1A; i++ ) {
      if( i % 4 == 0 )
	chprintf(chp, NL"%02x: ", i);
      tx[0] = i;
    58a2:	f88d 4014 	strb.w	r4, [sp, #20]
      i2cAcquireBus(&I2CD1);
    58a6:	f7fd fa93 	bl	2dd0 <i2cAcquireBus>
      retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    58aa:	2203      	movs	r2, #3
    58ac:	f04f 33ff 	mov.w	r3, #4294967295
    58b0:	9201      	str	r2, [sp, #4]
    58b2:	9302      	str	r3, [sp, #8]
    58b4:	f8cd 8000 	str.w	r8, [sp]
    58b8:	2301      	movs	r3, #1
    58ba:	4898      	ldr	r0, [pc, #608]	; (5b1c <ggCommand+0x2bc>)
    58bc:	210b      	movs	r1, #11
    58be:	463a      	mov	r2, r7
    
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    int i;
    for( i = 0; i <= 0x1A; i++ ) {
    58c0:	441c      	add	r4, r3
      if( i % 4 == 0 )
	chprintf(chp, NL"%02x: ", i);
      tx[0] = i;
      i2cAcquireBus(&I2CD1);
      retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    58c2:	f7fd fa25 	bl	2d10 <i2cMasterTransmitTimeout>
    58c6:	4605      	mov	r5, r0
      i2cReleaseBus(&I2CD1);
    58c8:	4894      	ldr	r0, [pc, #592]	; (5b1c <ggCommand+0x2bc>)
    58ca:	f7fd fa99 	bl	2e00 <i2cReleaseBus>
      if( retval != MSG_OK ) {
    58ce:	b99d      	cbnz	r5, 58f8 <ggCommand+0x98>
	chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
      }
      chprintf(chp, "%04x ", rx[0] | (rx[1] << 8) );
    58d0:	f89d 5011 	ldrb.w	r5, [sp, #17]
    58d4:	f89d 2010 	ldrb.w	r2, [sp, #16]
    58d8:	4991      	ldr	r1, [pc, #580]	; (5b20 <ggCommand+0x2c0>)
    58da:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
    58de:	4630      	mov	r0, r6
    58e0:	f7fe fe76 	bl	45d0 <chprintf>
    
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    int i;
    for( i = 0; i <= 0x1A; i++ ) {
    58e4:	2c1b      	cmp	r4, #27
    58e6:	d06f      	beq.n	59c8 <ggCommand+0x168>
      if( i % 4 == 0 )
    58e8:	07a3      	lsls	r3, r4, #30
    58ea:	d1d9      	bne.n	58a0 <ggCommand+0x40>
	chprintf(chp, NL"%02x: ", i);
    58ec:	4630      	mov	r0, r6
    58ee:	498d      	ldr	r1, [pc, #564]	; (5b24 <ggCommand+0x2c4>)
    58f0:	4622      	mov	r2, r4
    58f2:	f7fe fe6d 	bl	45d0 <chprintf>
    58f6:	e7d3      	b.n	58a0 <ggCommand+0x40>
      tx[0] = i;
      i2cAcquireBus(&I2CD1);
      retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
      i2cReleaseBus(&I2CD1);
      if( retval != MSG_OK ) {
	chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    58f8:	4888      	ldr	r0, [pc, #544]	; (5b1c <ggCommand+0x2bc>)
    58fa:	f7fd f9f9 	bl	2cf0 <i2cGetErrors>
    58fe:	498a      	ldr	r1, [pc, #552]	; (5b28 <ggCommand+0x2c8>)
    5900:	4602      	mov	r2, r0
    5902:	4630      	mov	r0, r6
    5904:	f7fe fe64 	bl	45d0 <chprintf>
    5908:	e7e2      	b.n	58d0 <ggCommand+0x70>
    chprintf(chp, "    stby      Set gg standby"NL);
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    tx[0] = 0x11; // ic version
    590a:	ac06      	add	r4, sp, #24
    590c:	2311      	movs	r3, #17
    590e:	f804 3d04 	strb.w	r3, [r4, #-4]!
    i2cAcquireBus(&I2CD1);
    5912:	4882      	ldr	r0, [pc, #520]	; (5b1c <ggCommand+0x2bc>)
    5914:	f7fd fa5c 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    5918:	a804      	add	r0, sp, #16
    591a:	2103      	movs	r1, #3
    591c:	f04f 33ff 	mov.w	r3, #4294967295
    5920:	e88d 000b 	stmia.w	sp, {r0, r1, r3}
    5924:	4622      	mov	r2, r4
    5926:	487d      	ldr	r0, [pc, #500]	; (5b1c <ggCommand+0x2bc>)
    5928:	210b      	movs	r1, #11
    592a:	2301      	movs	r3, #1
    592c:	f7fd f9f0 	bl	2d10 <i2cMasterTransmitTimeout>
    5930:	4604      	mov	r4, r0
    i2cReleaseBus(&I2CD1);
    5932:	487a      	ldr	r0, [pc, #488]	; (5b1c <ggCommand+0x2bc>)
    5934:	f7fd fa64 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5938:	2c00      	cmp	r4, #0
    593a:	f040 80a6 	bne.w	5a8a <ggCommand+0x22a>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "ID code: %04x"NL, rx[0] | (rx[1] << 8));
    593e:	f89d 2011 	ldrb.w	r2, [sp, #17]
    5942:	f89d 3010 	ldrb.w	r3, [sp, #16]
    5946:	4979      	ldr	r1, [pc, #484]	; (5b2c <ggCommand+0x2cc>)
    5948:	4630      	mov	r0, r6
    594a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
    594e:	f7fe fe3f 	bl	45d0 <chprintf>
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    5952:	b006      	add	sp, #24
    5954:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      chprintf(chp, "%04x ", rx[0] | (rx[1] << 8) );
    }
    chprintf(chp, NL);
  }
  
  else if (!strcasecmp(argv[0], "on")) {
    5958:	4628      	mov	r0, r5
    595a:	4975      	ldr	r1, [pc, #468]	; (5b30 <ggCommand+0x2d0>)
    595c:	f000 fe90 	bl	6680 <strcasecmp>
    5960:	4604      	mov	r4, r0
    5962:	2800      	cmp	r0, #0
    5964:	f000 809a 	beq.w	5a9c <ggCommand+0x23c>
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
  }
  
  else if (!strcasecmp(argv[0], "stby")) {
    5968:	4628      	mov	r0, r5
    596a:	4972      	ldr	r1, [pc, #456]	; (5b34 <ggCommand+0x2d4>)
    596c:	f000 fe88 	bl	6680 <strcasecmp>
    5970:	4604      	mov	r4, r0
    5972:	2800      	cmp	r0, #0
    5974:	f040 80b3 	bne.w	5ade <ggCommand+0x27e>
    tx[0] = 0x15; // power mode
    5978:	2315      	movs	r3, #21
    i2cAcquireBus(&I2CD1);
    597a:	4868      	ldr	r0, [pc, #416]	; (5b1c <ggCommand+0x2bc>)
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
  }
  
  else if (!strcasecmp(argv[0], "stby")) {
    tx[0] = 0x15; // power mode
    597c:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    5980:	f7fd fa26 	bl	2dd0 <i2cAcquireBus>
    tx[1] = 0x2;
    tx[2] = 0x0;
    comp_crc8(tx);
    5984:	a805      	add	r0, sp, #20
  }
  
  else if (!strcasecmp(argv[0], "stby")) {
    tx[0] = 0x15; // power mode
    i2cAcquireBus(&I2CD1);
    tx[1] = 0x2;
    5986:	2302      	movs	r3, #2
    tx[2] = 0x0;
    5988:	f88d 4016 	strb.w	r4, [sp, #22]
  }
  
  else if (!strcasecmp(argv[0], "stby")) {
    tx[0] = 0x15; // power mode
    i2cAcquireBus(&I2CD1);
    tx[1] = 0x2;
    598c:	f88d 3015 	strb.w	r3, [sp, #21]
    tx[2] = 0x0;
    comp_crc8(tx);
    5990:	f7ff ff0e 	bl	57b0 <comp_crc8.constprop.0>
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 4, NULL, 0, TIME_INFINITE);
    5994:	f04f 33ff 	mov.w	r3, #4294967295
    5998:	9400      	str	r4, [sp, #0]
    599a:	9401      	str	r4, [sp, #4]
    599c:	9302      	str	r3, [sp, #8]
    599e:	aa05      	add	r2, sp, #20
    59a0:	485e      	ldr	r0, [pc, #376]	; (5b1c <ggCommand+0x2bc>)
    59a2:	210b      	movs	r1, #11
    59a4:	2304      	movs	r3, #4
    59a6:	f7fd f9b3 	bl	2d10 <i2cMasterTransmitTimeout>
    59aa:	4604      	mov	r4, r0
    i2cReleaseBus(&I2CD1);
    59ac:	485b      	ldr	r0, [pc, #364]	; (5b1c <ggCommand+0x2bc>)
    59ae:	f7fd fa27 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    59b2:	2c00      	cmp	r4, #0
    59b4:	d0cd      	beq.n	5952 <ggCommand+0xf2>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    59b6:	4859      	ldr	r0, [pc, #356]	; (5b1c <ggCommand+0x2bc>)
    59b8:	f7fd f99a 	bl	2cf0 <i2cGetErrors>
    59bc:	495a      	ldr	r1, [pc, #360]	; (5b28 <ggCommand+0x2c8>)
    59be:	4602      	mov	r2, r0
    59c0:	4630      	mov	r0, r6
    59c2:	f7fe fe05 	bl	45d0 <chprintf>
    59c6:	e7c4      	b.n	5952 <ggCommand+0xf2>
      if( retval != MSG_OK ) {
	chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
      }
      chprintf(chp, "%04x ", rx[0] | (rx[1] << 8) );
    }
    chprintf(chp, NL);
    59c8:	4630      	mov	r0, r6
    59ca:	495b      	ldr	r1, [pc, #364]	; (5b38 <ggCommand+0x2d8>)
    59cc:	f7fe fe00 	bl	45d0 <chprintf>
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    59d0:	b006      	add	sp, #24
    59d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    chprintf(chp, "ID code: %04x"NL, rx[0] | (rx[1] << 8));
  }

  else if (!strcasecmp(argv[0], "soc")) {
    tx[0] = 0x0f; // ITE register
    59d6:	af06      	add	r7, sp, #24
    59d8:	230f      	movs	r3, #15
    59da:	f807 3d04 	strb.w	r3, [r7, #-4]!
    i2cAcquireBus(&I2CD1);
    59de:	484f      	ldr	r0, [pc, #316]	; (5b1c <ggCommand+0x2bc>)
    59e0:	f7fd f9f6 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    59e4:	f10d 0810 	add.w	r8, sp, #16
    59e8:	2103      	movs	r1, #3
    59ea:	f04f 33ff 	mov.w	r3, #4294967295
    59ee:	9101      	str	r1, [sp, #4]
    59f0:	9302      	str	r3, [sp, #8]
    59f2:	463a      	mov	r2, r7
    59f4:	f8cd 8000 	str.w	r8, [sp]
    59f8:	4848      	ldr	r0, [pc, #288]	; (5b1c <ggCommand+0x2bc>)
    59fa:	210b      	movs	r1, #11
    59fc:	2301      	movs	r3, #1
    59fe:	f7fd f987 	bl	2d10 <i2cMasterTransmitTimeout>
    5a02:	4604      	mov	r4, r0
    i2cReleaseBus(&I2CD1);
    5a04:	4845      	ldr	r0, [pc, #276]	; (5b1c <ggCommand+0x2bc>)
    5a06:	f7fd f9fb 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5a0a:	2c00      	cmp	r4, #0
    5a0c:	d176      	bne.n	5afc <ggCommand+0x29c>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "State of charge: %.1f%%"NL, (rx[0] | (rx[1] << 8)) / 10.0);
    5a0e:	f89d 2011 	ldrb.w	r2, [sp, #17]
    5a12:	f89d 3010 	ldrb.w	r3, [sp, #16]
    5a16:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5a1a:	ee07 3a90 	vmov	s15, r3
    5a1e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    5a22:	eeb2 7a04 	vmov.f32	s14, #36	; 0x24
    5a26:	eec7 7a87 	vdiv.f32	s15, s15, s14
    5a2a:	ee17 0a90 	vmov	r0, s15
    5a2e:	f7fa ff0b 	bl	848 <__aeabi_f2d>
    5a32:	4602      	mov	r2, r0
    5a34:	460b      	mov	r3, r1
    5a36:	4630      	mov	r0, r6
    5a38:	4940      	ldr	r1, [pc, #256]	; (5b3c <ggCommand+0x2dc>)
    5a3a:	f7fe fdc9 	bl	45d0 <chprintf>

    tx[0] = 0x09; // voltage register
    5a3e:	2309      	movs	r3, #9
    i2cAcquireBus(&I2CD1);
    5a40:	4836      	ldr	r0, [pc, #216]	; (5b1c <ggCommand+0x2bc>)
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "State of charge: %.1f%%"NL, (rx[0] | (rx[1] << 8)) / 10.0);

    tx[0] = 0x09; // voltage register
    5a42:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    5a46:	f7fd f9c3 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    5a4a:	2103      	movs	r1, #3
    5a4c:	f04f 33ff 	mov.w	r3, #4294967295
    5a50:	9101      	str	r1, [sp, #4]
    5a52:	9302      	str	r3, [sp, #8]
    5a54:	f8cd 8000 	str.w	r8, [sp]
    5a58:	463a      	mov	r2, r7
    5a5a:	4830      	ldr	r0, [pc, #192]	; (5b1c <ggCommand+0x2bc>)
    5a5c:	210b      	movs	r1, #11
    5a5e:	2301      	movs	r3, #1
    5a60:	f7fd f956 	bl	2d10 <i2cMasterTransmitTimeout>
    5a64:	4604      	mov	r4, r0
    i2cReleaseBus(&I2CD1);
    5a66:	482d      	ldr	r0, [pc, #180]	; (5b1c <ggCommand+0x2bc>)
    5a68:	f7fd f9ca 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5a6c:	2c00      	cmp	r4, #0
    5a6e:	d13c      	bne.n	5aea <ggCommand+0x28a>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "Voltage: %dmV"NL, (rx[0] | (rx[1] << 8)));
    5a70:	f89d 2011 	ldrb.w	r2, [sp, #17]
    5a74:	f89d 3010 	ldrb.w	r3, [sp, #16]
    5a78:	4931      	ldr	r1, [pc, #196]	; (5b40 <ggCommand+0x2e0>)
    5a7a:	4630      	mov	r0, r6
    5a7c:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
    5a80:	f7fe fda6 	bl	45d0 <chprintf>
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    5a84:	b006      	add	sp, #24
    5a86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tx[0] = 0x11; // ic version
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    5a8a:	4824      	ldr	r0, [pc, #144]	; (5b1c <ggCommand+0x2bc>)
    5a8c:	f7fd f930 	bl	2cf0 <i2cGetErrors>
    5a90:	4925      	ldr	r1, [pc, #148]	; (5b28 <ggCommand+0x2c8>)
    5a92:	4602      	mov	r2, r0
    5a94:	4630      	mov	r0, r6
    5a96:	f7fe fd9b 	bl	45d0 <chprintf>
    5a9a:	e750      	b.n	593e <ggCommand+0xde>
    }
    chprintf(chp, NL);
  }
  
  else if (!strcasecmp(argv[0], "on")) {
    tx[0] = 0x15; // power mode
    5a9c:	2315      	movs	r3, #21
    i2cAcquireBus(&I2CD1);
    5a9e:	481f      	ldr	r0, [pc, #124]	; (5b1c <ggCommand+0x2bc>)
    }
    chprintf(chp, NL);
  }
  
  else if (!strcasecmp(argv[0], "on")) {
    tx[0] = 0x15; // power mode
    5aa0:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    5aa4:	f7fd f994 	bl	2dd0 <i2cAcquireBus>
    tx[1] = 0x1;
    tx[2] = 0x0;
    comp_crc8(tx);
    5aa8:	a805      	add	r0, sp, #20
  }
  
  else if (!strcasecmp(argv[0], "on")) {
    tx[0] = 0x15; // power mode
    i2cAcquireBus(&I2CD1);
    tx[1] = 0x1;
    5aaa:	2301      	movs	r3, #1
    5aac:	e76c      	b.n	5988 <ggCommand+0x128>
  (void)argv;
  uint8_t tx[4], rx[3];
  msg_t retval;
  
  if (argc <= 0) {
    chprintf(chp, "Usage: chg [verb]:"SHELL_NEWLINE_STR);
    5aae:	4925      	ldr	r1, [pc, #148]	; (5b44 <ggCommand+0x2e4>)
    5ab0:	f7fe fd8e 	bl	45d0 <chprintf>
    chprintf(chp, "    id        Charger chip ID"SHELL_NEWLINE_STR);
    5ab4:	4630      	mov	r0, r6
    5ab6:	4924      	ldr	r1, [pc, #144]	; (5b48 <ggCommand+0x2e8>)
    5ab8:	f7fe fd8a 	bl	45d0 <chprintf>
    chprintf(chp, "    soc       State of Charge"NL);
    5abc:	4630      	mov	r0, r6
    5abe:	4923      	ldr	r1, [pc, #140]	; (5b4c <ggCommand+0x2ec>)
    5ac0:	f7fe fd86 	bl	45d0 <chprintf>
    chprintf(chp, "    dump      Dump gg regs"NL);
    5ac4:	4630      	mov	r0, r6
    5ac6:	4922      	ldr	r1, [pc, #136]	; (5b50 <ggCommand+0x2f0>)
    5ac8:	f7fe fd82 	bl	45d0 <chprintf>
    chprintf(chp, "    on        Set gg on"NL);
    5acc:	4630      	mov	r0, r6
    5ace:	4921      	ldr	r1, [pc, #132]	; (5b54 <ggCommand+0x2f4>)
    5ad0:	f7fe fd7e 	bl	45d0 <chprintf>
    chprintf(chp, "    stby      Set gg standby"NL);
    5ad4:	4630      	mov	r0, r6
    5ad6:	4920      	ldr	r1, [pc, #128]	; (5b58 <ggCommand+0x2f8>)
    5ad8:	f7fe fd7a 	bl	45d0 <chprintf>
    5adc:	e739      	b.n	5952 <ggCommand+0xf2>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
  }
  
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
    5ade:	4630      	mov	r0, r6
    5ae0:	462a      	mov	r2, r5
    5ae2:	491e      	ldr	r1, [pc, #120]	; (5b5c <ggCommand+0x2fc>)
    5ae4:	f7fe fd74 	bl	45d0 <chprintf>
    5ae8:	e733      	b.n	5952 <ggCommand+0xf2>
    tx[0] = 0x09; // voltage register
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    5aea:	480c      	ldr	r0, [pc, #48]	; (5b1c <ggCommand+0x2bc>)
    5aec:	f7fd f900 	bl	2cf0 <i2cGetErrors>
    5af0:	490d      	ldr	r1, [pc, #52]	; (5b28 <ggCommand+0x2c8>)
    5af2:	4602      	mov	r2, r0
    5af4:	4630      	mov	r0, r6
    5af6:	f7fe fd6b 	bl	45d0 <chprintf>
    5afa:	e7b9      	b.n	5a70 <ggCommand+0x210>
    tx[0] = 0x0f; // ITE register
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, LC709203_ADDR, tx, 1, rx, 3, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    5afc:	4807      	ldr	r0, [pc, #28]	; (5b1c <ggCommand+0x2bc>)
    5afe:	f7fd f8f7 	bl	2cf0 <i2cGetErrors>
    5b02:	4909      	ldr	r1, [pc, #36]	; (5b28 <ggCommand+0x2c8>)
    5b04:	4602      	mov	r2, r0
    5b06:	4630      	mov	r0, r6
    5b08:	f7fe fd62 	bl	45d0 <chprintf>
    5b0c:	e77f      	b.n	5a0e <ggCommand+0x1ae>
    5b0e:	bf00      	nop
    5b10:	000076e4 	.word	0x000076e4
    5b14:	00007954 	.word	0x00007954
    5b18:	00007984 	.word	0x00007984
    5b1c:	1ffff3f8 	.word	0x1ffff3f8
    5b20:	0000798c 	.word	0x0000798c
    5b24:	00007760 	.word	0x00007760
    5b28:	000076e8 	.word	0x000076e8
    5b2c:	00007944 	.word	0x00007944
    5b30:	00007994 	.word	0x00007994
    5b34:	00007998 	.word	0x00007998
    5b38:	000077a0 	.word	0x000077a0
    5b3c:	00007958 	.word	0x00007958
    5b40:	00007974 	.word	0x00007974
    5b44:	00007890 	.word	0x00007890
    5b48:	000078a8 	.word	0x000078a8
    5b4c:	000078c8 	.word	0x000078c8
    5b50:	000078e8 	.word	0x000078e8
    5b54:	00007908 	.word	0x00007908
    5b58:	00007924 	.word	0x00007924
    5b5c:	00007740 	.word	0x00007740

00005b60 <fpgaReconfig>:
#define NL SHELL_NEWLINE_STR

uint32_t spiRuntSend(SPIDriver *spip, uint32_t count, uint8_t *data);
void fpgaProgramPage(SPIDriver *spidev, uint32_t page, uint32_t spi_data_count, uint8_t *spi_data);

void fpgaReconfig(void) {
    5b60:	b570      	push	{r4, r5, r6, lr}
    5b62:	b082      	sub	sp, #8
    uint8_t dummy = 0xFF;
    5b64:	aa02      	add	r2, sp, #8
    
    spiRuntSend(&SPID2, 1, &dummy); // send a dummy byte to get clock to high default polarity
    5b66:	4c10      	ldr	r4, [pc, #64]	; (5ba8 <fpgaReconfig+0x48>)
    // do it while bus is /deselected/
    // this is doen just in case we're off a cold boot
    spiSelect(&SPID2); // SS must be low to set config mode correctly

    palClearPad(IOPORT2, 18);
    5b68:	4d10      	ldr	r5, [pc, #64]	; (5bac <fpgaReconfig+0x4c>)

uint32_t spiRuntSend(SPIDriver *spip, uint32_t count, uint8_t *data);
void fpgaProgramPage(SPIDriver *spidev, uint32_t page, uint32_t spi_data_count, uint8_t *spi_data);

void fpgaReconfig(void) {
    uint8_t dummy = 0xFF;
    5b6a:	23ff      	movs	r3, #255	; 0xff
    5b6c:	f802 3d01 	strb.w	r3, [r2, #-1]!
    
    spiRuntSend(&SPID2, 1, &dummy); // send a dummy byte to get clock to high default polarity
    5b70:	2101      	movs	r1, #1
    5b72:	4620      	mov	r0, r4
    5b74:	f7ff fd0c 	bl	5590 <spiRuntSend>
    // do it while bus is /deselected/
    // this is doen just in case we're off a cold boot
    spiSelect(&SPID2); // SS must be low to set config mode correctly

    palClearPad(IOPORT2, 18);
    5b78:	f44f 2680 	mov.w	r6, #262144	; 0x40000
    uint8_t dummy = 0xFF;
    
    spiRuntSend(&SPID2, 1, &dummy); // send a dummy byte to get clock to high default polarity
    // do it while bus is /deselected/
    // this is doen just in case we're off a cold boot
    spiSelect(&SPID2); // SS must be low to set config mode correctly
    5b7c:	4620      	mov	r0, r4
    5b7e:	f7fd fa3f 	bl	3000 <spiSelect>

    palClearPad(IOPORT2, 18);
    5b82:	60ae      	str	r6, [r5, #8]
    chThdSleepMilliseconds(1);
    5b84:	2001      	movs	r0, #1
    5b86:	f7fb ff3b 	bl	1a00 <chThdSleep>
    palSetPad(IOPORT2, 18);
    5b8a:	606e      	str	r6, [r5, #4]
    
    chThdSleepMilliseconds(1);
    5b8c:	2001      	movs	r0, #1
    5b8e:	f7fb ff37 	bl	1a00 <chThdSleep>
    spiUnselect(&SPID2);
    5b92:	4620      	mov	r0, r4
    5b94:	f7fd fa6c 	bl	3070 <spiUnselect>
    
    fpgaProgramPage(&SPID2, 0, fpga_config_size, (uint8_t *) fpga_config);
    5b98:	4620      	mov	r0, r4
    5b9a:	2100      	movs	r1, #0
    5b9c:	4a04      	ldr	r2, [pc, #16]	; (5bb0 <fpgaReconfig+0x50>)
    5b9e:	4b05      	ldr	r3, [pc, #20]	; (5bb4 <fpgaReconfig+0x54>)
    5ba0:	f7ff fd1e 	bl	55e0 <fpgaProgramPage>
}
    5ba4:	b002      	add	sp, #8
    5ba6:	bd70      	pop	{r4, r5, r6, pc}
    5ba8:	1ffff3c8 	.word	0x1ffff3c8
    5bac:	400ff040 	.word	0x400ff040
    5bb0:	00007ddc 	.word	0x00007ddc
    5bb4:	00008040 	.word	0x00008040
    5bb8:	f3af 8000 	nop.w
    5bbc:	f3af 8000 	nop.w

00005bc0 <fpgaCommand>:

void fpgaCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5bc0:	b530      	push	{r4, r5, lr}
  (void)argc;
  (void)argv;

  if (argc <= 0) {
    5bc2:	2900      	cmp	r1, #0
    
    fpgaProgramPage(&SPID2, 0, fpga_config_size, (uint8_t *) fpga_config);
}

void fpgaCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5bc4:	b083      	sub	sp, #12
    5bc6:	4605      	mov	r5, r0
  (void)argc;
  (void)argv;

  if (argc <= 0) {
    5bc8:	dd46      	ble.n	5c58 <fpgaCommand+0x98>
    chprintf(chp, "    stat      config state"NL);
    chprintf(chp, "    config    load config"NL);
    return;
  }

  if (!strcasecmp(argv[0], "reset")) {
    5bca:	6814      	ldr	r4, [r2, #0]
    5bcc:	492a      	ldr	r1, [pc, #168]	; (5c78 <fpgaCommand+0xb8>)
    5bce:	4620      	mov	r0, r4
    5bd0:	f000 fd56 	bl	6680 <strcasecmp>
    5bd4:	b328      	cbz	r0, 5c22 <fpgaCommand+0x62>
    
    chThdSleepMilliseconds(1);
    spiUnselect(&SPID2);
  }
  
  else if (!strcasecmp(argv[0], "stat")) {
    5bd6:	4620      	mov	r0, r4
    5bd8:	4928      	ldr	r1, [pc, #160]	; (5c7c <fpgaCommand+0xbc>)
    5bda:	f000 fd51 	bl	6680 <strcasecmp>
    5bde:	b178      	cbz	r0, 5c00 <fpgaCommand+0x40>
    chprintf(chp, "Done pin status: "NL);
    palReadPad(IOPORT1, 12) == PAL_HIGH ? chprintf(chp, "high"NL) : chprintf(chp, "low"NL);
  }
  
  else if (!strcasecmp(argv[0], "config")) {
    5be0:	4620      	mov	r0, r4
    5be2:	4927      	ldr	r1, [pc, #156]	; (5c80 <fpgaCommand+0xc0>)
    5be4:	f000 fd4c 	bl	6680 <strcasecmp>
    5be8:	b130      	cbz	r0, 5bf8 <fpgaCommand+0x38>
    fpgaReconfig();
  }

  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
    5bea:	4628      	mov	r0, r5
    5bec:	4622      	mov	r2, r4
    5bee:	4925      	ldr	r1, [pc, #148]	; (5c84 <fpgaCommand+0xc4>)
    5bf0:	f7fe fcee 	bl	45d0 <chprintf>
  }
  
  return;
}
    5bf4:	b003      	add	sp, #12
    5bf6:	bd30      	pop	{r4, r5, pc}
    chprintf(chp, "Done pin status: "NL);
    palReadPad(IOPORT1, 12) == PAL_HIGH ? chprintf(chp, "high"NL) : chprintf(chp, "low"NL);
  }
  
  else if (!strcasecmp(argv[0], "config")) {
    fpgaReconfig();
    5bf8:	f7ff ffb2 	bl	5b60 <fpgaReconfig>
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
  return;
}
    5bfc:	b003      	add	sp, #12
    5bfe:	bd30      	pop	{r4, r5, pc}
    chThdSleepMilliseconds(1);
    spiUnselect(&SPID2);
  }
  
  else if (!strcasecmp(argv[0], "stat")) {
    chprintf(chp, "Done pin status: "NL);
    5c00:	4628      	mov	r0, r5
    5c02:	4921      	ldr	r1, [pc, #132]	; (5c88 <fpgaCommand+0xc8>)
    5c04:	f7fe fce4 	bl	45d0 <chprintf>
    palReadPad(IOPORT1, 12) == PAL_HIGH ? chprintf(chp, "high"NL) : chprintf(chp, "low"NL);
    5c08:	210c      	movs	r1, #12
    5c0a:	4820      	ldr	r0, [pc, #128]	; (5c8c <fpgaCommand+0xcc>)
    5c0c:	f7fd fc40 	bl	3490 <_pal_lld_readpad>
    5c10:	2801      	cmp	r0, #1
    5c12:	bf0c      	ite	eq
    5c14:	491e      	ldreq	r1, [pc, #120]	; (5c90 <fpgaCommand+0xd0>)
    5c16:	491f      	ldrne	r1, [pc, #124]	; (5c94 <fpgaCommand+0xd4>)
    5c18:	4628      	mov	r0, r5
    5c1a:	f7fe fcd9 	bl	45d0 <chprintf>
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
  return;
}
    5c1e:	b003      	add	sp, #12
    5c20:	bd30      	pop	{r4, r5, pc}
    chprintf(chp, "    config    load config"NL);
    return;
  }

  if (!strcasecmp(argv[0], "reset")) {
    uint8_t dummy = 0xFF;
    5c22:	aa02      	add	r2, sp, #8
    5c24:	23ff      	movs	r3, #255	; 0xff
    5c26:	f802 3d01 	strb.w	r3, [r2, #-1]!
    spiRuntSend(&SPID2, 1, &dummy); // send a dummy byte to get clock to high default polarity
    5c2a:	2101      	movs	r1, #1
    // do it while bus is /deselected/
    // this is doen just in case we're off a cold boot
    
    spiSelect(&SPID2); // SS must be low to set config mode correctly

    palClearPad(IOPORT2, 18);
    5c2c:	4c1a      	ldr	r4, [pc, #104]	; (5c98 <fpgaCommand+0xd8>)
    return;
  }

  if (!strcasecmp(argv[0], "reset")) {
    uint8_t dummy = 0xFF;
    spiRuntSend(&SPID2, 1, &dummy); // send a dummy byte to get clock to high default polarity
    5c2e:	481b      	ldr	r0, [pc, #108]	; (5c9c <fpgaCommand+0xdc>)
    5c30:	f7ff fcae 	bl	5590 <spiRuntSend>
    // do it while bus is /deselected/
    // this is doen just in case we're off a cold boot
    
    spiSelect(&SPID2); // SS must be low to set config mode correctly

    palClearPad(IOPORT2, 18);
    5c34:	f44f 2580 	mov.w	r5, #262144	; 0x40000
    uint8_t dummy = 0xFF;
    spiRuntSend(&SPID2, 1, &dummy); // send a dummy byte to get clock to high default polarity
    // do it while bus is /deselected/
    // this is doen just in case we're off a cold boot
    
    spiSelect(&SPID2); // SS must be low to set config mode correctly
    5c38:	4818      	ldr	r0, [pc, #96]	; (5c9c <fpgaCommand+0xdc>)
    5c3a:	f7fd f9e1 	bl	3000 <spiSelect>

    palClearPad(IOPORT2, 18);
    5c3e:	60a5      	str	r5, [r4, #8]
    chThdSleepMilliseconds(1);
    5c40:	2001      	movs	r0, #1
    5c42:	f7fb fedd 	bl	1a00 <chThdSleep>
    palSetPad(IOPORT2, 18);
    5c46:	6065      	str	r5, [r4, #4]
    
    chThdSleepMilliseconds(1);
    5c48:	2001      	movs	r0, #1
    5c4a:	f7fb fed9 	bl	1a00 <chThdSleep>
    spiUnselect(&SPID2);
    5c4e:	4813      	ldr	r0, [pc, #76]	; (5c9c <fpgaCommand+0xdc>)
    5c50:	f7fd fa0e 	bl	3070 <spiUnselect>
  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
  return;
}
    5c54:	b003      	add	sp, #12
    5c56:	bd30      	pop	{r4, r5, pc}
{
  (void)argc;
  (void)argv;

  if (argc <= 0) {
    chprintf(chp, "Usage: fpga [verb]:"SHELL_NEWLINE_STR);
    5c58:	4911      	ldr	r1, [pc, #68]	; (5ca0 <fpgaCommand+0xe0>)
    5c5a:	f7fe fcb9 	bl	45d0 <chprintf>
    chprintf(chp, "    reset     reset FPGA"SHELL_NEWLINE_STR);
    5c5e:	4628      	mov	r0, r5
    5c60:	4910      	ldr	r1, [pc, #64]	; (5ca4 <fpgaCommand+0xe4>)
    5c62:	f7fe fcb5 	bl	45d0 <chprintf>
    chprintf(chp, "    stat      config state"NL);
    5c66:	4628      	mov	r0, r5
    5c68:	490f      	ldr	r1, [pc, #60]	; (5ca8 <fpgaCommand+0xe8>)
    5c6a:	f7fe fcb1 	bl	45d0 <chprintf>
    chprintf(chp, "    config    load config"NL);
    5c6e:	4628      	mov	r0, r5
    5c70:	490e      	ldr	r1, [pc, #56]	; (5cac <fpgaCommand+0xec>)
    5c72:	f7fe fcad 	bl	45d0 <chprintf>
    return;
    5c76:	e7bd      	b.n	5bf4 <fpgaCommand+0x34>
    5c78:	00007738 	.word	0x00007738
    5c7c:	00007a10 	.word	0x00007a10
    5c80:	00007a3c 	.word	0x00007a3c
    5c84:	00007740 	.word	0x00007740
    5c88:	00007a18 	.word	0x00007a18
    5c8c:	400ff000 	.word	0x400ff000
    5c90:	00007a2c 	.word	0x00007a2c
    5c94:	00007a34 	.word	0x00007a34
    5c98:	400ff040 	.word	0x400ff040
    5c9c:	1ffff3c8 	.word	0x1ffff3c8
    5ca0:	000079a0 	.word	0x000079a0
    5ca4:	000079b8 	.word	0x000079b8
    5ca8:	000079d4 	.word	0x000079d4
    5cac:	000079f4 	.word	0x000079f4

00005cb0 <chg_cb>:
  i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, NULL, 0, TIME_INFINITE);
  i2cReleaseBus(&I2CD1);
}


static void chg_cb(void *arg) {
    5cb0:	b508      	push	{r3, lr}
    5cb2:	2320      	movs	r3, #32
    5cb4:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
    5cb8:	f7fc f80a 	bl	1cd0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    5cbc:	f7fb f9e0 	bl	1080 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
    5cc0:	480c      	ldr	r0, [pc, #48]	; (5cf4 <chg_cb+0x44>)
    5cc2:	2100      	movs	r1, #0
    5cc4:	f7fc fa4c 	bl	2160 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
    5cc8:	f7fb fa3a 	bl	1140 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
    5ccc:	480a      	ldr	r0, [pc, #40]	; (5cf8 <chg_cb+0x48>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    5cce:	68c3      	ldr	r3, [r0, #12]
    5cd0:	b10b      	cbz	r3, 5cd6 <chg_cb+0x26>
    chVTDoResetI(vtp);
    5cd2:	f7fb fa95 	bl	1200 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    5cd6:	4808      	ldr	r0, [pc, #32]	; (5cf8 <chg_cb+0x48>)
    5cd8:	4a08      	ldr	r2, [pc, #32]	; (5cfc <chg_cb+0x4c>)
    5cda:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    5cde:	2300      	movs	r3, #0
    5ce0:	f7fb fa5e 	bl	11a0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
    5ce4:	f7fb f9e4 	bl	10b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    5ce8:	f7fb fffa 	bl	1ce0 <_stats_stop_measure_crit_isr>
    5cec:	2300      	movs	r3, #0
    5cee:	f383 8811 	msr	BASEPRI, r3
    5cf2:	bd08      	pop	{r3, pc}
    5cf4:	2000056c 	.word	0x2000056c
    5cf8:	20000570 	.word	0x20000570
    5cfc:	00005cb1 	.word	0x00005cb1

00005d00 <chg_keepalive_handler>:
virtual_timer_t chg_vt;
event_source_t chg_keepalive_event;

void ggOn(void);

void chg_keepalive_handler(eventid_t id) {
    5d00:	b530      	push	{r4, r5, lr}
  uint8_t tx[2];

  tx[0] = FAN5421_CTL0_ADR;
  tx[1] = 0xC0; // 32sec timer reset, enable stat pin

  i2cAcquireBus(&I2CD1);
    5d02:	4c0e      	ldr	r4, [pc, #56]	; (5d3c <chg_keepalive_handler+0x3c>)
virtual_timer_t chg_vt;
event_source_t chg_keepalive_event;

void ggOn(void);

void chg_keepalive_handler(eventid_t id) {
    5d04:	b087      	sub	sp, #28
  (void) id;
  uint8_t tx[2];

  tx[0] = FAN5421_CTL0_ADR;
    5d06:	2500      	movs	r5, #0
  tx[1] = 0xC0; // 32sec timer reset, enable stat pin

  i2cAcquireBus(&I2CD1);
    5d08:	4620      	mov	r0, r4
void chg_keepalive_handler(eventid_t id) {
  (void) id;
  uint8_t tx[2];

  tx[0] = FAN5421_CTL0_ADR;
  tx[1] = 0xC0; // 32sec timer reset, enable stat pin
    5d0a:	23c0      	movs	r3, #192	; 0xc0
    5d0c:	f88d 3015 	strb.w	r3, [sp, #21]

void chg_keepalive_handler(eventid_t id) {
  (void) id;
  uint8_t tx[2];

  tx[0] = FAN5421_CTL0_ADR;
    5d10:	f88d 5014 	strb.w	r5, [sp, #20]
  tx[1] = 0xC0; // 32sec timer reset, enable stat pin

  i2cAcquireBus(&I2CD1);
    5d14:	f7fd f85c 	bl	2dd0 <i2cAcquireBus>
  i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, NULL, 0, TIME_INFINITE);
    5d18:	f04f 33ff 	mov.w	r3, #4294967295
    5d1c:	216a      	movs	r1, #106	; 0x6a
    5d1e:	aa05      	add	r2, sp, #20
    5d20:	9302      	str	r3, [sp, #8]
    5d22:	9500      	str	r5, [sp, #0]
    5d24:	2302      	movs	r3, #2
    5d26:	9501      	str	r5, [sp, #4]
    5d28:	4620      	mov	r0, r4
    5d2a:	f7fc fff1 	bl	2d10 <i2cMasterTransmitTimeout>
  i2cReleaseBus(&I2CD1);
    5d2e:	4620      	mov	r0, r4
    5d30:	f7fd f866 	bl	2e00 <i2cReleaseBus>

  ggOn(); // make sure the gas gauge is powered on so it can capture charging
    5d34:	f7ff fd6c 	bl	5810 <ggOn>
  //  chprintf((BaseSequentialStream *)&SD4, "ping"NL);
}
    5d38:	b007      	add	sp, #28
    5d3a:	bd30      	pop	{r4, r5, pc}
    5d3c:	1ffff3f8 	.word	0x1ffff3f8

00005d40 <chgSetSafety>:

void chgSetSafety(void) {
    5d40:	b510      	push	{r4, lr}
  uint8_t tx[2];

  tx[0] = FAN5421_SAFE_ADR;
  tx[1] = 0x60; // 1150mA, 4.2V
  i2cAcquireBus(&I2CD1);
    5d42:	4c0e      	ldr	r4, [pc, #56]	; (5d7c <chgSetSafety+0x3c>)

  ggOn(); // make sure the gas gauge is powered on so it can capture charging
  //  chprintf((BaseSequentialStream *)&SD4, "ping"NL);
}

void chgSetSafety(void) {
    5d44:	b086      	sub	sp, #24
  uint8_t tx[2];

  tx[0] = FAN5421_SAFE_ADR;
    5d46:	2206      	movs	r2, #6
  tx[1] = 0x60; // 1150mA, 4.2V
  i2cAcquireBus(&I2CD1);
    5d48:	4620      	mov	r0, r4

void chgSetSafety(void) {
  uint8_t tx[2];

  tx[0] = FAN5421_SAFE_ADR;
  tx[1] = 0x60; // 1150mA, 4.2V
    5d4a:	2360      	movs	r3, #96	; 0x60
}

void chgSetSafety(void) {
  uint8_t tx[2];

  tx[0] = FAN5421_SAFE_ADR;
    5d4c:	f88d 2014 	strb.w	r2, [sp, #20]
  tx[1] = 0x60; // 1150mA, 4.2V
    5d50:	f88d 3015 	strb.w	r3, [sp, #21]
  i2cAcquireBus(&I2CD1);
    5d54:	f7fd f83c 	bl	2dd0 <i2cAcquireBus>
  i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, NULL, 0, TIME_INFINITE);
    5d58:	2300      	movs	r3, #0
    5d5a:	f04f 32ff 	mov.w	r2, #4294967295
    5d5e:	9300      	str	r3, [sp, #0]
    5d60:	9301      	str	r3, [sp, #4]
    5d62:	9202      	str	r2, [sp, #8]
    5d64:	216a      	movs	r1, #106	; 0x6a
    5d66:	aa05      	add	r2, sp, #20
    5d68:	2302      	movs	r3, #2
    5d6a:	4620      	mov	r0, r4
    5d6c:	f7fc ffd0 	bl	2d10 <i2cMasterTransmitTimeout>
  i2cReleaseBus(&I2CD1);
    5d70:	4620      	mov	r0, r4
    5d72:	f7fd f845 	bl	2e00 <i2cReleaseBus>
}
    5d76:	b006      	add	sp, #24
    5d78:	bd10      	pop	{r4, pc}
    5d7a:	bf00      	nop
    5d7c:	1ffff3f8 	.word	0x1ffff3f8

00005d80 <chgCommand>:
  chVTSetI(&chg_vt, MS2ST(1000), chg_cb, NULL);
  chSysUnlockFromISR();
}

void chgCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5d80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  (void)argv;
  uint8_t tx[2], rx[1];
  msg_t retval;
  uint32_t temp;
  
  if (argc <= 0) {
    5d84:	2900      	cmp	r1, #0
  chVTSetI(&chg_vt, MS2ST(1000), chg_cb, NULL);
  chSysUnlockFromISR();
}

void chgCommand(BaseSequentialStream *chp, int argc, char *argv[])
{
    5d86:	b086      	sub	sp, #24
    5d88:	4604      	mov	r4, r0
  (void)argv;
  uint8_t tx[2], rx[1];
  msg_t retval;
  uint32_t temp;
  
  if (argc <= 0) {
    5d8a:	f340 8361 	ble.w	6450 <__ram0_size__+0x450>
    chprintf(chp, "    auto      Set sane defaults (doesn't start keep-alive)"SHELL_NEWLINE_STR);
    chprintf(chp, "    dump      Raw dump of registers"SHELL_NEWLINE_STR);
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    5d8e:	6816      	ldr	r6, [r2, #0]
    5d90:	4973      	ldr	r1, [pc, #460]	; (5f60 <chgCommand+0x1e0>)
    5d92:	4630      	mov	r0, r6
    5d94:	f000 fc74 	bl	6680 <strcasecmp>
    5d98:	2800      	cmp	r0, #0
    5d9a:	d051      	beq.n	5e40 <chgCommand+0xc0>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "ID code: %02x"NL, rx[0]);
  }

  else if (!strcasecmp(argv[0], "start")) {
    5d9c:	4630      	mov	r0, r6
    5d9e:	4971      	ldr	r1, [pc, #452]	; (5f64 <chgCommand+0x1e4>)
    5da0:	f000 fc6e 	bl	6680 <strcasecmp>
    5da4:	2800      	cmp	r0, #0
    5da6:	d06d      	beq.n	5e84 <chgCommand+0x104>
    }

    chVTSet(&chg_vt, MS2ST(1000), chg_cb, NULL);
  }
  
  else if (!strcasecmp(argv[0], "stop")) {
    5da8:	4630      	mov	r0, r6
    5daa:	496f      	ldr	r1, [pc, #444]	; (5f68 <chgCommand+0x1e8>)
    5dac:	f000 fc68 	bl	6680 <strcasecmp>
    5db0:	2800      	cmp	r0, #0
    5db2:	f000 8283 	beq.w	62bc <__ram0_size__+0x2bc>
    }

    chVTReset(&chg_vt);
  }

  else if (!strcasecmp(argv[0], "auto")) {
    5db6:	4630      	mov	r0, r6
    5db8:	496c      	ldr	r1, [pc, #432]	; (5f6c <chgCommand+0x1ec>)
    5dba:	f000 fc61 	bl	6680 <strcasecmp>
    5dbe:	4605      	mov	r5, r0
    5dc0:	2800      	cmp	r0, #0
    5dc2:	f000 82cc 	beq.w	635e <__ram0_size__+0x35e>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
  }
  
  else if (!strcasecmp(argv[0], "stat")) {
    5dc6:	4630      	mov	r0, r6
    5dc8:	4969      	ldr	r1, [pc, #420]	; (5f70 <chgCommand+0x1f0>)
    5dca:	f000 fc59 	bl	6680 <strcasecmp>
    5dce:	4603      	mov	r3, r0
    5dd0:	2800      	cmp	r0, #0
    5dd2:	f000 80e1 	beq.w	5f98 <chgCommand+0x218>
    
    temp = 4200 + (rx[0] & 0xF) * 20;
    chprintf(chp, "Max Vbat safety limit: %dmV"NL, temp);
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    5dd6:	4630      	mov	r0, r6
    5dd8:	4966      	ldr	r1, [pc, #408]	; (5f74 <chgCommand+0x1f4>)
    5dda:	f000 fc51 	bl	6680 <strcasecmp>
    5dde:	2800      	cmp	r0, #0
    5de0:	f040 839a 	bne.w	6518 <__ram0_size__+0x518>
    5de4:	4605      	mov	r5, r0
    5de6:	ae05      	add	r6, sp, #20
    5de8:	af04      	add	r7, sp, #16
    5dea:	e008      	b.n	5dfe <chgCommand+0x7e>
      retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
      i2cReleaseBus(&I2CD1);
      if( retval != MSG_OK ) {
	chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
      }
      chprintf(chp, "%02x ", rx[0]);
    5dec:	4620      	mov	r0, r4
    5dee:	4962      	ldr	r1, [pc, #392]	; (5f78 <chgCommand+0x1f8>)
    5df0:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5df4:	f7fe fbec 	bl	45d0 <chprintf>
    chprintf(chp, "Max Vbat safety limit: %dmV"NL, temp);
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    int i;
    for( i = 0; i < 7; i++ ) {
    5df8:	2d07      	cmp	r5, #7
    5dfa:	f000 82a9 	beq.w	6350 <__ram0_size__+0x350>
      tx[0] = i;
      i2cAcquireBus(&I2CD1);
    5dfe:	485f      	ldr	r0, [pc, #380]	; (5f7c <chgCommand+0x1fc>)
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    int i;
    for( i = 0; i < 7; i++ ) {
      tx[0] = i;
    5e00:	f88d 5014 	strb.w	r5, [sp, #20]
      i2cAcquireBus(&I2CD1);
    5e04:	f7fc ffe4 	bl	2dd0 <i2cAcquireBus>
      retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5e08:	2301      	movs	r3, #1
    5e0a:	f04f 32ff 	mov.w	r2, #4294967295
    5e0e:	9202      	str	r2, [sp, #8]
    5e10:	9700      	str	r7, [sp, #0]
    5e12:	9301      	str	r3, [sp, #4]
    5e14:	4859      	ldr	r0, [pc, #356]	; (5f7c <chgCommand+0x1fc>)
    5e16:	216a      	movs	r1, #106	; 0x6a
    5e18:	4632      	mov	r2, r6
    chprintf(chp, "Max Vbat safety limit: %dmV"NL, temp);
  }
  
  else if (!strcasecmp(argv[0], "dump")) {
    int i;
    for( i = 0; i < 7; i++ ) {
    5e1a:	441d      	add	r5, r3
      tx[0] = i;
      i2cAcquireBus(&I2CD1);
      retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5e1c:	f7fc ff78 	bl	2d10 <i2cMasterTransmitTimeout>
    5e20:	4680      	mov	r8, r0
      i2cReleaseBus(&I2CD1);
    5e22:	4856      	ldr	r0, [pc, #344]	; (5f7c <chgCommand+0x1fc>)
    5e24:	f7fc ffec 	bl	2e00 <i2cReleaseBus>
      if( retval != MSG_OK ) {
    5e28:	f1b8 0f00 	cmp.w	r8, #0
    5e2c:	d0de      	beq.n	5dec <chgCommand+0x6c>
	chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    5e2e:	4853      	ldr	r0, [pc, #332]	; (5f7c <chgCommand+0x1fc>)
    5e30:	f7fc ff5e 	bl	2cf0 <i2cGetErrors>
    5e34:	4952      	ldr	r1, [pc, #328]	; (5f80 <chgCommand+0x200>)
    5e36:	4602      	mov	r2, r0
    5e38:	4620      	mov	r0, r4
    5e3a:	f7fe fbc9 	bl	45d0 <chprintf>
    5e3e:	e7d5      	b.n	5dec <chgCommand+0x6c>
    chprintf(chp, "    dump      Raw dump of registers"SHELL_NEWLINE_STR);
    return;
  }

  if (!strcasecmp(argv[0], "id")) {
    tx[0] = FAN5421_INFO_ADR;
    5e40:	ad06      	add	r5, sp, #24
    5e42:	2303      	movs	r3, #3
    5e44:	f805 3d04 	strb.w	r3, [r5, #-4]!
    i2cAcquireBus(&I2CD1);
    5e48:	484c      	ldr	r0, [pc, #304]	; (5f7c <chgCommand+0x1fc>)
    5e4a:	f7fc ffc1 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5e4e:	a804      	add	r0, sp, #16
    5e50:	2301      	movs	r3, #1
    5e52:	f04f 31ff 	mov.w	r1, #4294967295
    5e56:	462a      	mov	r2, r5
    5e58:	e88d 0009 	stmia.w	sp, {r0, r3}
    5e5c:	9102      	str	r1, [sp, #8]
    5e5e:	4847      	ldr	r0, [pc, #284]	; (5f7c <chgCommand+0x1fc>)
    5e60:	216a      	movs	r1, #106	; 0x6a
    5e62:	f7fc ff55 	bl	2d10 <i2cMasterTransmitTimeout>
    5e66:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    5e68:	4844      	ldr	r0, [pc, #272]	; (5f7c <chgCommand+0x1fc>)
    5e6a:	f7fc ffc9 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5e6e:	2d00      	cmp	r5, #0
    5e70:	d16c      	bne.n	5f4c <chgCommand+0x1cc>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    chprintf(chp, "ID code: %02x"NL, rx[0]);
    5e72:	4620      	mov	r0, r4
    5e74:	4943      	ldr	r1, [pc, #268]	; (5f84 <chgCommand+0x204>)
    5e76:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5e7a:	f7fe fba9 	bl	45d0 <chprintf>

  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    5e7e:	b006      	add	sp, #24
    5e80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    chprintf(chp, "ID code: %02x"NL, rx[0]);
  }

  else if (!strcasecmp(argv[0], "start")) {
    tx[0] = FAN5421_CTL1_ADR;
    5e84:	ae06      	add	r6, sp, #24
    5e86:	2501      	movs	r5, #1
    5e88:	f806 5d04 	strb.w	r5, [r6, #-4]!
    i2cAcquireBus(&I2CD1);
    5e8c:	483b      	ldr	r0, [pc, #236]	; (5f7c <chgCommand+0x1fc>)
    5e8e:	f7fc ff9f 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5e92:	af04      	add	r7, sp, #16
    5e94:	f04f 31ff 	mov.w	r1, #4294967295
    5e98:	9501      	str	r5, [sp, #4]
    5e9a:	462b      	mov	r3, r5
    5e9c:	9102      	str	r1, [sp, #8]
    5e9e:	4632      	mov	r2, r6
    5ea0:	9700      	str	r7, [sp, #0]
    5ea2:	4836      	ldr	r0, [pc, #216]	; (5f7c <chgCommand+0x1fc>)
    5ea4:	216a      	movs	r1, #106	; 0x6a
    5ea6:	f7fc ff33 	bl	2d10 <i2cMasterTransmitTimeout>
    5eaa:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    5eac:	4833      	ldr	r0, [pc, #204]	; (5f7c <chgCommand+0x1fc>)
    5eae:	f7fc ffa7 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5eb2:	2d00      	cmp	r5, #0
    5eb4:	f040 82f1 	bne.w	649a <__ram0_size__+0x49a>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    tx[1] = rx[0] & 0xFB; // bit 2 low to start charging
    5eb8:	f89d 3010 	ldrb.w	r3, [sp, #16]
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    5ebc:	482f      	ldr	r0, [pc, #188]	; (5f7c <chgCommand+0x1fc>)
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    tx[1] = rx[0] & 0xFB; // bit 2 low to start charging
    5ebe:	f023 0304 	bic.w	r3, r3, #4
    tx[0] = FAN5421_CTL1_ADR;
    5ec2:	2201      	movs	r2, #1
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    tx[1] = rx[0] & 0xFB; // bit 2 low to start charging
    5ec4:	f88d 3015 	strb.w	r3, [sp, #21]
    tx[0] = FAN5421_CTL1_ADR;
    5ec8:	f88d 2014 	strb.w	r2, [sp, #20]
    i2cAcquireBus(&I2CD1);
    5ecc:	f7fc ff80 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    5ed0:	2100      	movs	r1, #0
    5ed2:	f04f 33ff 	mov.w	r3, #4294967295
    5ed6:	9101      	str	r1, [sp, #4]
    5ed8:	9302      	str	r3, [sp, #8]
    5eda:	9700      	str	r7, [sp, #0]
    5edc:	4632      	mov	r2, r6
    5ede:	4827      	ldr	r0, [pc, #156]	; (5f7c <chgCommand+0x1fc>)
    5ee0:	216a      	movs	r1, #106	; 0x6a
    5ee2:	2302      	movs	r3, #2
    5ee4:	f7fc ff14 	bl	2d10 <i2cMasterTransmitTimeout>
    5ee8:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    5eea:	4824      	ldr	r0, [pc, #144]	; (5f7c <chgCommand+0x1fc>)
    5eec:	f7fc ff88 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5ef0:	2d00      	cmp	r5, #0
    5ef2:	f040 82c9 	bne.w	6488 <__ram0_size__+0x488>
    5ef6:	2320      	movs	r3, #32
    5ef8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    5efc:	f7fb fed8 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    5f00:	f7fb f896 	bl	1030 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
    5f04:	f7fb f91c 	bl	1140 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
    5f08:	481f      	ldr	r0, [pc, #124]	; (5f88 <chgCommand+0x208>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    5f0a:	68c3      	ldr	r3, [r0, #12]
    5f0c:	b10b      	cbz	r3, 5f12 <chgCommand+0x192>
    chVTDoResetI(vtp);
    5f0e:	f7fb f977 	bl	1200 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    5f12:	481d      	ldr	r0, [pc, #116]	; (5f88 <chgCommand+0x208>)
    5f14:	4a1d      	ldr	r2, [pc, #116]	; (5f8c <chgCommand+0x20c>)
    5f16:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    5f1a:	2300      	movs	r3, #0
    5f1c:	f7fb f940 	bl	11a0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
    5f20:	f7fb f896 	bl	1050 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    5f24:	f7fb fecc 	bl	1cc0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    5f28:	4b19      	ldr	r3, [pc, #100]	; (5f90 <chgCommand+0x210>)
    5f2a:	681a      	ldr	r2, [r3, #0]
    5f2c:	429a      	cmp	r2, r3
    5f2e:	d007      	beq.n	5f40 <chgCommand+0x1c0>
    5f30:	6999      	ldr	r1, [r3, #24]
    5f32:	6893      	ldr	r3, [r2, #8]
    5f34:	688a      	ldr	r2, [r1, #8]
    5f36:	429a      	cmp	r2, r3
    5f38:	d202      	bcs.n	5f40 <chgCommand+0x1c0>
    5f3a:	4816      	ldr	r0, [pc, #88]	; (5f94 <chgCommand+0x214>)
    5f3c:	f7fb f820 	bl	f80 <chSysHalt>
    5f40:	2300      	movs	r3, #0
    5f42:	f383 8811 	msr	BASEPRI, r3

  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    5f46:	b006      	add	sp, #24
    5f48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tx[0] = FAN5421_INFO_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    5f4c:	480b      	ldr	r0, [pc, #44]	; (5f7c <chgCommand+0x1fc>)
    5f4e:	f7fc fecf 	bl	2cf0 <i2cGetErrors>
    5f52:	490b      	ldr	r1, [pc, #44]	; (5f80 <chgCommand+0x200>)
    5f54:	4602      	mov	r2, r0
    5f56:	4620      	mov	r0, r4
    5f58:	f7fe fb3a 	bl	45d0 <chprintf>
    5f5c:	e789      	b.n	5e72 <chgCommand+0xf2>
    5f5e:	bf00      	nop
    5f60:	000076e4 	.word	0x000076e4
    5f64:	00007b50 	.word	0x00007b50
    5f68:	00007b58 	.word	0x00007b58
    5f6c:	00007b60 	.word	0x00007b60
    5f70:	00007a10 	.word	0x00007a10
    5f74:	00007984 	.word	0x00007984
    5f78:	0000776c 	.word	0x0000776c
    5f7c:	1ffff3f8 	.word	0x1ffff3f8
    5f80:	000076e8 	.word	0x000076e8
    5f84:	00007b40 	.word	0x00007b40
    5f88:	20000570 	.word	0x20000570
    5f8c:	00005cb1 	.word	0x00005cb1
    5f90:	1ffff228 	.word	0x1ffff228
    5f94:	00007e50 	.word	0x00007e50
    }
    
  }
  
  else if (!strcasecmp(argv[0], "stat")) {
    tx[0] = FAN5421_CTL0_ADR;
    5f98:	ae06      	add	r6, sp, #24
    i2cAcquireBus(&I2CD1);
    5f9a:	48ad      	ldr	r0, [pc, #692]	; (6250 <__ram0_size__+0x250>)
    }
    
  }
  
  else if (!strcasecmp(argv[0], "stat")) {
    tx[0] = FAN5421_CTL0_ADR;
    5f9c:	f806 3d04 	strb.w	r3, [r6, #-4]!
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5fa0:	af04      	add	r7, sp, #16
    
  }
  
  else if (!strcasecmp(argv[0], "stat")) {
    tx[0] = FAN5421_CTL0_ADR;
    i2cAcquireBus(&I2CD1);
    5fa2:	f7fc ff15 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    5fa6:	2301      	movs	r3, #1
    5fa8:	f04f 31ff 	mov.w	r1, #4294967295
    5fac:	9102      	str	r1, [sp, #8]
    5fae:	4632      	mov	r2, r6
    5fb0:	9700      	str	r7, [sp, #0]
    5fb2:	9301      	str	r3, [sp, #4]
    5fb4:	48a6      	ldr	r0, [pc, #664]	; (6250 <__ram0_size__+0x250>)
    5fb6:	216a      	movs	r1, #106	; 0x6a
    5fb8:	f7fc feaa 	bl	2d10 <i2cMasterTransmitTimeout>
    5fbc:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    5fbe:	48a4      	ldr	r0, [pc, #656]	; (6250 <__ram0_size__+0x250>)
    5fc0:	f7fc ff1e 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    5fc4:	2d00      	cmp	r5, #0
    5fc6:	f040 8271 	bne.w	64ac <__ram0_size__+0x4ac>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    chprintf(chp, "Status: ");
    5fca:	4620      	mov	r0, r4
    5fcc:	49a1      	ldr	r1, [pc, #644]	; (6254 <__ram0_size__+0x254>)
    5fce:	f7fe faff 	bl	45d0 <chprintf>
    switch( (rx[0] >> 4) & 0x3 ) {
    5fd2:	f89d 3010 	ldrb.w	r3, [sp, #16]
    5fd6:	f3c3 1301 	ubfx	r3, r3, #4, #2
    5fda:	2b02      	cmp	r3, #2
      break;
    case 1:
      chprintf(chp, "Charge in progress"NL);
      break;
    case 2:
      chprintf(chp, "Charge done"NL);
    5fdc:	4620      	mov	r0, r4
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    chprintf(chp, "Status: ");
    switch( (rx[0] >> 4) & 0x3 ) {
    5fde:	f000 8323 	beq.w	6628 <__ram0_size__+0x628>
    5fe2:	2b03      	cmp	r3, #3
    5fe4:	f000 826b 	beq.w	64be <__ram0_size__+0x4be>
    5fe8:	2b01      	cmp	r3, #1
    case 0:
      chprintf(chp, "Ready"NL);
    5fea:	bf14      	ite	ne
    5fec:	499a      	ldrne	r1, [pc, #616]	; (6258 <__ram0_size__+0x258>)
      break;
    case 1:
      chprintf(chp, "Charge in progress"NL);
    5fee:	499b      	ldreq	r1, [pc, #620]	; (625c <__ram0_size__+0x25c>)
    5ff0:	f7fe faee 	bl	45d0 <chprintf>
	break;
      }
      break;
    }
    
    chprintf(chp, "STAT ");
    5ff4:	499a      	ldr	r1, [pc, #616]	; (6260 <__ram0_size__+0x260>)
    5ff6:	4620      	mov	r0, r4
    5ff8:	f7fe faea 	bl	45d0 <chprintf>
    rx[0] >> 6 ? chprintf( chp, "enabled"NL ) : chprintf( chp, "disabled"NL );
    5ffc:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6000:	099b      	lsrs	r3, r3, #6
    6002:	bf14      	ite	ne
    6004:	4997      	ldrne	r1, [pc, #604]	; (6264 <__ram0_size__+0x264>)
    6006:	4998      	ldreq	r1, [pc, #608]	; (6268 <__ram0_size__+0x268>)
    6008:	4620      	mov	r0, r4
    600a:	f7fe fae1 	bl	45d0 <chprintf>
    
    tx[0] = FAN5421_CTL1_ADR;
    600e:	2501      	movs	r5, #1
    i2cAcquireBus(&I2CD1);
    6010:	488f      	ldr	r0, [pc, #572]	; (6250 <__ram0_size__+0x250>)
    }
    
    chprintf(chp, "STAT ");
    rx[0] >> 6 ? chprintf( chp, "enabled"NL ) : chprintf( chp, "disabled"NL );
    
    tx[0] = FAN5421_CTL1_ADR;
    6012:	f88d 5014 	strb.w	r5, [sp, #20]
    i2cAcquireBus(&I2CD1);
    6016:	f7fc fedb 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    601a:	f04f 32ff 	mov.w	r2, #4294967295
    601e:	9501      	str	r5, [sp, #4]
    6020:	462b      	mov	r3, r5
    6022:	9202      	str	r2, [sp, #8]
    6024:	9700      	str	r7, [sp, #0]
    6026:	488a      	ldr	r0, [pc, #552]	; (6250 <__ram0_size__+0x250>)
    6028:	216a      	movs	r1, #106	; 0x6a
    602a:	4632      	mov	r2, r6
    602c:	f7fc fe70 	bl	2d10 <i2cMasterTransmitTimeout>
    6030:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    6032:	4887      	ldr	r0, [pc, #540]	; (6250 <__ram0_size__+0x250>)
    6034:	f7fc fee4 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6038:	2d00      	cmp	r5, #0
    603a:	f040 82ec 	bne.w	6616 <__ram0_size__+0x616>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    temp = ((rx[0] >> 4) & 0x3) + 4;
    603e:	f89d 2010 	ldrb.w	r2, [sp, #16]
    chprintf(chp, "Weak battery threshold: 3.%dV"NL, temp);
    6042:	498a      	ldr	r1, [pc, #552]	; (626c <__ram0_size__+0x26c>)
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    temp = ((rx[0] >> 4) & 0x3) + 4;
    6044:	f3c2 1201 	ubfx	r2, r2, #4, #2
    chprintf(chp, "Weak battery threshold: 3.%dV"NL, temp);
    6048:	3204      	adds	r2, #4
    604a:	4620      	mov	r0, r4
    604c:	f7fe fac0 	bl	45d0 <chprintf>

    chprintf(chp, "Charge current termination ");
    6050:	4987      	ldr	r1, [pc, #540]	; (6270 <__ram0_size__+0x270>)
    6052:	4620      	mov	r0, r4
    6054:	f7fe fabc 	bl	45d0 <chprintf>
    (rx[0] >> 3) & 0x1 ? chprintf( chp, "enabled"NL ) : chprintf( chp, "disabled"NL );
    6058:	f89d 3010 	ldrb.w	r3, [sp, #16]
    605c:	071a      	lsls	r2, r3, #28
    605e:	bf4c      	ite	mi
    6060:	4980      	ldrmi	r1, [pc, #512]	; (6264 <__ram0_size__+0x264>)
    6062:	4981      	ldrpl	r1, [pc, #516]	; (6268 <__ram0_size__+0x268>)
    6064:	4620      	mov	r0, r4
    6066:	f7fe fab3 	bl	45d0 <chprintf>

    chprintf(chp, "Charger ");
    606a:	4982      	ldr	r1, [pc, #520]	; (6274 <__ram0_size__+0x274>)
    606c:	4620      	mov	r0, r4
    606e:	f7fe faaf 	bl	45d0 <chprintf>
    (rx[0] >> 2) & 0x1 ? chprintf( chp, "disabled"NL ) : chprintf( chp, "enabled"NL );
    6072:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6076:	075b      	lsls	r3, r3, #29
    6078:	bf4c      	ite	mi
    607a:	497b      	ldrmi	r1, [pc, #492]	; (6268 <__ram0_size__+0x268>)
    607c:	4979      	ldrpl	r1, [pc, #484]	; (6264 <__ram0_size__+0x264>)
    607e:	4620      	mov	r0, r4
    6080:	f7fe faa6 	bl	45d0 <chprintf>

    chprintf(chp, "High impedance mode ");
    6084:	497c      	ldr	r1, [pc, #496]	; (6278 <__ram0_size__+0x278>)
    6086:	4620      	mov	r0, r4
    6088:	f7fe faa2 	bl	45d0 <chprintf>
    (rx[0] >> 1) & 0x1 ? chprintf( chp, "enabled"NL ) : chprintf( chp, "disabled"NL );
    608c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6090:	079d      	lsls	r5, r3, #30
    6092:	bf4c      	ite	mi
    6094:	4973      	ldrmi	r1, [pc, #460]	; (6264 <__ram0_size__+0x264>)
    6096:	4974      	ldrpl	r1, [pc, #464]	; (6268 <__ram0_size__+0x268>)
    6098:	4620      	mov	r0, r4
    609a:	f7fe fa99 	bl	45d0 <chprintf>

    tx[0] = FAN5421_OREG_ADR;
    609e:	2302      	movs	r3, #2
    i2cAcquireBus(&I2CD1);
    60a0:	486b      	ldr	r0, [pc, #428]	; (6250 <__ram0_size__+0x250>)
    (rx[0] >> 2) & 0x1 ? chprintf( chp, "disabled"NL ) : chprintf( chp, "enabled"NL );

    chprintf(chp, "High impedance mode ");
    (rx[0] >> 1) & 0x1 ? chprintf( chp, "enabled"NL ) : chprintf( chp, "disabled"NL );

    tx[0] = FAN5421_OREG_ADR;
    60a2:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    60a6:	f7fc fe93 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    60aa:	2301      	movs	r3, #1
    60ac:	f04f 32ff 	mov.w	r2, #4294967295
    60b0:	9202      	str	r2, [sp, #8]
    60b2:	9700      	str	r7, [sp, #0]
    60b4:	9301      	str	r3, [sp, #4]
    60b6:	4866      	ldr	r0, [pc, #408]	; (6250 <__ram0_size__+0x250>)
    60b8:	216a      	movs	r1, #106	; 0x6a
    60ba:	4632      	mov	r2, r6
    60bc:	f7fc fe28 	bl	2d10 <i2cMasterTransmitTimeout>
    60c0:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    60c2:	4863      	ldr	r0, [pc, #396]	; (6250 <__ram0_size__+0x250>)
    60c4:	f7fc fe9c 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    60c8:	2d00      	cmp	r5, #0
    60ca:	f040 829b 	bne.w	6604 <__ram0_size__+0x604>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    chprintf(chp, "Float voltage ");
    60ce:	496b      	ldr	r1, [pc, #428]	; (627c <__ram0_size__+0x27c>)
    60d0:	4620      	mov	r0, r4
    60d2:	f7fe fa7d 	bl	45d0 <chprintf>
    temp = 3500 + ((rx[0] >> 2) * 20);
    60d6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    chprintf(chp, "%dmV"NL, temp);
    60da:	4969      	ldr	r1, [pc, #420]	; (6280 <__ram0_size__+0x280>)
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    chprintf(chp, "Float voltage ");
    temp = 3500 + ((rx[0] >> 2) * 20);
    60dc:	089b      	lsrs	r3, r3, #2
    60de:	2014      	movs	r0, #20
    60e0:	f640 52ac 	movw	r2, #3500	; 0xdac
    chprintf(chp, "%dmV"NL, temp);
    60e4:	fb00 2203 	mla	r2, r0, r3, r2
    60e8:	4620      	mov	r0, r4
    60ea:	f7fe fa71 	bl	45d0 <chprintf>

    tx[0] = FAN5421_SPCHG_ADR;
    60ee:	2305      	movs	r3, #5
    i2cAcquireBus(&I2CD1);
    60f0:	4857      	ldr	r0, [pc, #348]	; (6250 <__ram0_size__+0x250>)

    chprintf(chp, "Float voltage ");
    temp = 3500 + ((rx[0] >> 2) * 20);
    chprintf(chp, "%dmV"NL, temp);

    tx[0] = FAN5421_SPCHG_ADR;
    60f2:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    60f6:	f7fc fe6b 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    60fa:	2301      	movs	r3, #1
    60fc:	f04f 32ff 	mov.w	r2, #4294967295
    6100:	9202      	str	r2, [sp, #8]
    6102:	9700      	str	r7, [sp, #0]
    6104:	9301      	str	r3, [sp, #4]
    6106:	4852      	ldr	r0, [pc, #328]	; (6250 <__ram0_size__+0x250>)
    6108:	216a      	movs	r1, #106	; 0x6a
    610a:	4632      	mov	r2, r6
    610c:	f7fc fe00 	bl	2d10 <i2cMasterTransmitTimeout>
    6110:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    6112:	484f      	ldr	r0, [pc, #316]	; (6250 <__ram0_size__+0x250>)
    6114:	f7fc fe74 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6118:	2d00      	cmp	r5, #0
    611a:	f040 8242 	bne.w	65a2 <__ram0_size__+0x5a2>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    chprintf(chp, "Disable pin: ");
    611e:	4959      	ldr	r1, [pc, #356]	; (6284 <__ram0_size__+0x284>)
    6120:	4620      	mov	r0, r4
    6122:	f7fe fa55 	bl	45d0 <chprintf>
    (rx[0] >> 3) & 0x1 ? chprintf( chp, "high, charging disabled"NL ) : chprintf( chp, "low, charging controllled by I2C"NL );
    6126:	f89d 3010 	ldrb.w	r3, [sp, #16]
    612a:	0719      	lsls	r1, r3, #28
    612c:	bf4c      	ite	mi
    612e:	4956      	ldrmi	r1, [pc, #344]	; (6288 <__ram0_size__+0x288>)
    6130:	4956      	ldrpl	r1, [pc, #344]	; (628c <__ram0_size__+0x28c>)
    6132:	4620      	mov	r0, r4
    6134:	f7fe fa4c 	bl	45d0 <chprintf>
    
    chprintf(chp, "Weak charger: ");
    6138:	4955      	ldr	r1, [pc, #340]	; (6290 <__ram0_size__+0x290>)
    613a:	4620      	mov	r0, r4
    613c:	f7fe fa48 	bl	45d0 <chprintf>
    (rx[0] >> 4) & 0x1 ? chprintf( chp, "detected"NL ) : chprintf( chp, "not detected"NL );
    6140:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6144:	06da      	lsls	r2, r3, #27
    6146:	bf4c      	ite	mi
    6148:	4952      	ldrmi	r1, [pc, #328]	; (6294 <__ram0_size__+0x294>)
    614a:	4953      	ldrpl	r1, [pc, #332]	; (6298 <__ram0_size__+0x298>)
    614c:	4620      	mov	r0, r4
    614e:	f7fe fa3f 	bl	45d0 <chprintf>

    temp = (rx[0] & 0x7) * 80 + 4200;
    6152:	f89d 3010 	ldrb.w	r3, [sp, #16]
    chprintf(chp, "Weak charger keep-above voltage: %dmV"NL, temp);
    6156:	4951      	ldr	r1, [pc, #324]	; (629c <__ram0_size__+0x29c>)
    (rx[0] >> 3) & 0x1 ? chprintf( chp, "high, charging disabled"NL ) : chprintf( chp, "low, charging controllled by I2C"NL );
    
    chprintf(chp, "Weak charger: ");
    (rx[0] >> 4) & 0x1 ? chprintf( chp, "detected"NL ) : chprintf( chp, "not detected"NL );

    temp = (rx[0] & 0x7) * 80 + 4200;
    6158:	f003 0307 	and.w	r3, r3, #7
    615c:	2050      	movs	r0, #80	; 0x50
    615e:	f241 0268 	movw	r2, #4200	; 0x1068
    chprintf(chp, "Weak charger keep-above voltage: %dmV"NL, temp);
    6162:	fb00 2203 	mla	r2, r0, r3, r2
    6166:	4620      	mov	r0, r4
    6168:	f7fe fa32 	bl	45d0 <chprintf>
    
    chprintf(chp, "Charge current programming: ");
    616c:	494c      	ldr	r1, [pc, #304]	; (62a0 <__ram0_size__+0x2a0>)
    616e:	4620      	mov	r0, r4
    6170:	f7fe fa2e 	bl	45d0 <chprintf>
    (rx[0] >> 5) & 0x1 ? chprintf( chp, "fixed at 325mA"NL ) : chprintf( chp, "per IOCHARGE below"NL );
    6174:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6178:	069b      	lsls	r3, r3, #26
    617a:	bf4c      	ite	mi
    617c:	4949      	ldrmi	r1, [pc, #292]	; (62a4 <__ram0_size__+0x2a4>)
    617e:	494a      	ldrpl	r1, [pc, #296]	; (62a8 <__ram0_size__+0x2a8>)
    6180:	4620      	mov	r0, r4
    6182:	f7fe fa25 	bl	45d0 <chprintf>

    
    tx[0] = FAN5421_IBAT_ADR;
    6186:	2304      	movs	r3, #4
    i2cAcquireBus(&I2CD1);
    6188:	4831      	ldr	r0, [pc, #196]	; (6250 <__ram0_size__+0x250>)
    
    chprintf(chp, "Charge current programming: ");
    (rx[0] >> 5) & 0x1 ? chprintf( chp, "fixed at 325mA"NL ) : chprintf( chp, "per IOCHARGE below"NL );

    
    tx[0] = FAN5421_IBAT_ADR;
    618a:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    618e:	f7fc fe1f 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    6192:	2301      	movs	r3, #1
    6194:	f04f 32ff 	mov.w	r2, #4294967295
    6198:	9202      	str	r2, [sp, #8]
    619a:	9700      	str	r7, [sp, #0]
    619c:	9301      	str	r3, [sp, #4]
    619e:	482c      	ldr	r0, [pc, #176]	; (6250 <__ram0_size__+0x250>)
    61a0:	216a      	movs	r1, #106	; 0x6a
    61a2:	4632      	mov	r2, r6
    61a4:	f7fc fdb4 	bl	2d10 <i2cMasterTransmitTimeout>
    61a8:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    61aa:	4829      	ldr	r0, [pc, #164]	; (6250 <__ram0_size__+0x250>)
    61ac:	f7fc fe28 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    61b0:	2d00      	cmp	r5, #0
    61b2:	f040 81ed 	bne.w	6590 <__ram0_size__+0x590>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    temp = 550 + ((rx[0] >> 3) & 0xF) * 100;
    61b6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    chprintf(chp, "IOCHARGE programmable charge current limit: %dmA"NL, temp);
    61ba:	493c      	ldr	r1, [pc, #240]	; (62ac <__ram0_size__+0x2ac>)
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    temp = 550 + ((rx[0] >> 3) & 0xF) * 100;
    61bc:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    61c0:	2064      	movs	r0, #100	; 0x64
    61c2:	f240 2226 	movw	r2, #550	; 0x226
    chprintf(chp, "IOCHARGE programmable charge current limit: %dmA"NL, temp);
    61c6:	fb00 2203 	mla	r2, r0, r3, r2
    61ca:	4620      	mov	r0, r4
    61cc:	f7fe fa00 	bl	45d0 <chprintf>

    temp = ((rx[0] & 0x7) * 49) + 49;
    61d0:	f89d 2010 	ldrb.w	r2, [sp, #16]
    chprintf(chp, "Termination current limit: %dmA"NL, temp);
    61d4:	4936      	ldr	r1, [pc, #216]	; (62b0 <__ram0_size__+0x2b0>)
    }

    temp = 550 + ((rx[0] >> 3) & 0xF) * 100;
    chprintf(chp, "IOCHARGE programmable charge current limit: %dmA"NL, temp);

    temp = ((rx[0] & 0x7) * 49) + 49;
    61d6:	f002 0207 	and.w	r2, r2, #7
    61da:	3201      	adds	r2, #1
    61dc:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    chprintf(chp, "Termination current limit: %dmA"NL, temp);
    61e0:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    61e4:	4620      	mov	r0, r4
    61e6:	f7fe f9f3 	bl	45d0 <chprintf>
    
    tx[0] = FAN5421_SAFE_ADR;
    61ea:	2306      	movs	r3, #6
    i2cAcquireBus(&I2CD1);
    61ec:	4818      	ldr	r0, [pc, #96]	; (6250 <__ram0_size__+0x250>)
    chprintf(chp, "IOCHARGE programmable charge current limit: %dmA"NL, temp);

    temp = ((rx[0] & 0x7) * 49) + 49;
    chprintf(chp, "Termination current limit: %dmA"NL, temp);
    
    tx[0] = FAN5421_SAFE_ADR;
    61ee:	f88d 3014 	strb.w	r3, [sp, #20]
    i2cAcquireBus(&I2CD1);
    61f2:	f7fc fded 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    61f6:	2301      	movs	r3, #1
    61f8:	f04f 31ff 	mov.w	r1, #4294967295
    61fc:	9102      	str	r1, [sp, #8]
    61fe:	9700      	str	r7, [sp, #0]
    6200:	4632      	mov	r2, r6
    6202:	9301      	str	r3, [sp, #4]
    6204:	4812      	ldr	r0, [pc, #72]	; (6250 <__ram0_size__+0x250>)
    6206:	216a      	movs	r1, #106	; 0x6a
    6208:	f7fc fd82 	bl	2d10 <i2cMasterTransmitTimeout>
    620c:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    620e:	4810      	ldr	r0, [pc, #64]	; (6250 <__ram0_size__+0x250>)
    6210:	f7fc fdf6 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6214:	2d00      	cmp	r5, #0
    6216:	f040 81b2 	bne.w	657e <__ram0_size__+0x57e>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    temp = 550 + ((rx[0] >> 4) & 0xF) * 100;
    621a:	f89d 3010 	ldrb.w	r3, [sp, #16]
    chprintf(chp, "Max IOCHARGE safety limit: %dmA"NL, temp);
    621e:	4925      	ldr	r1, [pc, #148]	; (62b4 <__ram0_size__+0x2b4>)
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    temp = 550 + ((rx[0] >> 4) & 0xF) * 100;
    6220:	091b      	lsrs	r3, r3, #4
    6222:	2064      	movs	r0, #100	; 0x64
    6224:	f240 2226 	movw	r2, #550	; 0x226
    chprintf(chp, "Max IOCHARGE safety limit: %dmA"NL, temp);
    6228:	fb00 2203 	mla	r2, r0, r3, r2
    622c:	4620      	mov	r0, r4
    622e:	f7fe f9cf 	bl	45d0 <chprintf>
    
    temp = 4200 + (rx[0] & 0xF) * 20;
    6232:	f89d 3010 	ldrb.w	r3, [sp, #16]
    chprintf(chp, "Max Vbat safety limit: %dmV"NL, temp);
    6236:	4920      	ldr	r1, [pc, #128]	; (62b8 <__ram0_size__+0x2b8>)
    }

    temp = 550 + ((rx[0] >> 4) & 0xF) * 100;
    chprintf(chp, "Max IOCHARGE safety limit: %dmA"NL, temp);
    
    temp = 4200 + (rx[0] & 0xF) * 20;
    6238:	f003 030f 	and.w	r3, r3, #15
    623c:	2514      	movs	r5, #20
    623e:	f241 0268 	movw	r2, #4200	; 0x1068
    chprintf(chp, "Max Vbat safety limit: %dmV"NL, temp);
    6242:	4620      	mov	r0, r4
    6244:	fb05 2203 	mla	r2, r5, r3, r2
    6248:	f7fe f9c2 	bl	45d0 <chprintf>
    624c:	e617      	b.n	5e7e <chgCommand+0xfe>
    624e:	bf00      	nop
    6250:	1ffff3f8 	.word	0x1ffff3f8
    6254:	00007b68 	.word	0x00007b68
    6258:	00007b74 	.word	0x00007b74
    625c:	00007b7c 	.word	0x00007b7c
    6260:	00007c30 	.word	0x00007c30
    6264:	00007c38 	.word	0x00007c38
    6268:	00007c44 	.word	0x00007c44
    626c:	00007c50 	.word	0x00007c50
    6270:	00007c70 	.word	0x00007c70
    6274:	00007c8c 	.word	0x00007c8c
    6278:	00007c98 	.word	0x00007c98
    627c:	00007cb0 	.word	0x00007cb0
    6280:	00007cc0 	.word	0x00007cc0
    6284:	00007cc8 	.word	0x00007cc8
    6288:	00007cd8 	.word	0x00007cd8
    628c:	00007cf4 	.word	0x00007cf4
    6290:	00007d18 	.word	0x00007d18
    6294:	00007d2c 	.word	0x00007d2c
    6298:	00007d28 	.word	0x00007d28
    629c:	00007d38 	.word	0x00007d38
    62a0:	00007d60 	.word	0x00007d60
    62a4:	00007d80 	.word	0x00007d80
    62a8:	00007d94 	.word	0x00007d94
    62ac:	00007dac 	.word	0x00007dac
    62b0:	00007de0 	.word	0x00007de0
    62b4:	00007e04 	.word	0x00007e04
    62b8:	00007e28 	.word	0x00007e28

    chVTSet(&chg_vt, MS2ST(1000), chg_cb, NULL);
  }
  
  else if (!strcasecmp(argv[0], "stop")) {
    tx[0] = FAN5421_CTL1_ADR;
    62bc:	ae06      	add	r6, sp, #24
    62be:	2501      	movs	r5, #1
    62c0:	f806 5d04 	strb.w	r5, [r6, #-4]!
    i2cAcquireBus(&I2CD1);
    62c4:	48bb      	ldr	r0, [pc, #748]	; (65b4 <__ram0_size__+0x5b4>)
    62c6:	f7fc fd83 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    62ca:	af04      	add	r7, sp, #16
    62cc:	f04f 31ff 	mov.w	r1, #4294967295
    62d0:	9501      	str	r5, [sp, #4]
    62d2:	462b      	mov	r3, r5
    62d4:	9102      	str	r1, [sp, #8]
    62d6:	4632      	mov	r2, r6
    62d8:	9700      	str	r7, [sp, #0]
    62da:	48b6      	ldr	r0, [pc, #728]	; (65b4 <__ram0_size__+0x5b4>)
    62dc:	216a      	movs	r1, #106	; 0x6a
    62de:	f7fc fd17 	bl	2d10 <i2cMasterTransmitTimeout>
    62e2:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    62e4:	48b3      	ldr	r0, [pc, #716]	; (65b4 <__ram0_size__+0x5b4>)
    62e6:	f7fc fd8b 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    62ea:	2d00      	cmp	r5, #0
    62ec:	f040 8123 	bne.w	6536 <__ram0_size__+0x536>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    tx[1] = rx[0] | 0x04; // bit 2 high to stop charging
    62f0:	f89d 3010 	ldrb.w	r3, [sp, #16]
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    62f4:	48af      	ldr	r0, [pc, #700]	; (65b4 <__ram0_size__+0x5b4>)
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    tx[1] = rx[0] | 0x04; // bit 2 high to stop charging
    62f6:	f043 0304 	orr.w	r3, r3, #4
    tx[0] = FAN5421_CTL1_ADR;
    62fa:	2201      	movs	r2, #1
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }

    tx[1] = rx[0] | 0x04; // bit 2 high to stop charging
    62fc:	f88d 3015 	strb.w	r3, [sp, #21]
    tx[0] = FAN5421_CTL1_ADR;
    6300:	f88d 2014 	strb.w	r2, [sp, #20]
    i2cAcquireBus(&I2CD1);
    6304:	f7fc fd64 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    6308:	2100      	movs	r1, #0
    630a:	f04f 33ff 	mov.w	r3, #4294967295
    630e:	9101      	str	r1, [sp, #4]
    6310:	9302      	str	r3, [sp, #8]
    6312:	9700      	str	r7, [sp, #0]
    6314:	4632      	mov	r2, r6
    6316:	48a7      	ldr	r0, [pc, #668]	; (65b4 <__ram0_size__+0x5b4>)
    6318:	216a      	movs	r1, #106	; 0x6a
    631a:	2302      	movs	r3, #2
    631c:	f7fc fcf8 	bl	2d10 <i2cMasterTransmitTimeout>
    6320:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    6322:	48a4      	ldr	r0, [pc, #656]	; (65b4 <__ram0_size__+0x5b4>)
    6324:	f7fc fd6c 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6328:	2d00      	cmp	r5, #0
    632a:	f040 80fb 	bne.w	6524 <__ram0_size__+0x524>
    632e:	2320      	movs	r3, #32
    6330:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
    6334:	f7fb fcbc 	bl	1cb0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    6338:	f7fa fe7a 	bl	1030 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
    633c:	f7fa ff00 	bl	1140 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
    6340:	489d      	ldr	r0, [pc, #628]	; (65b8 <__ram0_size__+0x5b8>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    6342:	68c3      	ldr	r3, [r0, #12]
    6344:	2b00      	cmp	r3, #0
    6346:	f43f adeb 	beq.w	5f20 <chgCommand+0x1a0>
    chVTDoResetI(vtp);
    634a:	f7fa ff59 	bl	1200 <chVTDoResetI>
    634e:	e5e7      	b.n	5f20 <chgCommand+0x1a0>
      if( retval != MSG_OK ) {
	chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
      }
      chprintf(chp, "%02x ", rx[0]);
    }
    chprintf(chp, NL);
    6350:	4620      	mov	r0, r4
    6352:	499a      	ldr	r1, [pc, #616]	; (65bc <__ram0_size__+0x5bc>)
    6354:	f7fe f93c 	bl	45d0 <chprintf>

  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
  }
  
}
    6358:	b006      	add	sp, #24
    635a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    chVTReset(&chg_vt);
  }

  else if (!strcasecmp(argv[0], "auto")) {
    // now set current targets
    tx[0] = FAN5421_IBAT_ADR;
    635e:	2204      	movs	r2, #4
    tx[1] = 0x6 << 3 | 0x2; // 1150mA, termination at 146mA (~C/10)
    6360:	2332      	movs	r3, #50	; 0x32
    i2cAcquireBus(&I2CD1);
    6362:	4894      	ldr	r0, [pc, #592]	; (65b4 <__ram0_size__+0x5b4>)
    chVTReset(&chg_vt);
  }

  else if (!strcasecmp(argv[0], "auto")) {
    // now set current targets
    tx[0] = FAN5421_IBAT_ADR;
    6364:	f88d 2014 	strb.w	r2, [sp, #20]
    tx[1] = 0x6 << 3 | 0x2; // 1150mA, termination at 146mA (~C/10)
    6368:	f88d 3015 	strb.w	r3, [sp, #21]
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    636c:	ae05      	add	r6, sp, #20

  else if (!strcasecmp(argv[0], "auto")) {
    // now set current targets
    tx[0] = FAN5421_IBAT_ADR;
    tx[1] = 0x6 << 3 | 0x2; // 1150mA, termination at 146mA (~C/10)
    i2cAcquireBus(&I2CD1);
    636e:	f7fc fd2f 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    6372:	af04      	add	r7, sp, #16
    6374:	f04f 33ff 	mov.w	r3, #4294967295
    6378:	9501      	str	r5, [sp, #4]
    637a:	9302      	str	r3, [sp, #8]
    637c:	4632      	mov	r2, r6
    637e:	9700      	str	r7, [sp, #0]
    6380:	488c      	ldr	r0, [pc, #560]	; (65b4 <__ram0_size__+0x5b4>)
    6382:	216a      	movs	r1, #106	; 0x6a
    6384:	2302      	movs	r3, #2
    6386:	f7fc fcc3 	bl	2d10 <i2cMasterTransmitTimeout>
    638a:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    638c:	4889      	ldr	r0, [pc, #548]	; (65b4 <__ram0_size__+0x5b4>)
    638e:	f7fc fd37 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6392:	2d00      	cmp	r5, #0
    6394:	f040 80e1 	bne.w	655a <__ram0_size__+0x55a>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    tx[0] = FAN5421_SPCHG_ADR;
    6398:	2305      	movs	r3, #5
    tx[1] = 0x00; // use IOCHARGE to set target current
    639a:	2500      	movs	r5, #0
    i2cAcquireBus(&I2CD1);
    639c:	4885      	ldr	r0, [pc, #532]	; (65b4 <__ram0_size__+0x5b4>)
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    tx[0] = FAN5421_SPCHG_ADR;
    639e:	f88d 3014 	strb.w	r3, [sp, #20]
    tx[1] = 0x00; // use IOCHARGE to set target current
    63a2:	f88d 5015 	strb.w	r5, [sp, #21]
    i2cAcquireBus(&I2CD1);
    63a6:	f7fc fd13 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    63aa:	f04f 33ff 	mov.w	r3, #4294967295
    63ae:	9501      	str	r5, [sp, #4]
    63b0:	9302      	str	r3, [sp, #8]
    63b2:	9700      	str	r7, [sp, #0]
    63b4:	487f      	ldr	r0, [pc, #508]	; (65b4 <__ram0_size__+0x5b4>)
    63b6:	216a      	movs	r1, #106	; 0x6a
    63b8:	4632      	mov	r2, r6
    63ba:	2302      	movs	r3, #2
    63bc:	f7fc fca8 	bl	2d10 <i2cMasterTransmitTimeout>
    63c0:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    63c2:	487c      	ldr	r0, [pc, #496]	; (65b4 <__ram0_size__+0x5b4>)
    63c4:	f7fc fd1c 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    63c8:	2d00      	cmp	r5, #0
    63ca:	f040 80bd 	bne.w	6548 <__ram0_size__+0x548>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    // target "float" voltage
    tx[0] = FAN5421_OREG_ADR;
    63ce:	2502      	movs	r5, #2
    tx[1] = (0x22 << 2); // target 4.18 float voltage
    63d0:	2388      	movs	r3, #136	; 0x88
    i2cAcquireBus(&I2CD1);
    63d2:	4878      	ldr	r0, [pc, #480]	; (65b4 <__ram0_size__+0x5b4>)
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    // target "float" voltage
    tx[0] = FAN5421_OREG_ADR;
    63d4:	f88d 5014 	strb.w	r5, [sp, #20]
    tx[1] = (0x22 << 2); // target 4.18 float voltage
    63d8:	f88d 3015 	strb.w	r3, [sp, #21]
    i2cAcquireBus(&I2CD1);
    63dc:	f7fc fcf8 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    63e0:	2100      	movs	r1, #0
    63e2:	f04f 32ff 	mov.w	r2, #4294967295
    63e6:	462b      	mov	r3, r5
    63e8:	9101      	str	r1, [sp, #4]
    63ea:	9202      	str	r2, [sp, #8]
    63ec:	9700      	str	r7, [sp, #0]
    63ee:	4871      	ldr	r0, [pc, #452]	; (65b4 <__ram0_size__+0x5b4>)
    63f0:	216a      	movs	r1, #106	; 0x6a
    63f2:	4632      	mov	r2, r6
    63f4:	f7fc fc8c 	bl	2d10 <i2cMasterTransmitTimeout>
    63f8:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    63fa:	486e      	ldr	r0, [pc, #440]	; (65b4 <__ram0_size__+0x5b4>)
    63fc:	f7fc fd00 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6400:	2d00      	cmp	r5, #0
    6402:	f040 80b3 	bne.w	656c <__ram0_size__+0x56c>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    // initiate charging
    tx[0] = FAN5421_CTL1_ADR;
    6406:	2201      	movs	r2, #1
    tx[1] = 0x18; // weak battery: 3.5V; charge current termination; charger enabled
    6408:	2318      	movs	r3, #24
    i2cAcquireBus(&I2CD1);
    640a:	486a      	ldr	r0, [pc, #424]	; (65b4 <__ram0_size__+0x5b4>)
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    }
    
    // initiate charging
    tx[0] = FAN5421_CTL1_ADR;
    640c:	f88d 2014 	strb.w	r2, [sp, #20]
    tx[1] = 0x18; // weak battery: 3.5V; charge current termination; charger enabled
    6410:	f88d 3015 	strb.w	r3, [sp, #21]
    i2cAcquireBus(&I2CD1);
    6414:	f7fc fcdc 	bl	2dd0 <i2cAcquireBus>
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    6418:	2100      	movs	r1, #0
    641a:	f04f 33ff 	mov.w	r3, #4294967295
    641e:	9101      	str	r1, [sp, #4]
    6420:	9302      	str	r3, [sp, #8]
    6422:	9700      	str	r7, [sp, #0]
    6424:	4632      	mov	r2, r6
    6426:	4863      	ldr	r0, [pc, #396]	; (65b4 <__ram0_size__+0x5b4>)
    6428:	216a      	movs	r1, #106	; 0x6a
    642a:	2302      	movs	r3, #2
    642c:	f7fc fc70 	bl	2d10 <i2cMasterTransmitTimeout>
    6430:	4605      	mov	r5, r0
    i2cReleaseBus(&I2CD1);
    6432:	4860      	ldr	r0, [pc, #384]	; (65b4 <__ram0_size__+0x5b4>)
    6434:	f7fc fce4 	bl	2e00 <i2cReleaseBus>
    if( retval != MSG_OK ) {
    6438:	2d00      	cmp	r5, #0
    643a:	f43f ad20 	beq.w	5e7e <chgCommand+0xfe>
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    643e:	485d      	ldr	r0, [pc, #372]	; (65b4 <__ram0_size__+0x5b4>)
    6440:	f7fc fc56 	bl	2cf0 <i2cGetErrors>
    6444:	495e      	ldr	r1, [pc, #376]	; (65c0 <__ram0_size__+0x5c0>)
    6446:	4602      	mov	r2, r0
    6448:	4620      	mov	r0, r4
    644a:	f7fe f8c1 	bl	45d0 <chprintf>
    644e:	e516      	b.n	5e7e <chgCommand+0xfe>
  uint8_t tx[2], rx[1];
  msg_t retval;
  uint32_t temp;
  
  if (argc <= 0) {
    chprintf(chp, "Usage: chg [verb]:"SHELL_NEWLINE_STR);
    6450:	495c      	ldr	r1, [pc, #368]	; (65c4 <__ram0_size__+0x5c4>)
    6452:	f7fe f8bd 	bl	45d0 <chprintf>
    chprintf(chp, "    stat      Charger status"SHELL_NEWLINE_STR);
    6456:	4620      	mov	r0, r4
    6458:	495b      	ldr	r1, [pc, #364]	; (65c8 <__ram0_size__+0x5c8>)
    645a:	f7fe f8b9 	bl	45d0 <chprintf>
    chprintf(chp, "    id        Charger chip ID"SHELL_NEWLINE_STR);
    645e:	4620      	mov	r0, r4
    6460:	495a      	ldr	r1, [pc, #360]	; (65cc <__ram0_size__+0x5cc>)
    6462:	f7fe f8b5 	bl	45d0 <chprintf>
    chprintf(chp, "    start     Enable charging & keep-alive timer"SHELL_NEWLINE_STR);
    6466:	4620      	mov	r0, r4
    6468:	4959      	ldr	r1, [pc, #356]	; (65d0 <__ram0_size__+0x5d0>)
    646a:	f7fe f8b1 	bl	45d0 <chprintf>
    chprintf(chp, "    stop      Disable charging & keep-alive timer"SHELL_NEWLINE_STR);
    646e:	4620      	mov	r0, r4
    6470:	4958      	ldr	r1, [pc, #352]	; (65d4 <__ram0_size__+0x5d4>)
    6472:	f7fe f8ad 	bl	45d0 <chprintf>
    chprintf(chp, "    auto      Set sane defaults (doesn't start keep-alive)"SHELL_NEWLINE_STR);
    6476:	4620      	mov	r0, r4
    6478:	4957      	ldr	r1, [pc, #348]	; (65d8 <__ram0_size__+0x5d8>)
    647a:	f7fe f8a9 	bl	45d0 <chprintf>
    chprintf(chp, "    dump      Raw dump of registers"SHELL_NEWLINE_STR);
    647e:	4620      	mov	r0, r4
    6480:	4956      	ldr	r1, [pc, #344]	; (65dc <__ram0_size__+0x5dc>)
    6482:	f7fe f8a5 	bl	45d0 <chprintf>
    6486:	e4fa      	b.n	5e7e <chgCommand+0xfe>
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6488:	484a      	ldr	r0, [pc, #296]	; (65b4 <__ram0_size__+0x5b4>)
    648a:	f7fc fc31 	bl	2cf0 <i2cGetErrors>
    648e:	494c      	ldr	r1, [pc, #304]	; (65c0 <__ram0_size__+0x5c0>)
    6490:	4602      	mov	r2, r0
    6492:	4620      	mov	r0, r4
    6494:	f7fe f89c 	bl	45d0 <chprintf>
    6498:	e52d      	b.n	5ef6 <chgCommand+0x176>
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    649a:	4846      	ldr	r0, [pc, #280]	; (65b4 <__ram0_size__+0x5b4>)
    649c:	f7fc fc28 	bl	2cf0 <i2cGetErrors>
    64a0:	4947      	ldr	r1, [pc, #284]	; (65c0 <__ram0_size__+0x5c0>)
    64a2:	4602      	mov	r2, r0
    64a4:	4620      	mov	r0, r4
    64a6:	f7fe f893 	bl	45d0 <chprintf>
    64aa:	e505      	b.n	5eb8 <chgCommand+0x138>
    tx[0] = FAN5421_CTL0_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    64ac:	4841      	ldr	r0, [pc, #260]	; (65b4 <__ram0_size__+0x5b4>)
    64ae:	f7fc fc1f 	bl	2cf0 <i2cGetErrors>
    64b2:	4943      	ldr	r1, [pc, #268]	; (65c0 <__ram0_size__+0x5c0>)
    64b4:	4602      	mov	r2, r0
    64b6:	4620      	mov	r0, r4
    64b8:	f7fe f88a 	bl	45d0 <chprintf>
    64bc:	e585      	b.n	5fca <chgCommand+0x24a>
      break;
    case 2:
      chprintf(chp, "Charge done"NL);
      break;
    case 3:
      chprintf(chp, "Fault ");
    64be:	4948      	ldr	r1, [pc, #288]	; (65e0 <__ram0_size__+0x5e0>)
    64c0:	f7fe f886 	bl	45d0 <chprintf>
      switch( rx[0] & 0x7 ) {
    64c4:	f89d 3010 	ldrb.w	r3, [sp, #16]
    64c8:	f003 0307 	and.w	r3, r3, #7
    64cc:	3b01      	subs	r3, #1
	break;
      case 6:
	chprintf(chp, "Timer fault"NL);
	break;
      case 7:
	chprintf(chp, "No battery"NL);
    64ce:	4620      	mov	r0, r4
    case 2:
      chprintf(chp, "Charge done"NL);
      break;
    case 3:
      chprintf(chp, "Fault ");
      switch( rx[0] & 0x7 ) {
    64d0:	2b06      	cmp	r3, #6
    64d2:	d81d      	bhi.n	6510 <__ram0_size__+0x510>
    64d4:	e8df f003 	tbb	[pc, r3]
    64d8:	0c101418 	.word	0x0c101418
    64dc:	0408      	.short	0x0408
    64de:	ac          	.byte	0xac
    64df:	00          	.byte	0x00
	break;
      case 5:
	chprintf(chp, "Thermal shutdown"NL);
	break;
      case 6:
	chprintf(chp, "Timer fault"NL);
    64e0:	4940      	ldr	r1, [pc, #256]	; (65e4 <__ram0_size__+0x5e4>)
    64e2:	f7fe f875 	bl	45d0 <chprintf>
	break;
    64e6:	e585      	b.n	5ff4 <chgCommand+0x274>
	break;
      case 4:
	chprintf(chp, "Battery OVP"NL);
	break;
      case 5:
	chprintf(chp, "Thermal shutdown"NL);
    64e8:	493f      	ldr	r1, [pc, #252]	; (65e8 <__ram0_size__+0x5e8>)
    64ea:	f7fe f871 	bl	45d0 <chprintf>
	break;
    64ee:	e581      	b.n	5ff4 <chgCommand+0x274>
	break;
      case 3:
	chprintf(chp, "Poor input source"NL);
	break;
      case 4:
	chprintf(chp, "Battery OVP"NL);
    64f0:	493e      	ldr	r1, [pc, #248]	; (65ec <__ram0_size__+0x5ec>)
    64f2:	f7fe f86d 	bl	45d0 <chprintf>
	break;
    64f6:	e57d      	b.n	5ff4 <chgCommand+0x274>
	break;
      case 2:
	chprintf(chp, "Sleep mode"NL);
	break;
      case 3:
	chprintf(chp, "Poor input source"NL);
    64f8:	493d      	ldr	r1, [pc, #244]	; (65f0 <__ram0_size__+0x5f0>)
    64fa:	f7fe f869 	bl	45d0 <chprintf>
	break;
    64fe:	e579      	b.n	5ff4 <chgCommand+0x274>
	break;
      case 1:
	chprintf(chp, "Vbus OVP"NL);
	break;
      case 2:
	chprintf(chp, "Sleep mode"NL);
    6500:	493c      	ldr	r1, [pc, #240]	; (65f4 <__ram0_size__+0x5f4>)
    6502:	f7fe f865 	bl	45d0 <chprintf>
	break;
    6506:	e575      	b.n	5ff4 <chgCommand+0x274>
      switch( rx[0] & 0x7 ) {
      case 0:
	chprintf(chp, "(unreachable)"NL);
	break;
      case 1:
	chprintf(chp, "Vbus OVP"NL);
    6508:	493b      	ldr	r1, [pc, #236]	; (65f8 <__ram0_size__+0x5f8>)
    650a:	f7fe f861 	bl	45d0 <chprintf>
	break;
    650e:	e571      	b.n	5ff4 <chgCommand+0x274>
      break;
    case 3:
      chprintf(chp, "Fault ");
      switch( rx[0] & 0x7 ) {
      case 0:
	chprintf(chp, "(unreachable)"NL);
    6510:	493a      	ldr	r1, [pc, #232]	; (65fc <__ram0_size__+0x5fc>)
    6512:	f7fe f85d 	bl	45d0 <chprintf>
	break;
    6516:	e56d      	b.n	5ff4 <chgCommand+0x274>
    }
    chprintf(chp, NL);
  }

  else {
    chprintf(chp, "Unrecognized command: %s"NL, argv[0]);
    6518:	4620      	mov	r0, r4
    651a:	4632      	mov	r2, r6
    651c:	4938      	ldr	r1, [pc, #224]	; (6600 <__ram0_size__+0x600>)
    651e:	f7fe f857 	bl	45d0 <chprintf>
    6522:	e4ac      	b.n	5e7e <chgCommand+0xfe>
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6524:	4823      	ldr	r0, [pc, #140]	; (65b4 <__ram0_size__+0x5b4>)
    6526:	f7fc fbe3 	bl	2cf0 <i2cGetErrors>
    652a:	4925      	ldr	r1, [pc, #148]	; (65c0 <__ram0_size__+0x5c0>)
    652c:	4602      	mov	r2, r0
    652e:	4620      	mov	r0, r4
    6530:	f7fe f84e 	bl	45d0 <chprintf>
    6534:	e6fb      	b.n	632e <__ram0_size__+0x32e>
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6536:	481f      	ldr	r0, [pc, #124]	; (65b4 <__ram0_size__+0x5b4>)
    6538:	f7fc fbda 	bl	2cf0 <i2cGetErrors>
    653c:	4920      	ldr	r1, [pc, #128]	; (65c0 <__ram0_size__+0x5c0>)
    653e:	4602      	mov	r2, r0
    6540:	4620      	mov	r0, r4
    6542:	f7fe f845 	bl	45d0 <chprintf>
    6546:	e6d3      	b.n	62f0 <__ram0_size__+0x2f0>
    tx[1] = 0x00; // use IOCHARGE to set target current
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6548:	481a      	ldr	r0, [pc, #104]	; (65b4 <__ram0_size__+0x5b4>)
    654a:	f7fc fbd1 	bl	2cf0 <i2cGetErrors>
    654e:	491c      	ldr	r1, [pc, #112]	; (65c0 <__ram0_size__+0x5c0>)
    6550:	4602      	mov	r2, r0
    6552:	4620      	mov	r0, r4
    6554:	f7fe f83c 	bl	45d0 <chprintf>
    6558:	e739      	b.n	63ce <__ram0_size__+0x3ce>
    tx[1] = 0x6 << 3 | 0x2; // 1150mA, termination at 146mA (~C/10)
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    655a:	4816      	ldr	r0, [pc, #88]	; (65b4 <__ram0_size__+0x5b4>)
    655c:	f7fc fbc8 	bl	2cf0 <i2cGetErrors>
    6560:	4917      	ldr	r1, [pc, #92]	; (65c0 <__ram0_size__+0x5c0>)
    6562:	4602      	mov	r2, r0
    6564:	4620      	mov	r0, r4
    6566:	f7fe f833 	bl	45d0 <chprintf>
    656a:	e715      	b.n	6398 <__ram0_size__+0x398>
    tx[1] = (0x22 << 2); // target 4.18 float voltage
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 2, rx, 0, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    656c:	4811      	ldr	r0, [pc, #68]	; (65b4 <__ram0_size__+0x5b4>)
    656e:	f7fc fbbf 	bl	2cf0 <i2cGetErrors>
    6572:	4913      	ldr	r1, [pc, #76]	; (65c0 <__ram0_size__+0x5c0>)
    6574:	4602      	mov	r2, r0
    6576:	4620      	mov	r0, r4
    6578:	f7fe f82a 	bl	45d0 <chprintf>
    657c:	e743      	b.n	6406 <__ram0_size__+0x406>
    tx[0] = FAN5421_SAFE_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    657e:	480d      	ldr	r0, [pc, #52]	; (65b4 <__ram0_size__+0x5b4>)
    6580:	f7fc fbb6 	bl	2cf0 <i2cGetErrors>
    6584:	490e      	ldr	r1, [pc, #56]	; (65c0 <__ram0_size__+0x5c0>)
    6586:	4602      	mov	r2, r0
    6588:	4620      	mov	r0, r4
    658a:	f7fe f821 	bl	45d0 <chprintf>
    658e:	e644      	b.n	621a <__ram0_size__+0x21a>
    tx[0] = FAN5421_IBAT_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6590:	4808      	ldr	r0, [pc, #32]	; (65b4 <__ram0_size__+0x5b4>)
    6592:	f7fc fbad 	bl	2cf0 <i2cGetErrors>
    6596:	490a      	ldr	r1, [pc, #40]	; (65c0 <__ram0_size__+0x5c0>)
    6598:	4602      	mov	r2, r0
    659a:	4620      	mov	r0, r4
    659c:	f7fe f818 	bl	45d0 <chprintf>
    65a0:	e609      	b.n	61b6 <__ram0_size__+0x1b6>
    tx[0] = FAN5421_SPCHG_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    65a2:	4804      	ldr	r0, [pc, #16]	; (65b4 <__ram0_size__+0x5b4>)
    65a4:	f7fc fba4 	bl	2cf0 <i2cGetErrors>
    65a8:	4905      	ldr	r1, [pc, #20]	; (65c0 <__ram0_size__+0x5c0>)
    65aa:	4602      	mov	r2, r0
    65ac:	4620      	mov	r0, r4
    65ae:	f7fe f80f 	bl	45d0 <chprintf>
    65b2:	e5b4      	b.n	611e <__ram0_size__+0x11e>
    65b4:	1ffff3f8 	.word	0x1ffff3f8
    65b8:	20000570 	.word	0x20000570
    65bc:	000077a0 	.word	0x000077a0
    65c0:	000076e8 	.word	0x000076e8
    65c4:	00007890 	.word	0x00007890
    65c8:	00007a50 	.word	0x00007a50
    65cc:	000078a8 	.word	0x000078a8
    65d0:	00007a70 	.word	0x00007a70
    65d4:	00007aa4 	.word	0x00007aa4
    65d8:	00007ad8 	.word	0x00007ad8
    65dc:	00007b18 	.word	0x00007b18
    65e0:	00007ba4 	.word	0x00007ba4
    65e4:	00007c10 	.word	0x00007c10
    65e8:	00007bfc 	.word	0x00007bfc
    65ec:	00007bec 	.word	0x00007bec
    65f0:	00007bd8 	.word	0x00007bd8
    65f4:	00007bc8 	.word	0x00007bc8
    65f8:	00007bbc 	.word	0x00007bbc
    65fc:	00007bac 	.word	0x00007bac
    6600:	00007740 	.word	0x00007740
    tx[0] = FAN5421_OREG_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6604:	480c      	ldr	r0, [pc, #48]	; (6638 <__ram0_size__+0x638>)
    6606:	f7fc fb73 	bl	2cf0 <i2cGetErrors>
    660a:	490c      	ldr	r1, [pc, #48]	; (663c <__ram0_size__+0x63c>)
    660c:	4602      	mov	r2, r0
    660e:	4620      	mov	r0, r4
    6610:	f7fd ffde 	bl	45d0 <chprintf>
    6614:	e55b      	b.n	60ce <__ram0_size__+0xce>
    tx[0] = FAN5421_CTL1_ADR;
    i2cAcquireBus(&I2CD1);
    retval = i2cMasterTransmitTimeout(&I2CD1, FAN5421_ADDR, tx, 1, rx, 1, TIME_INFINITE);
    i2cReleaseBus(&I2CD1);
    if( retval != MSG_OK ) {
      chprintf(chp, " I2C transaction error: %d"NL, i2cGetErrors(&I2CD1));
    6616:	4808      	ldr	r0, [pc, #32]	; (6638 <__ram0_size__+0x638>)
    6618:	f7fc fb6a 	bl	2cf0 <i2cGetErrors>
    661c:	4907      	ldr	r1, [pc, #28]	; (663c <__ram0_size__+0x63c>)
    661e:	4602      	mov	r2, r0
    6620:	4620      	mov	r0, r4
    6622:	f7fd ffd5 	bl	45d0 <chprintf>
    6626:	e50a      	b.n	603e <__ram0_size__+0x3e>
      break;
    case 1:
      chprintf(chp, "Charge in progress"NL);
      break;
    case 2:
      chprintf(chp, "Charge done"NL);
    6628:	4905      	ldr	r1, [pc, #20]	; (6640 <__ram0_size__+0x640>)
    662a:	f7fd ffd1 	bl	45d0 <chprintf>
      break;
    662e:	e4e1      	b.n	5ff4 <chgCommand+0x274>
	break;
      case 6:
	chprintf(chp, "Timer fault"NL);
	break;
      case 7:
	chprintf(chp, "No battery"NL);
    6630:	4904      	ldr	r1, [pc, #16]	; (6644 <__ram0_size__+0x644>)
    6632:	f7fd ffcd 	bl	45d0 <chprintf>
	break;
    6636:	e4dd      	b.n	5ff4 <chgCommand+0x274>
    6638:	1ffff3f8 	.word	0x1ffff3f8
    663c:	000076e8 	.word	0x000076e8
    6640:	00007b94 	.word	0x00007b94
    6644:	00007c20 	.word	0x00007c20
    6648:	f3af 8000 	nop.w
    664c:	f3af 8000 	nop.w

00006650 <memcpy>:
    6650:	b510      	push	{r4, lr}
    6652:	1e43      	subs	r3, r0, #1
    6654:	440a      	add	r2, r1
    6656:	4291      	cmp	r1, r2
    6658:	d004      	beq.n	6664 <memcpy+0x14>
    665a:	f811 4b01 	ldrb.w	r4, [r1], #1
    665e:	f803 4f01 	strb.w	r4, [r3, #1]!
    6662:	e7f8      	b.n	6656 <memcpy+0x6>
    6664:	bd10      	pop	{r4, pc}
	...

00006670 <memset>:
    6670:	4402      	add	r2, r0
    6672:	4603      	mov	r3, r0
    6674:	4293      	cmp	r3, r2
    6676:	d002      	beq.n	667e <memset+0xe>
    6678:	f803 1b01 	strb.w	r1, [r3], #1
    667c:	e7fa      	b.n	6674 <memset+0x4>
    667e:	4770      	bx	lr

00006680 <strcasecmp>:
    6680:	4b0d      	ldr	r3, [pc, #52]	; (66b8 <strcasecmp+0x38>)
    6682:	b530      	push	{r4, r5, lr}
    6684:	681d      	ldr	r5, [r3, #0]
    6686:	f810 3b01 	ldrb.w	r3, [r0], #1
    668a:	18ea      	adds	r2, r5, r3
    668c:	7852      	ldrb	r2, [r2, #1]
    668e:	f002 0203 	and.w	r2, r2, #3
    6692:	2a01      	cmp	r2, #1
    6694:	f811 2b01 	ldrb.w	r2, [r1], #1
    6698:	eb05 0402 	add.w	r4, r5, r2
    669c:	bf08      	it	eq
    669e:	3320      	addeq	r3, #32
    66a0:	7864      	ldrb	r4, [r4, #1]
    66a2:	f004 0403 	and.w	r4, r4, #3
    66a6:	2c01      	cmp	r4, #1
    66a8:	bf08      	it	eq
    66aa:	3220      	addeq	r2, #32
    66ac:	1a9b      	subs	r3, r3, r2
    66ae:	d101      	bne.n	66b4 <strcasecmp+0x34>
    66b0:	2a00      	cmp	r2, #0
    66b2:	d1e8      	bne.n	6686 <strcasecmp+0x6>
    66b4:	4618      	mov	r0, r3
    66b6:	bd30      	pop	{r4, r5, pc}
    66b8:	1ffff03c 	.word	0x1ffff03c
    66bc:	00000000 	.word	0x00000000

000066c0 <strchr>:
    66c0:	b2c9      	uxtb	r1, r1
    66c2:	4603      	mov	r3, r0
    66c4:	f810 2b01 	ldrb.w	r2, [r0], #1
    66c8:	b11a      	cbz	r2, 66d2 <strchr+0x12>
    66ca:	428a      	cmp	r2, r1
    66cc:	d1f9      	bne.n	66c2 <strchr+0x2>
    66ce:	4618      	mov	r0, r3
    66d0:	4770      	bx	lr
    66d2:	2900      	cmp	r1, #0
    66d4:	bf0c      	ite	eq
    66d6:	4618      	moveq	r0, r3
    66d8:	2000      	movne	r0, #0
    66da:	4770      	bx	lr
    66dc:	0000      	movs	r0, r0
	...

000066e0 <strlen>:
    66e0:	4603      	mov	r3, r0
    66e2:	f813 2b01 	ldrb.w	r2, [r3], #1
    66e6:	2a00      	cmp	r2, #0
    66e8:	d1fb      	bne.n	66e2 <strlen+0x2>
    66ea:	1a18      	subs	r0, r3, r0
    66ec:	3801      	subs	r0, #1
    66ee:	4770      	bx	lr

000066f0 <strstr>:
    66f0:	b530      	push	{r4, r5, lr}
    66f2:	7803      	ldrb	r3, [r0, #0]
    66f4:	b923      	cbnz	r3, 6700 <strstr+0x10>
    66f6:	780b      	ldrb	r3, [r1, #0]
    66f8:	2b00      	cmp	r3, #0
    66fa:	bf18      	it	ne
    66fc:	2000      	movne	r0, #0
    66fe:	bd30      	pop	{r4, r5, pc}
    6700:	4603      	mov	r3, r0
    6702:	3001      	adds	r0, #1
    6704:	781a      	ldrb	r2, [r3, #0]
    6706:	b13a      	cbz	r2, 6718 <strstr+0x28>
    6708:	2200      	movs	r2, #0
    670a:	5c8c      	ldrb	r4, [r1, r2]
    670c:	b134      	cbz	r4, 671c <strstr+0x2c>
    670e:	5c9d      	ldrb	r5, [r3, r2]
    6710:	42a5      	cmp	r5, r4
    6712:	d1f5      	bne.n	6700 <strstr+0x10>
    6714:	3201      	adds	r2, #1
    6716:	e7f8      	b.n	670a <strstr+0x1a>
    6718:	4610      	mov	r0, r2
    671a:	bd30      	pop	{r4, r5, pc}
    671c:	4618      	mov	r0, r3
    671e:	bd30      	pop	{r4, r5, pc}

00006720 <_strtol_r>:
    6720:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6724:	4c40      	ldr	r4, [pc, #256]	; (6828 <_strtol_r+0x108>)
    6726:	f8d4 9000 	ldr.w	r9, [r4]
    672a:	460f      	mov	r7, r1
    672c:	463d      	mov	r5, r7
    672e:	f815 eb01 	ldrb.w	lr, [r5], #1
    6732:	eb09 040e 	add.w	r4, r9, lr
    6736:	7866      	ldrb	r6, [r4, #1]
    6738:	f006 0408 	and.w	r4, r6, #8
    673c:	f004 06ff 	and.w	r6, r4, #255	; 0xff
    6740:	b10c      	cbz	r4, 6746 <_strtol_r+0x26>
    6742:	462f      	mov	r7, r5
    6744:	e7f2      	b.n	672c <_strtol_r+0xc>
    6746:	4674      	mov	r4, lr
    6748:	2c2d      	cmp	r4, #45	; 0x2d
    674a:	d103      	bne.n	6754 <_strtol_r+0x34>
    674c:	1cbd      	adds	r5, r7, #2
    674e:	787c      	ldrb	r4, [r7, #1]
    6750:	2601      	movs	r6, #1
    6752:	e003      	b.n	675c <_strtol_r+0x3c>
    6754:	2c2b      	cmp	r4, #43	; 0x2b
    6756:	bf04      	itt	eq
    6758:	787c      	ldrbeq	r4, [r7, #1]
    675a:	1cbd      	addeq	r5, r7, #2
    675c:	b113      	cbz	r3, 6764 <_strtol_r+0x44>
    675e:	2b10      	cmp	r3, #16
    6760:	d10a      	bne.n	6778 <_strtol_r+0x58>
    6762:	e05a      	b.n	681a <_strtol_r+0xfa>
    6764:	2c30      	cmp	r4, #48	; 0x30
    6766:	d156      	bne.n	6816 <_strtol_r+0xf6>
    6768:	782c      	ldrb	r4, [r5, #0]
    676a:	f004 04df 	and.w	r4, r4, #223	; 0xdf
    676e:	2c58      	cmp	r4, #88	; 0x58
    6770:	d14c      	bne.n	680c <_strtol_r+0xec>
    6772:	786c      	ldrb	r4, [r5, #1]
    6774:	2310      	movs	r3, #16
    6776:	3502      	adds	r5, #2
    6778:	2e00      	cmp	r6, #0
    677a:	bf14      	ite	ne
    677c:	f04f 4800 	movne.w	r8, #2147483648	; 0x80000000
    6780:	f06f 4800 	mvneq.w	r8, #2147483648	; 0x80000000
    6784:	2700      	movs	r7, #0
    6786:	fbb8 faf3 	udiv	sl, r8, r3
    678a:	46be      	mov	lr, r7
    678c:	fb03 881a 	mls	r8, r3, sl, r8
    6790:	eb09 0c04 	add.w	ip, r9, r4
    6794:	f89c c001 	ldrb.w	ip, [ip, #1]
    6798:	f01c 0f04 	tst.w	ip, #4
    679c:	d001      	beq.n	67a2 <_strtol_r+0x82>
    679e:	3c30      	subs	r4, #48	; 0x30
    67a0:	e00b      	b.n	67ba <_strtol_r+0x9a>
    67a2:	f01c 0c03 	ands.w	ip, ip, #3
    67a6:	d01b      	beq.n	67e0 <_strtol_r+0xc0>
    67a8:	f1bc 0f01 	cmp.w	ip, #1
    67ac:	bf0c      	ite	eq
    67ae:	f04f 0c37 	moveq.w	ip, #55	; 0x37
    67b2:	f04f 0c57 	movne.w	ip, #87	; 0x57
    67b6:	ebcc 0404 	rsb	r4, ip, r4
    67ba:	429c      	cmp	r4, r3
    67bc:	da10      	bge.n	67e0 <_strtol_r+0xc0>
    67be:	f1b7 3fff 	cmp.w	r7, #4294967295
    67c2:	d00a      	beq.n	67da <_strtol_r+0xba>
    67c4:	45d6      	cmp	lr, sl
    67c6:	d806      	bhi.n	67d6 <_strtol_r+0xb6>
    67c8:	d101      	bne.n	67ce <_strtol_r+0xae>
    67ca:	4544      	cmp	r4, r8
    67cc:	dc03      	bgt.n	67d6 <_strtol_r+0xb6>
    67ce:	fb03 4e0e 	mla	lr, r3, lr, r4
    67d2:	2701      	movs	r7, #1
    67d4:	e001      	b.n	67da <_strtol_r+0xba>
    67d6:	f04f 37ff 	mov.w	r7, #4294967295
    67da:	f815 4b01 	ldrb.w	r4, [r5], #1
    67de:	e7d7      	b.n	6790 <_strtol_r+0x70>
    67e0:	1c7c      	adds	r4, r7, #1
    67e2:	4673      	mov	r3, lr
    67e4:	d10a      	bne.n	67fc <_strtol_r+0xdc>
    67e6:	2e00      	cmp	r6, #0
    67e8:	f04f 0122 	mov.w	r1, #34	; 0x22
    67ec:	bf14      	ite	ne
    67ee:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
    67f2:	f06f 4300 	mvneq.w	r3, #2147483648	; 0x80000000
    67f6:	6001      	str	r1, [r0, #0]
    67f8:	b92a      	cbnz	r2, 6806 <_strtol_r+0xe6>
    67fa:	e011      	b.n	6820 <_strtol_r+0x100>
    67fc:	b10e      	cbz	r6, 6802 <_strtol_r+0xe2>
    67fe:	f1ce 0300 	rsb	r3, lr, #0
    6802:	b16a      	cbz	r2, 6820 <_strtol_r+0x100>
    6804:	b107      	cbz	r7, 6808 <_strtol_r+0xe8>
    6806:	1e69      	subs	r1, r5, #1
    6808:	6011      	str	r1, [r2, #0]
    680a:	e009      	b.n	6820 <_strtol_r+0x100>
    680c:	2430      	movs	r4, #48	; 0x30
    680e:	2b00      	cmp	r3, #0
    6810:	d1b2      	bne.n	6778 <_strtol_r+0x58>
    6812:	2308      	movs	r3, #8
    6814:	e7b0      	b.n	6778 <_strtol_r+0x58>
    6816:	230a      	movs	r3, #10
    6818:	e7ae      	b.n	6778 <_strtol_r+0x58>
    681a:	2c30      	cmp	r4, #48	; 0x30
    681c:	d1ac      	bne.n	6778 <_strtol_r+0x58>
    681e:	e7a3      	b.n	6768 <_strtol_r+0x48>
    6820:	4618      	mov	r0, r3
    6822:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6826:	bf00      	nop
    6828:	1ffff03c 	.word	0x1ffff03c
    682c:	00000000 	.word	0x00000000

00006830 <strtol>:
    6830:	b530      	push	{r4, r5, lr}
    6832:	4613      	mov	r3, r2
    6834:	4a04      	ldr	r2, [pc, #16]	; (6848 <strtol+0x18>)
    6836:	4605      	mov	r5, r0
    6838:	460c      	mov	r4, r1
    683a:	6810      	ldr	r0, [r2, #0]
    683c:	4629      	mov	r1, r5
    683e:	4622      	mov	r2, r4
    6840:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    6844:	f7ff bf6c 	b.w	6720 <_strtol_r>
    6848:	1ffff0a0 	.word	0x1ffff0a0
    684c:	00000000 	.word	0x00000000
    6850:	00160014 	.word	0x00160014
    6854:	001a0018 	.word	0x001a0018
    6858:	001e001c 	.word	0x001e001c
    685c:	00280022 	.word	0x00280022
    6860:	0020001c 	.word	0x0020001c
    6864:	00280024 	.word	0x00280024
    6868:	0030002c 	.word	0x0030002c
    686c:	00440038 	.word	0x00440038
    6870:	00380030 	.word	0x00380030
    6874:	00480040 	.word	0x00480040
    6878:	00580050 	.word	0x00580050
    687c:	00800068 	.word	0x00800068
    6880:	00600050 	.word	0x00600050
    6884:	00800070 	.word	0x00800070
    6888:	00a00090 	.word	0x00a00090
    688c:	00f000c0 	.word	0x00f000c0
    6890:	00c000a0 	.word	0x00c000a0
    6894:	010000e0 	.word	0x010000e0
    6898:	01400120 	.word	0x01400120
    689c:	01e00180 	.word	0x01e00180
    68a0:	01800140 	.word	0x01800140
    68a4:	020001c0 	.word	0x020001c0
    68a8:	02800240 	.word	0x02800240
    68ac:	03c00300 	.word	0x03c00300
    68b0:	03000280 	.word	0x03000280
    68b4:	04000380 	.word	0x04000380
    68b8:	05000480 	.word	0x05000480
    68bc:	07800600 	.word	0x07800600
    68c0:	06000500 	.word	0x06000500
    68c4:	08000700 	.word	0x08000700
    68c8:	0a000900 	.word	0x0a000900
    68cc:	0f000c00 	.word	0x0f000c00

000068d0 <ram_areas>:
    68d0:	0000801c 20000584 20000584 20000584     ....... ... ... 
    68e0:	0000801c 00000000 00000000 00000000     ................
    68f0:	0000801c 00000000 00000000 00000000     ................
    6900:	0000801c 00000000 00000000 00000000     ................
    6910:	0000801c 00000000 00000000 00000000     ................
    6920:	0000801c 00000000 00000000 00000000     ................
    6930:	0000801c 00000000 00000000 00000000     ................
    6940:	0000801c 00000000 00000000 00000000     ................

00006950 <idle_descriptor.6742>:
    6950:	00006970 1ffff0a8 1ffff228 00000001     pi......(.......
    6960:	00000ec1 00000000 00000000 00000000     ................
    6970:	656c6469 00000000 00000000 00000000     idle............
    6980:	31235653 00000000 32235653 00000000     SV#1....SV#2....
    6990:	33235653 00000000 34235653 00000000     SV#3....SV#4....
    69a0:	35235653 00000000 36235653 00000000     SV#5....SV#6....
    69b0:	37235653 00000000 38235653 00000000     SV#7....SV#8....
    69c0:	39235653 00000000 31235653 00000030     SV#9....SV#10...
    69d0:	31235653 00000031 00000000 00000000     SV#11...........

000069e0 <__func__.6743>:
    69e0:	54566863 65536f44 00004974 00000000     chVTDoSetI......

000069f0 <__func__.6750>:
    69f0:	54566863 65526f44 49746573 00000000     chVTDoResetI....

00006a00 <__func__.6776>:
    6a00:	63536863 6b615768 53707565 00000000     chSchWakeupS....

00006a10 <__func__.6740>:
    6a10:	63536863 61655268 00497964 00000000     chSchReadyI.....
    6a20:	63617473 766f206b 6c667265 0000776f     stack overflow..

00006a30 <__func__.6747>:
    6a30:	63536863 61655268 68417964 49646165     chSchReadyAheadI
	...

00006a50 <__func__.6771>:
    6a50:	68546863 65724364 53657461 69746174     chThdCreateStati
    6a60:	00000063 00000000 00000000 00000000     c...............

00006a70 <__func__.6061>:
    6a70:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006a80 <__func__.6783>:
    6a80:	68546863 6c655264 65736165 00000000     chThdRelease....

00006a90 <__func__.6836>:
    6a90:	68546863 73755364 646e6570 656d6954     chThdSuspendTime
    6aa0:	5374756f 00000000 00000000 00000000     outS............

00006ab0 <__func__.6842>:
    6ab0:	68546863 73655264 49656d75 00000000     chThdResumeI....

00006ac0 <__func__.6262>:
    6ac0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
    6ad0:	00497478 00000000 00000000 00000000     xtI.............
    6ae0:	616e6f6e 0000656d 00000000 00000000     noname..........

00006af0 <__func__.6798>:
    6af0:	68546863 69784564 00005374 00000000     chThdExitS......

00006b00 <__func__.6250>:
    6b00:	68546863 656c5364 00537065 00000000     chThdSleepS.....

00006b10 <__func__.6803>:
    6b10:	68546863 69615764 00000074 00000000     chThdWait.......

00006b20 <__func__.6749>:
    6b20:	68546863 65724364 53657461 65707375     chThdCreateSuspe
    6b30:	6465646e 00000049 00000000 00000000     ndedI...........

00006b40 <__func__.6762>:
    6b40:	68546863 65724364 00657461 00000000     chThdCreate.....

00006b50 <ch_debug>:
    6b50:	6e69616d 20001600 08600404 1814100c     main... ..`.....
    6b60:	2221201c 00000023 00000000 00000000     . !"#...........

00006b70 <__func__.7101>:
    6b70:	65526863 78654e67 72685474 00646165     chRegNextThread.

00006b80 <__func__.6421>:
    6b80:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006b90 <__func__.6766>:
    6b90:	744d6863 6c6e5578 006b636f 00000000     chMtxUnlock.....

00006ba0 <__func__.6061>:
    6ba0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006bb0 <__func__.6735>:
    6bb0:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

00006bc0 <__func__.6743>:
    6bc0:	744d6863 636f4c78 0000536b 00000000     chMtxLockS......

00006bd0 <__func__.6061>:
    6bd0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006be0 <__func__.6777>:
    6be0:	76456863 67695374 496c616e 00000000     chEvtSignalI....

00006bf0 <__func__.6791>:
    6bf0:	76456863 73694474 63746170 00000068     chEvtDispatch...

00006c00 <__func__.6738>:
    6c00:	76456863 67655274 65747369 73614d72     chEvtRegisterMas
    6c10:	7469576b 616c4668 00007367 00000000     kWithFlags......

00006c20 <__func__.6744>:
    6c20:	76456863 726e5574 73696765 00726574     chEvtUnregister.

00006c30 <__func__.6760>:
    6c30:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
    6c40:	49736761 00000000 00000000 00000000     agsI............

00006c50 <__func__.6061>:
    6c50:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006c60 <__func__.6061>:
    6c60:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006c70 <__func__.6746>:
    6c70:	6f436863 6c416572 41636f6c 6e67696c     chCoreAllocAlign
    6c80:	00496465 00000000 00000000 00000000     edI.............

00006c90 <__func__.6765>:
    6c90:	65486863 72467061 00006565 00000000     chHeapFree......

00006ca0 <__func__.6751>:
    6ca0:	65486863 6c417061 41636f6c 6e67696c     chHeapAllocAlign
    6cb0:	00006465 00000000 00000000 00000000     ed..............

00006cc0 <__func__.6061>:
    6cc0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006cd0 <__func__.6761>:
    6cd0:	6f506863 72466c6f 00496565 00000000     chPoolFreeI.....

00006ce0 <__func__.6061>:
    6ce0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006cf0 <__func__.7634>:
    6cf0:	7257716f 54657469 6f656d69 00007475     oqWriteTimeout..

00006d00 <__func__.7595>:
    6d00:	65527169 69546461 756f656d 00000074     iqReadTimeout...

00006d10 <__func__.6061>:
    6d10:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006d20 <__func__.7605>:
    6d20:	41633269 69757163 75426572 00000073     i2cAcquireBus...

00006d30 <__func__.7609>:
    6d30:	52633269 61656c65 75426573 00000073     i2cReleaseBus...

00006d40 <__func__.7573>:
    6d40:	53633269 74726174 00000000 00000000     i2cStart........

00006d50 <__func__.7581>:
    6d50:	47633269 72457465 73726f72 00000000     i2cGetErrors....

00006d60 <__func__.7592>:
    6d60:	4d633269 65747361 61725472 696d736e     i2cMasterTransmi
    6d70:	6d695474 74756f65 00000000 00000000     tTimeout........

00006d80 <__func__.6061>:
    6d80:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006d90 <__func__.7614>:
    6d90:	74536473 00747261 00000000 00000000     sdStart.........

00006da0 <vmt>:
    6da0:	00002e61 00002e41 00002ea1 00002e81     a...A...........
    6db0:	00002e91 00002e71 00002e51 00002e31     ....q...Q...1...

00006dc0 <__func__.6061>:
    6dc0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006dd0 <__func__.7573>:
    6dd0:	53697073 74726174 00000000 00000000     spiStart........

00006de0 <__func__.7581>:
    6de0:	53697073 63656c65 00000074 00000000     spiSelect.......

00006df0 <__func__.7585>:
    6df0:	55697073 6c65736e 00746365 00000000     spiUnselect.....

00006e00 <__func__.7574>:
    6e00:	6369766e 53746553 65747379 6e61486d     nvicSetSystemHan
    6e10:	72656c64 6f697250 79746972 00000000     dlerPriority....

00006e20 <__func__.7578>:
    6e20:	6c61705f 646c6c5f 7465735f 6d646170     _pal_lld_setpadm
    6e30:	0065646f 00000000 00000000 00000000     ode.............

00006e40 <default_config>:
    6e40:	0001c200 00000000 00000000 00000000     ................

00006e50 <__func__.6061>:
    6e50:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00006e60 <pal_default_config>:
    6e60:	400ff000 00000016 00000001 00000001     ...@............
    6e70:	00000016 00000001 00000001 00000001     ................
    6e80:	00000001 00000001 00000001 00000001     ................
    6e90:	00000001 00000002 00000002 00000001     ................
    6ea0:	00000001 00000001 00000001 00000006     ................
    6eb0:	00000006 00000001 00000001 00000001     ................
    6ec0:	00000001 00000001 00000001 00000001     ................
    6ed0:	00000001 00000001 00000001 00000001     ................
    6ee0:	00000001 400ff040 00000003 00000006     ....@..@........
    6ef0:	00000011 00000011 00000001 00000001     ................
    6f00:	00000001 00000001 00000001 00000001     ................
    6f10:	00000001 00000001 00000001 00000001     ................
    6f20:	00000001 00000001 00000012 00000006     ................
    6f30:	00000006 00000007 00000001 00000001     ................
    6f40:	00000001 00000001 00000001 00000001     ................
    6f50:	00000001 00000001 00000001 00000001     ................
    6f60:	00000001 00000001 400ff080 00000002     ...........@....
    6f70:	00000002 00000011 00000016 00000016     ................
    6f80:	00000011 00000011 00000011 00000006     ................
    6f90:	00000006 00000011 00000011 00000001     ................
    6fa0:	00000001 00000001 00000001 00000001     ................
    6fb0:	00000001 00000001 00000001 00000001     ................
    6fc0:	00000001 00000001 00000001 00000001     ................
    6fd0:	00000001 00000001 00000001 00000001     ................
    6fe0:	00000001 00000001 00000001 400ff0c0     ...............@
    6ff0:	00000003 00000006 00000012 00000012     ................
    7000:	00000006 00000016 00000016 00000016     ................
    7010:	00000001 00000001 00000001 00000001     ................
    7020:	00000001 00000001 00000001 00000001     ................
    7030:	00000001 00000001 00000001 00000001     ................
    7040:	00000001 00000001 00000001 00000001     ................
    7050:	00000001 00000001 00000001 00000001     ................
    7060:	00000001 00000001 00000001 00000001     ................
    7070:	400ff100 00000006 00000012 00000001     ...@............
    7080:	00000001 00000001 00000001 00000001     ................
    7090:	00000001 00000001 00000001 00000001     ................
    70a0:	00000001 00000001 00000001 00000001     ................
    70b0:	00000001 00000001 00000001 00000001     ................
    70c0:	00000001 00000001 00000001 00000001     ................
    70d0:	00000001 00000001 00000001 00000001     ................
    70e0:	00000001 00000001 00000001 00000001     ................
    70f0:	00000001 00000000 00000000 00000000     ................
    7100:	6c756e28 0000296c 00000000 00000000     (null)..........

00007110 <pow10>:
    7110:	0000000a 00000064 000003e8 00002710     ....d........'..
    7120:	000186a0 000f4240 00989680 05f5e100     ....@B..........
    7130:	3b9aca00 00000000 00000000 00000000     ...;............
    7140:	64255b1b 255b1b44 00004364 004b5b1b     .[%dD.[%dC...[K.
    7150:	00007325 203e6863 00000000 00732520     %s..ch> .... %s.
    7160:	706c6568 00000000 62696843 2f534f69     help....ChibiOS/
    7170:	53205452 6c6c6568 00000a0d 206f6f74     RT Shell....too 
    7180:	796e616d 67726120 6e656d75 0a0d7374     many arguments..
    7190:	00000000 67617355 25203a65 000a0d73     ....Usage: %s...
    71a0:	6d6d6f43 73646e61 6568203a 0020706c     Commands: help .
    71b0:	00207325 0a0d3f20 00000000 00000000     %s . ?..........

000071c0 <states.7999>:
    71c0:	00007440 00007448 00007450 00007458     @t..Ht..Pt..Xt..
    71d0:	00007464 0000746c 00007474 0000747c     dt..lt..tt..|t..
    71e0:	00007484 00007490 00007498 000074a0     .t...t...t...t..
    71f0:	000074ac 000074b4 000074bc 000074c4     .t...t...t...t..
    7200:	6f686365 656d2220 67617373 00002265     echo "message"..
    7210:	0a0d7325 00000000 6f666e69 00000000     %s......info....
    7220:	6e72654b 203a6c65 20202020 73252020     Kernel:       %s
    7230:	00000a0d 2e302e34 00000030 706d6f43     ....4.0.0...Comp
    7240:	72656c69 2020203a 73252020 00000a0d     iler:     %s....
    7250:	20434347 2e392e34 00000032 68637241     GCC 4.9.2...Arch
    7260:	63657469 65727574 7325203a 00000a0d     itecture: %s....
    7270:	764d5241 4d2d4537 00000000 65726f43     ARMv7E-M....Core
    7280:	72615620 746e6169 7325203a 00000a0d      Variant: %s....
    7290:	74726f43 4d2d7865 00004634 74726f50     Cortex-M4F..Port
    72a0:	666e4920 20203a6f 73252020 00000a0d      Info:    %s....
    72b0:	61766441 6465636e 72656b20 206c656e     Advanced kernel 
    72c0:	65646f6d 00000000 74616c50 6d726f66     mode....Platform
    72d0:	2020203a 73252020 00000a0d 656e694b     :     %s....Kine
    72e0:	00736974 72616f42 20203a64 20202020     tis.Board:      
    72f0:	73252020 00000a0d 72746e49 6570736f       %s....Introspe
    7300:	6f697463 6e45206e 656e6967 00000000     ction Engine....
    7310:	6c697542 69742064 203a656d 73252020     Build time:   %s
    7320:	73257325 00000a0d 20766f4e 32203032     %s%s....Nov 20 2
    7330:	00363130 00202d20 353a3930 38313a38     016. - .09:58:18
    7340:	00000000 65726874 00736461 6c6b7473     ....threads.stkl
    7350:	74696d69 20202020 63617473 2020206b     imit    stack   
    7360:	64612020 72207264 20736665 6f697270       addr refs prio
    7370:	20202020 61747320 20206574 20202020          state      
    7380:	6e202020 0d656d61 000a0d0a 6c383025        name.....%08l
    7390:	30252078 20786c38 6c383025 34252078     x %08lx %08lx %4
    73a0:	2520756c 20756c34 20733925 73323125     lu %4lu %9s %12s
    73b0:	00000a0d 006d656d 65726f63 65726620     ....mem.core fre
    73c0:	656d2065 79726f6d 25203a20 79622075     e memory : %u by
    73d0:	0d736574 0000000a 70616568 61726620     tes.....heap fra
    73e0:	6e656d67 20207374 25203a20 000a0d75     gments   : %u...
    73f0:	70616568 65726620 6f742065 206c6174     heap free total 
    7400:	25203a20 79622075 0d736574 0000000a      : %u bytes.....
    7410:	70616568 65726620 616c2065 73656772     heap free larges
    7420:	25203a74 79622075 0d736574 0000000a     t: %u bytes.....
    7430:	74737973 00656d69 0d756c25 0000000a     systime.%lu.....
    7440:	44414552 00000059 52525543 00544e45     READY...CURRENT.
    7450:	54535457 00545241 50535553 45444e45     WTSTART.SUSPENDE
    7460:	00000044 55455551 00004445 45535457     D...QUEUED..WTSE
    7470:	0000004d 544d5457 00000058 4f435457     M...WTMTX...WTCO
    7480:	0000444e 45454c53 474e4950 00000000     ND..SLEEPING....
    7490:	58455457 00005449 524f5457 00545645     WTEXIT..WTOREVT.
    74a0:	4e415457 54564544 00000000 4d444e53     WTANDEVT....SNDM
    74b0:	00514753 4d444e53 00004753 534d5457     SGQ.SNDMSG..WTMS
    74c0:	00000047 414e4946 0000004c 6f686365     G...FINAL...echo
	...

000074e0 <__func__.6421>:
    74e0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000074f0 <i2c2_config>:
    74f0:	00061a80 00000000 00000000 00000000     ................

00007500 <i2c_config>:
    7500:	000186a0 00000000 00000000 00000000     ................
    7510:	6863724f 20647261 6e657645 68542074     Orchard Event Th
    7520:	64616572 00000073 0a0d0a0d 00000000     reads...........
    7530:	62205a58 6c746f6f 6564616f 20202e72     XZ bootloader.  
    7540:	65736142 6e6f2064 69756220 2520646c     Based on build %
    7550:	000a0d73 65726f43 65726620 656d2065     s...Core free me
    7560:	79726f6d 25203a20 79622064 0d736574     mory : %d bytes.
    7570:	0000000a 6c656873 0000006c 00000000     ....shell.......

00007580 <spi_config>:
    7580:	00000000 400ff0c0 00000004 be000000     .......@........

00007590 <serialConfig>:
    7590:	0001c200 00000000 00000000 00000000     ................
    75a0:	63617453 6863206b 206b6365 6c696166     Stack check fail
	...

000075c0 <shell_cfg>:
    75c0:	1ffff328 000075e0 20000248 00000200     (....u..H.. ....
    75d0:	20000448 00000000 00000000 00000000     H.. ............

000075e0 <commands>:
    75e0:	00007630 00005561 00007638 000053e1     0v..aU..8v...S..
    75f0:	0000763c 00005471 00007640 000054f1     <v..qT..@v...T..
    7600:	00007644 00005d81 00007648 00005861     Dv...]..Hv..aX..
    7610:	0000764c 00005bc1 00007654 00005651     Lv...[..Tv..QV..
    7620:	0000765c 00005301 00000000 00000000     \v...S..........
    7630:	74736574 00000000 00633269 00000063     test....i2c.c...
    7640:	00007263 00676863 00006767 61677066     cr..chg.gg..fpga
    7650:	00000000 6f6c7075 00006461 00786667     ....upload..gfx.
    7660:	38373161 38623231 62643236 37373938     a17812b862db8977
    7670:	37316631 35356136 39353338 35656237     1f176a5583597be5
    7680:	38663738 32613135 00000000 00000000     87f851a2........
    7690:	67617355 67203a65 5b207866 62726576     Usage: gfx [verb
    76a0:	0a0d3a5d 00000000 20202020 20206469     ]:......    id  
    76b0:	20202020 53532020 30333144 44492036           SSD1306 ID
    76c0:	00000a0d 20202020 65736572 20202074     ....    reset   
    76d0:	65522020 20746573 70736964 0d79616c       Reset display.
    76e0:	0000000a 00006469 43324920 61727420     ....id.. I2C tra
    76f0:	6361736e 6e6f6974 72726520 203a726f     nsaction error: 
    7700:	0a0d6425 00000000 756c6156 666f2065     %d......Value of
    7710:	38783020 73282031 6c756f68 65622064      0x81 (should be
    7720:	37783020 65642046 6c756166 203a2974      0x7F default): 
    7730:	78323025 00000a0d 65736572 00000074     %02x....reset...
    7740:	65726e55 6e676f63 64657a69 6d6f6320     Unrecognized com
    7750:	646e616d 7325203a 00000a0d 00000000     mand: %s........
    7760:	30250a0d 203a7832 00000000 78323025     ..%02x: ....%02x
    7770:	00000020 67617355 63203a65 64613c20      ...Usage: c <ad
    7780:	203e7264 7461643c 0a0d3e61 00000000     dr> <data>......
    7790:	67617355 63203a65 613c2072 3e726464     Usage: cr <addr>
    77a0:	00000a0d 64616572 3025203a 202c7832     ....read: %02x, 
    77b0:	76746572 203a6c61 0a0d6425 00000000     retval: %d......
    77c0:	74736574 00000a0d 00000000 00000000     test............
    77d0:	6f6c7075 64656461 20642520 65747962     uploaded %d byte
    77e0:	6f742073 47504620 000a0d41 746e6573     s to FPGA...sent
    77f0:	20642520 6d6d7564 79622079 20736574      %d dummy bytes 
    7800:	61206f74 76697463 20657461 0a0d4f49     to activate IO..
    7810:	00000000 67617355 75203a65 616f6c70     ....Usage: uploa
    7820:	765b2064 5d627265 000a0d3a 20202020     d [verb]:...    
    7830:	20206f67 20202020 74532020 20747261     go        Start 
    7840:	6f6c7075 0a0d6461 00000000 20202020     upload......    
    7850:	74736574 20202020 65732020 6120646e     test      send a
    7860:	73657420 61702074 74656b63 00000a0d      test packet....
    7870:	00006f67 41475046 6e6f6320 20676966     go..FPGA config 
    7880:	61657261 7a697320 64252065 00000a0d     area size %d....
    7890:	67617355 63203a65 5b206768 62726576     Usage: chg [verb
    78a0:	0a0d3a5d 00000000 20202020 20206469     ]:......    id  
    78b0:	20202020 68432020 65677261 68632072           Charger ch
    78c0:	49207069 000a0d44 20202020 20636f73     ip ID...    soc 
    78d0:	20202020 74532020 20657461 4320666f           State of C
    78e0:	67726168 000a0d65 20202020 706d7564     harge...    dump
    78f0:	20202020 75442020 6720706d 65722067           Dump gg re
    7900:	0a0d7367 00000000 20202020 20206e6f     gs......    on  
    7910:	20202020 65532020 67672074 0d6e6f20           Set gg on.
    7920:	0000000a 20202020 79627473 20202020     ....    stby    
    7930:	65532020 67672074 61747320 7962646e       Set gg standby
    7940:	00000a0d 63204449 3a65646f 34302520     ....ID code: %04
    7950:	000a0d78 00636f73 74617453 666f2065     x...soc.State of
    7960:	61686320 3a656772 312e2520 0d252566      charge: %.1f%%.
    7970:	0000000a 746c6f56 3a656761 6d642520     ....Voltage: %dm
    7980:	000a0d56 706d7564 00000000 78343025     V...dump....%04x
    7990:	00000020 00006e6f 79627473 00000000      ...on..stby....
    79a0:	67617355 66203a65 20616770 7265765b     Usage: fpga [ver
    79b0:	0d3a5d62 0000000a 20202020 65736572     b]:.....    rese
    79c0:	20202074 65722020 20746573 41475046     t     reset FPGA
    79d0:	00000a0d 20202020 74617473 20202020     ....    stat    
    79e0:	6f632020 6769666e 61747320 0a0d6574       config state..
    79f0:	00000000 20202020 666e6f63 20206769     ....    config  
    7a00:	6f6c2020 63206461 69666e6f 000a0d67       load config...
    7a10:	74617473 00000000 656e6f44 6e697020     stat....Done pin
    7a20:	61747320 3a737574 000a0d20 68676968      status: ...high
    7a30:	00000a0d 0d776f6c 0000000a 666e6f63     ....low.....conf
    7a40:	00006769 00000000 00000000 00000000     ig..............
    7a50:	20202020 74617473 20202020 68432020         stat      Ch
    7a60:	65677261 74732072 73757461 00000a0d     arger status....
    7a70:	20202020 72617473 20202074 6e452020         start     En
    7a80:	656c6261 61686320 6e696772 20262067     able charging & 
    7a90:	7065656b 696c612d 74206576 72656d69     keep-alive timer
    7aa0:	00000a0d 20202020 706f7473 20202020     ....    stop    
    7ab0:	69442020 6c626173 68632065 69677261       Disable chargi
    7ac0:	2620676e 65656b20 6c612d70 20657669     ng & keep-alive 
    7ad0:	656d6974 000a0d72 20202020 6f747561     timer...    auto
    7ae0:	20202020 65532020 61732074 6420656e           Set sane d
    7af0:	75616665 2073746c 656f6428 74276e73     efaults (doesn't
    7b00:	61747320 6b207472 2d706565 76696c61      start keep-aliv
    7b10:	0a0d2965 00000000 20202020 706d7564     e)......    dump
    7b20:	20202020 61522020 75642077 6f20706d           Raw dump o
    7b30:	65722066 74736967 0d737265 0000000a     f registers.....
    7b40:	63204449 3a65646f 32302520 000a0d78     ID code: %02x...
    7b50:	72617473 00000074 706f7473 00000000     start...stop....
    7b60:	6f747561 00000000 74617453 203a7375     auto....Status: 
    7b70:	00000000 64616552 000a0d79 72616843     ....Ready...Char
    7b80:	69206567 7270206e 6572676f 0a0d7373     ge in progress..
    7b90:	00000000 72616843 64206567 0d656e6f     ....Charge done.
    7ba0:	0000000a 6c756146 00002074 726e7528     ....Fault ..(unr
    7bb0:	68636165 656c6261 000a0d29 73756256     eachable)...Vbus
    7bc0:	50564f20 00000a0d 65656c53 6f6d2070      OVP....Sleep mo
    7bd0:	0a0d6564 00000000 726f6f50 706e6920     de......Poor inp
    7be0:	73207475 6372756f 000a0d65 74746142     ut source...Batt
    7bf0:	20797265 0d50564f 0000000a 72656854     ery OVP.....Ther
    7c00:	206c616d 74756873 6e776f64 00000a0d     mal shutdown....
    7c10:	656d6954 61662072 0d746c75 0000000a     Timer fault.....
    7c20:	62206f4e 65747461 0a0d7972 00000000     No battery......
    7c30:	54415453 00000020 62616e65 0d64656c     STAT ...enabled.
    7c40:	0000000a 61736964 64656c62 00000a0d     ....disabled....
    7c50:	6b616557 74616220 79726574 72687420     Weak battery thr
    7c60:	6f687365 203a646c 64252e33 000a0d56     eshold: 3.%dV...
    7c70:	72616843 63206567 65727275 7420746e     Charge current t
    7c80:	696d7265 6974616e 00206e6f 72616843     ermination .Char
    7c90:	20726567 00000000 68676948 706d6920     ger ....High imp
    7ca0:	6e616465 6d206563 2065646f 00000000     edance mode ....
    7cb0:	616f6c46 6f762074 6761746c 00002065     Float voltage ..
    7cc0:	566d6425 00000a0d 61736944 20656c62     %dmV....Disable 
    7cd0:	3a6e6970 00000020 68676968 6863202c     pin: ...high, ch
    7ce0:	69677261 6420676e 62617369 0d64656c     arging disabled.
    7cf0:	0000000a 2c776f6c 61686320 6e696772     ....low, chargin
    7d00:	6f632067 6f72746e 656c6c6c 79622064     g controllled by
    7d10:	43324920 00000a0d 6b616557 61686320      I2C....Weak cha
    7d20:	72656772 0000203a 20746f6e 65746564     rger: ..not dete
    7d30:	64657463 00000a0d 6b616557 61686320     cted....Weak cha
    7d40:	72656772 65656b20 62612d70 2065766f     rger keep-above 
    7d50:	746c6f76 3a656761 6d642520 000a0d56     voltage: %dmV...
    7d60:	72616843 63206567 65727275 7020746e     Charge current p
    7d70:	72676f72 696d6d61 203a676e 00000000     rogramming: ....
    7d80:	65786966 74612064 35323320 0a0d416d     fixed at 325mA..
    7d90:	00000000 20726570 48434f49 45475241     ....per IOCHARGE
    7da0:	6c656220 0a0d776f 00000000 48434f49      below......IOCH
    7db0:	45475241 6f727020 6d617267 6c62616d     ARGE programmabl
    7dc0:	68632065 65677261 72756320 746e6572     e charge current
    7dd0:	6d696c20 203a7469 416d6425 00000a0d      limit: %dmA....
    7de0:	6d726554 74616e69 206e6f69 72727563     Termination curr
    7df0:	20746e65 696d696c 25203a74 0d416d64     ent limit: %dmA.
    7e00:	0000000a 2078614d 48434f49 45475241     ....Max IOCHARGE
    7e10:	66617320 20797465 696d696c 25203a74      safety limit: %
    7e20:	0d416d64 0000000a 2078614d 74616256     dmA.....Max Vbat
    7e30:	66617320 20797465 696d696c 25203a74      safety limit: %
    7e40:	0d566d64 0000000a 00000000 00000000     dmV.............

00007e50 <__func__.7014>:
    7e50:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00007e60 <_ctype_>:
    7e60:	20202000 20202020 28282020 20282828     .         ((((( 
    7e70:	20202020 20202020 20202020 20202020                     
    7e80:	10108820 10101010 10101010 10101010      ...............
    7e90:	04040410 04040404 10040404 10101010     ................
    7ea0:	41411010 41414141 01010101 01010101     ..AAAAAA........
    7eb0:	01010101 01010101 01010101 10101010     ................
    7ec0:	42421010 42424242 02020202 02020202     ..BBBBBB........
    7ed0:	02020202 02020202 02020202 10101010     ................
    7ee0:	00000020 00000000 00000000 00000000      ...............
	...
    7f70:	00000043                                         C.
